import {
  constructFrom,
  enUS,
  getDefaultOptions,
  millisecondsInDay,
  millisecondsInHour,
  millisecondsInMinute,
  millisecondsInSecond,
  millisecondsInWeek,
  normalizeDates,
  startOfWeek,
  toDate
} from "./chunk-EKJFMIAH.js";
import "./chunk-HYZ2CRGS.js";
import {
  Fragment,
  Teleport,
  Transition,
  computed,
  createBaseVNode,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createSlots,
  createTextVNode,
  createVNode,
  defineComponent,
  getCurrentScope,
  guardReactiveProps,
  h,
  inject,
  mergeDefaults,
  mergeProps,
  nextTick,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  onBeforeUpdate,
  onMounted,
  onScopeDispose,
  onUnmounted,
  openBlock,
  provide,
  reactive,
  readonly,
  ref,
  renderList,
  renderSlot,
  resolveDynamicComponent,
  shallowReadonly,
  shallowRef,
  toDisplayString,
  toRef,
  toValue,
  unref,
  useSlots,
  useTemplateRef,
  vShow,
  watch,
  withCtx,
  withDirectives,
  withKeys,
  withModifiers
} from "./chunk-QCNYTOAH.js";
import {
  __publicField
} from "./chunk-L6OFPWCY.js";

// node_modules/@vueuse/shared/dist/index.js
var isClient = typeof window !== "undefined" && typeof document !== "undefined";
var isWorker = typeof WorkerGlobalScope !== "undefined" && globalThis instanceof WorkerGlobalScope;
var toString = Object.prototype.toString;
var isObject = (val) => toString.call(val) === "[object Object]";
var noop = () => {
};
var isIOS = getIsIOS();
function getIsIOS() {
  var _window, _window2, _window3;
  return isClient && !!((_window = window) === null || _window === void 0 || (_window = _window.navigator) === null || _window === void 0 ? void 0 : _window.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((_window2 = window) === null || _window2 === void 0 || (_window2 = _window2.navigator) === null || _window2 === void 0 ? void 0 : _window2.maxTouchPoints) > 2 && /iPad|Macintosh/.test((_window3 = window) === null || _window3 === void 0 ? void 0 : _window3.navigator.userAgent));
}
function identity(arg) {
  return arg;
}
function toArray(value) {
  return Array.isArray(value) ? value : [value];
}
function cacheStringFunction(fn) {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    return cache[str] || (cache[str] = fn(str));
  };
}
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
var camelizeRE = /-(\w)/g;
var camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
});
function watchImmediate(source, cb, options) {
  return watch(source, cb, {
    ...options,
    immediate: true
  });
}

// node_modules/@vueuse/core/dist/index.js
var defaultWindow = isClient ? window : void 0;
var defaultDocument = isClient ? window.document : void 0;
var defaultNavigator = isClient ? window.navigator : void 0;
var defaultLocation = isClient ? window.location : void 0;
function unrefElement(elRef) {
  var _$el;
  const plain = toValue(elRef);
  return (_$el = plain === null || plain === void 0 ? void 0 : plain.$el) !== null && _$el !== void 0 ? _$el : plain;
}
function useEventListener(...args) {
  const register = (el2, event, listener, options) => {
    el2.addEventListener(event, listener, options);
    return () => el2.removeEventListener(event, listener, options);
  };
  const firstParamTargets = computed(() => {
    const test = toArray(toValue(args[0])).filter((e) => e != null);
    return test.every((e) => typeof e !== "string") ? test : void 0;
  });
  return watchImmediate(() => {
    var _firstParamTargets$va, _firstParamTargets$va2;
    return [
      (_firstParamTargets$va = (_firstParamTargets$va2 = firstParamTargets.value) === null || _firstParamTargets$va2 === void 0 ? void 0 : _firstParamTargets$va2.map((e) => unrefElement(e))) !== null && _firstParamTargets$va !== void 0 ? _firstParamTargets$va : [defaultWindow].filter((e) => e != null),
      toArray(toValue(firstParamTargets.value ? args[1] : args[0])),
      toArray(unref(firstParamTargets.value ? args[2] : args[1])),
      toValue(firstParamTargets.value ? args[3] : args[2])
    ];
  }, ([raw_targets, raw_events, raw_listeners, raw_options], _, onCleanup) => {
    if (!(raw_targets === null || raw_targets === void 0 ? void 0 : raw_targets.length) || !(raw_events === null || raw_events === void 0 ? void 0 : raw_events.length) || !(raw_listeners === null || raw_listeners === void 0 ? void 0 : raw_listeners.length)) return;
    const optionsClone = isObject(raw_options) ? { ...raw_options } : raw_options;
    const cleanups = raw_targets.flatMap((el2) => raw_events.flatMap((event) => raw_listeners.map((listener) => register(el2, event, listener, optionsClone))));
    onCleanup(() => {
      cleanups.forEach((fn) => fn());
    });
  }, { flush: "post" });
}
var _iOSWorkaround = false;
function onClickOutside(target, handler, options = {}) {
  const { window: window$1 = defaultWindow, ignore = [], capture = true, detectIframe = false, controls = false } = options;
  if (!window$1) return controls ? {
    stop: noop,
    cancel: noop,
    trigger: noop
  } : noop;
  if (isIOS && !_iOSWorkaround) {
    _iOSWorkaround = true;
    const listenerOptions = { passive: true };
    Array.from(window$1.document.body.children).forEach((el2) => el2.addEventListener("click", noop, listenerOptions));
    window$1.document.documentElement.addEventListener("click", noop, listenerOptions);
  }
  let shouldListen = true;
  const shouldIgnore = (event) => {
    return toValue(ignore).some((target$1) => {
      if (typeof target$1 === "string") return Array.from(window$1.document.querySelectorAll(target$1)).some((el2) => el2 === event.target || event.composedPath().includes(el2));
      else {
        const el2 = unrefElement(target$1);
        return el2 && (event.target === el2 || event.composedPath().includes(el2));
      }
    });
  };
  function hasMultipleRoots(target$1) {
    const vm = toValue(target$1);
    return vm && vm.$.subTree.shapeFlag === 16;
  }
  function checkMultipleRoots(target$1, event) {
    const vm = toValue(target$1);
    const children = vm.$.subTree && vm.$.subTree.children;
    if (children == null || !Array.isArray(children)) return false;
    return children.some((child) => child.el === event.target || event.composedPath().includes(child.el));
  }
  const listener = (event) => {
    const el2 = unrefElement(target);
    if (event.target == null) return;
    if (!(el2 instanceof Element) && hasMultipleRoots(target) && checkMultipleRoots(target, event)) return;
    if (!el2 || el2 === event.target || event.composedPath().includes(el2)) return;
    if ("detail" in event && event.detail === 0) shouldListen = !shouldIgnore(event);
    if (!shouldListen) {
      shouldListen = true;
      return;
    }
    handler(event);
  };
  let isProcessingClick = false;
  const cleanup = [
    useEventListener(window$1, "click", (event) => {
      if (!isProcessingClick) {
        isProcessingClick = true;
        setTimeout(() => {
          isProcessingClick = false;
        }, 0);
        listener(event);
      }
    }, {
      passive: true,
      capture
    }),
    useEventListener(window$1, "pointerdown", (e) => {
      const el2 = unrefElement(target);
      shouldListen = !shouldIgnore(e) && !!(el2 && !e.composedPath().includes(el2));
    }, { passive: true }),
    detectIframe && useEventListener(window$1, "blur", (event) => {
      setTimeout(() => {
        var _window$document$acti;
        const el2 = unrefElement(target);
        if (((_window$document$acti = window$1.document.activeElement) === null || _window$document$acti === void 0 ? void 0 : _window$document$acti.tagName) === "IFRAME" && !(el2 === null || el2 === void 0 ? void 0 : el2.contains(window$1.document.activeElement))) handler(event);
      }, 0);
    }, { passive: true })
  ].filter(Boolean);
  const stop = () => cleanup.forEach((fn) => fn());
  if (controls) return {
    stop,
    cancel: () => {
      shouldListen = false;
    },
    trigger: (event) => {
      shouldListen = true;
      listener(event);
      shouldListen = false;
    }
  };
  return stop;
}
var ssrWidthSymbol = Symbol("vueuse-ssr-width");
var _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var globalKey = "__vueuse_ssr_handlers__";
var handlers = getHandlers();
function getHandlers() {
  if (!(globalKey in _global)) _global[globalKey] = _global[globalKey] || {};
  return _global[globalKey];
}
var defaultState = {
  x: 0,
  y: 0,
  pointerId: 0,
  pressure: 0,
  tiltX: 0,
  tiltY: 0,
  width: 0,
  height: 0,
  twist: 0,
  pointerType: null
};
var keys = Object.keys(defaultState);
function useSwipe(target, options = {}) {
  const { threshold = 50, onSwipe, onSwipeEnd, onSwipeStart, passive = true } = options;
  const coordsStart = reactive({
    x: 0,
    y: 0
  });
  const coordsEnd = reactive({
    x: 0,
    y: 0
  });
  const diffX = computed(() => coordsStart.x - coordsEnd.x);
  const diffY = computed(() => coordsStart.y - coordsEnd.y);
  const { max: max3, abs } = Math;
  const isThresholdExceeded = computed(() => max3(abs(diffX.value), abs(diffY.value)) >= threshold);
  const isSwiping = shallowRef(false);
  const direction = computed(() => {
    if (!isThresholdExceeded.value) return "none";
    if (abs(diffX.value) > abs(diffY.value)) return diffX.value > 0 ? "left" : "right";
    else return diffY.value > 0 ? "up" : "down";
  });
  const getTouchEventCoords = (e) => [e.touches[0].clientX, e.touches[0].clientY];
  const updateCoordsStart = (x, y) => {
    coordsStart.x = x;
    coordsStart.y = y;
  };
  const updateCoordsEnd = (x, y) => {
    coordsEnd.x = x;
    coordsEnd.y = y;
  };
  const listenerOptions = {
    passive,
    capture: !passive
  };
  const onTouchEnd = (e) => {
    if (isSwiping.value) onSwipeEnd === null || onSwipeEnd === void 0 || onSwipeEnd(e, direction.value);
    isSwiping.value = false;
  };
  const stops = [
    useEventListener(target, "touchstart", (e) => {
      if (e.touches.length !== 1) return;
      const [x, y] = getTouchEventCoords(e);
      updateCoordsStart(x, y);
      updateCoordsEnd(x, y);
      onSwipeStart === null || onSwipeStart === void 0 || onSwipeStart(e);
    }, listenerOptions),
    useEventListener(target, "touchmove", (e) => {
      if (e.touches.length !== 1) return;
      const [x, y] = getTouchEventCoords(e);
      updateCoordsEnd(x, y);
      if (listenerOptions.capture && !listenerOptions.passive && Math.abs(diffX.value) > Math.abs(diffY.value)) e.preventDefault();
      if (!isSwiping.value && isThresholdExceeded.value) isSwiping.value = true;
      if (isSwiping.value) onSwipe === null || onSwipe === void 0 || onSwipe(e);
    }, listenerOptions),
    useEventListener(target, ["touchend", "touchcancel"], onTouchEnd, listenerOptions)
  ];
  const stop = () => stops.forEach((s) => s());
  return {
    isSwiping,
    direction,
    coordsStart,
    coordsEnd,
    lengthX: diffX,
    lengthY: diffY,
    stop
  };
}
var DEFAULT_UNITS = [
  {
    max: 6e4,
    value: 1e3,
    name: "second"
  },
  {
    max: 276e4,
    value: 6e4,
    name: "minute"
  },
  {
    max: 72e6,
    value: 36e5,
    name: "hour"
  },
  {
    max: 5184e5,
    value: 864e5,
    name: "day"
  },
  {
    max: 24192e5,
    value: 6048e5,
    name: "week"
  },
  {
    max: 28512e6,
    value: 2592e6,
    name: "month"
  },
  {
    max: Number.POSITIVE_INFINITY,
    value: 31536e6,
    name: "year"
  }
];
var _TransitionPresets = {
  easeInSine: [
    0.12,
    0,
    0.39,
    0
  ],
  easeOutSine: [
    0.61,
    1,
    0.88,
    1
  ],
  easeInOutSine: [
    0.37,
    0,
    0.63,
    1
  ],
  easeInQuad: [
    0.11,
    0,
    0.5,
    0
  ],
  easeOutQuad: [
    0.5,
    1,
    0.89,
    1
  ],
  easeInOutQuad: [
    0.45,
    0,
    0.55,
    1
  ],
  easeInCubic: [
    0.32,
    0,
    0.67,
    0
  ],
  easeOutCubic: [
    0.33,
    1,
    0.68,
    1
  ],
  easeInOutCubic: [
    0.65,
    0,
    0.35,
    1
  ],
  easeInQuart: [
    0.5,
    0,
    0.75,
    0
  ],
  easeOutQuart: [
    0.25,
    1,
    0.5,
    1
  ],
  easeInOutQuart: [
    0.76,
    0,
    0.24,
    1
  ],
  easeInQuint: [
    0.64,
    0,
    0.78,
    0
  ],
  easeOutQuint: [
    0.22,
    1,
    0.36,
    1
  ],
  easeInOutQuint: [
    0.83,
    0,
    0.17,
    1
  ],
  easeInExpo: [
    0.7,
    0,
    0.84,
    0
  ],
  easeOutExpo: [
    0.16,
    1,
    0.3,
    1
  ],
  easeInOutExpo: [
    0.87,
    0,
    0.13,
    1
  ],
  easeInCirc: [
    0.55,
    0,
    1,
    0.45
  ],
  easeOutCirc: [
    0,
    0.55,
    0.45,
    1
  ],
  easeInOutCirc: [
    0.85,
    0,
    0.15,
    1
  ],
  easeInBack: [
    0.36,
    0,
    0.66,
    -0.56
  ],
  easeOutBack: [
    0.34,
    1.56,
    0.64,
    1
  ],
  easeInOutBack: [
    0.68,
    -0.6,
    0.32,
    1.6
  ]
};
var TransitionPresets = Object.assign({}, { linear: identity }, _TransitionPresets);

// node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var alignments = ["start", "end"];
var placements = sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v) => ({
  x: v,
  y: v
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp2(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
var yAxisSides = /* @__PURE__ */ new Set(["top", "bottom"]);
function getSideAxis(placement) {
  return yAxisSides.has(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
var lrPlacement = ["left", "right"];
var rlPlacement = ["right", "left"];
var tbPlacement = ["top", "bottom"];
var btPlacement = ["bottom", "top"];
function getSideList(side, isStart, rtl) {
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rlPlacement : lrPlacement;
      return isStart ? lrPlacement : rlPlacement;
    case "left":
    case "right":
      return isStart ? tbPlacement : btPlacement;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}

// node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x,
      y,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x,
      y
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max3 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset3 = clamp2(min$1, center, max3);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset3 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max3 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset3,
        centerOffset: center - offset3 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
          if (!ignoreCrossAxisOverflow || // We leave the current main axis only if every placement on that axis
          // overflows the main axis.
          overflowsData.every((d) => getSideAxis(d.placement) === initialSideAxis ? d.overflows[0] > 0 : true)) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
var originSides = /* @__PURE__ */ new Set(["left", "top"]);
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = originSides.has(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min3 = mainAxisCoord + overflow[minSide];
        const max3 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp2(min3, mainAxisCoord, max3);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min3 = crossAxisCoord + overflow[minSide];
        const max3 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp2(min3, crossAxisCoord, max3);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};

// node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
var invalidOverflowDisplayValues = /* @__PURE__ */ new Set(["inline", "contents"]);
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);
}
var tableElements = /* @__PURE__ */ new Set(["table", "td", "th"]);
function isTableElement(element) {
  return tableElements.has(getNodeName(element));
}
var topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(element) {
  return topLayerSelectors.some((selector) => {
    try {
      return element.matches(selector);
    } catch (_e) {
      return false;
    }
  });
}
var transformProperties = ["transform", "translate", "scale", "rotate", "perspective"];
var willChangeValues = ["transform", "translate", "scale", "rotate", "perspective", "filter"];
var containValues = ["paint", "layout", "strict", "content"];
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle2(elementOrCss) : elementOrCss;
  return transformProperties.some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || willChangeValues.some((value) => (css.willChange || "").includes(value)) || containValues.some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
var lastTraversableNodeNames = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function isLastTraversableNode(node) {
  return lastTraversableNodeNames.has(getNodeName(node));
}
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

// node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css = getComputedStyle2(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
var noOffsets = createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll) {
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - getWindowScrollBarX(documentElement, htmlRect);
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
var SCROLLBAR_MAX = 25;
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  const windowScrollbarX = getWindowScrollBarX(html);
  if (windowScrollbarX <= 0) {
    const doc = html.ownerDocument;
    const body = doc.body;
    const bodyStyles = getComputedStyle(body);
    const bodyMarginInline = doc.compatMode === "CSS1Compat" ? parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight) || 0 : 0;
    const clippingStableScrollbarWidth = Math.abs(html.clientWidth - body.clientWidth - bodyMarginInline);
    if (clippingStableScrollbarWidth <= SCROLLBAR_MAX) {
      width -= clippingStableScrollbarWidth;
    }
  } else if (windowScrollbarX <= SCROLLBAR_MAX) {
    width += windowScrollbarX;
  }
  return {
    width,
    height,
    x,
    y
  };
}
var absoluteOrFixed = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el2) => isElement(el2) && getNodeName(el2) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      setLeftRTLScrollbarOffset();
    }
  }
  if (isFixed && !isOffsetParentAnElement && documentElement) {
    setLeftRTLScrollbarOffset();
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle2(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle2(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle2(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(a, b) {
  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (_e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var offset2 = offset;
var shift2 = shift;
var flip2 = flip;
var arrow2 = arrow;
var computePosition2 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// node_modules/@floating-ui/vue/dist/floating-ui.vue.mjs
function isComponentPublicInstance(target) {
  return target != null && typeof target === "object" && "$el" in target;
}
function unwrapElement2(target) {
  if (isComponentPublicInstance(target)) {
    const element = target.$el;
    return isNode(element) && getNodeName(element) === "#comment" ? null : element;
  }
  return target;
}
function toValue2(source) {
  return typeof source === "function" ? source() : unref(source);
}
function arrow3(options) {
  return {
    name: "arrow",
    options,
    fn(args) {
      const element = unwrapElement2(toValue2(options.element));
      if (element == null) {
        return {};
      }
      return arrow2({
        element,
        padding: options.padding
      }).fn(args);
    }
  };
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useFloating(reference, floating, options) {
  if (options === void 0) {
    options = {};
  }
  const whileElementsMountedOption = options.whileElementsMounted;
  const openOption = computed(() => {
    var _toValue;
    return (_toValue = toValue2(options.open)) != null ? _toValue : true;
  });
  const middlewareOption = computed(() => toValue2(options.middleware));
  const placementOption = computed(() => {
    var _toValue2;
    return (_toValue2 = toValue2(options.placement)) != null ? _toValue2 : "bottom";
  });
  const strategyOption = computed(() => {
    var _toValue3;
    return (_toValue3 = toValue2(options.strategy)) != null ? _toValue3 : "absolute";
  });
  const transformOption = computed(() => {
    var _toValue4;
    return (_toValue4 = toValue2(options.transform)) != null ? _toValue4 : true;
  });
  const referenceElement = computed(() => unwrapElement2(reference.value));
  const floatingElement = computed(() => unwrapElement2(floating.value));
  const x = ref(0);
  const y = ref(0);
  const strategy = ref(strategyOption.value);
  const placement = ref(placementOption.value);
  const middlewareData = shallowRef({});
  const isPositioned = ref(false);
  const floatingStyles = computed(() => {
    const initialStyles = {
      position: strategy.value,
      left: "0",
      top: "0"
    };
    if (!floatingElement.value) {
      return initialStyles;
    }
    const xVal = roundByDPR(floatingElement.value, x.value);
    const yVal = roundByDPR(floatingElement.value, y.value);
    if (transformOption.value) {
      return {
        ...initialStyles,
        transform: "translate(" + xVal + "px, " + yVal + "px)",
        ...getDPR(floatingElement.value) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy.value,
      left: xVal + "px",
      top: yVal + "px"
    };
  });
  let whileElementsMountedCleanup;
  function update() {
    if (referenceElement.value == null || floatingElement.value == null) {
      return;
    }
    const open = openOption.value;
    computePosition2(referenceElement.value, floatingElement.value, {
      middleware: middlewareOption.value,
      placement: placementOption.value,
      strategy: strategyOption.value
    }).then((position) => {
      x.value = position.x;
      y.value = position.y;
      strategy.value = position.strategy;
      placement.value = position.placement;
      middlewareData.value = position.middlewareData;
      isPositioned.value = open !== false;
    });
  }
  function cleanup() {
    if (typeof whileElementsMountedCleanup === "function") {
      whileElementsMountedCleanup();
      whileElementsMountedCleanup = void 0;
    }
  }
  function attach() {
    cleanup();
    if (whileElementsMountedOption === void 0) {
      update();
      return;
    }
    if (referenceElement.value != null && floatingElement.value != null) {
      whileElementsMountedCleanup = whileElementsMountedOption(referenceElement.value, floatingElement.value, update);
      return;
    }
  }
  function reset() {
    if (!openOption.value) {
      isPositioned.value = false;
    }
  }
  watch([middlewareOption, placementOption, strategyOption, openOption], update, {
    flush: "sync"
  });
  watch([referenceElement, floatingElement], attach, {
    flush: "sync"
  });
  watch(openOption, reset, {
    flush: "sync"
  });
  if (getCurrentScope()) {
    onScopeDispose(cleanup);
  }
  return {
    x: shallowReadonly(x),
    y: shallowReadonly(y),
    strategy: shallowReadonly(strategy),
    placement: shallowReadonly(placement),
    middlewareData: shallowReadonly(middlewareData),
    isPositioned: shallowReadonly(isPositioned),
    floatingStyles,
    update
  };
}

// node_modules/date-fns/addDays.js
function addDays(date, amount, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  if (isNaN(amount)) return constructFrom((options == null ? void 0 : options.in) || date, NaN);
  if (!amount) return _date;
  _date.setDate(_date.getDate() + amount);
  return _date;
}

// node_modules/date-fns/addMonths.js
function addMonths(date, amount, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  if (isNaN(amount)) return constructFrom((options == null ? void 0 : options.in) || date, NaN);
  if (!amount) {
    return _date;
  }
  const dayOfMonth = _date.getDate();
  const endOfDesiredMonth = constructFrom((options == null ? void 0 : options.in) || date, _date.getTime());
  endOfDesiredMonth.setMonth(_date.getMonth() + amount + 1, 0);
  const daysInMonth = endOfDesiredMonth.getDate();
  if (dayOfMonth >= daysInMonth) {
    return endOfDesiredMonth;
  } else {
    _date.setFullYear(
      endOfDesiredMonth.getFullYear(),
      endOfDesiredMonth.getMonth(),
      dayOfMonth
    );
    return _date;
  }
}

// node_modules/date-fns/add.js
function add(date, duration, options) {
  const {
    years = 0,
    months = 0,
    weeks = 0,
    days = 0,
    hours = 0,
    minutes = 0,
    seconds = 0
  } = duration;
  const _date = toDate(date, options == null ? void 0 : options.in);
  const dateWithMonths = months || years ? addMonths(_date, months + years * 12) : _date;
  const dateWithDays = days || weeks ? addDays(dateWithMonths, days + weeks * 7) : dateWithMonths;
  const minutesToAdd = minutes + hours * 60;
  const secondsToAdd = seconds + minutesToAdd * 60;
  const msToAdd = secondsToAdd * 1e3;
  return constructFrom((options == null ? void 0 : options.in) || date, +dateWithDays + msToAdd);
}

// node_modules/date-fns/startOfISOWeek.js
function startOfISOWeek(date, options) {
  return startOfWeek(date, { ...options, weekStartsOn: 1 });
}

// node_modules/date-fns/getISOWeekYear.js
function getISOWeekYear(date, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  const year = _date.getFullYear();
  const fourthOfJanuaryOfNextYear = constructFrom(_date, 0);
  fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
  const startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear);
  const fourthOfJanuaryOfThisYear = constructFrom(_date, 0);
  fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
  const startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);
  if (_date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (_date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

// node_modules/date-fns/_lib/getTimezoneOffsetInMilliseconds.js
function getTimezoneOffsetInMilliseconds(date) {
  const _date = toDate(date);
  const utcDate = new Date(
    Date.UTC(
      _date.getFullYear(),
      _date.getMonth(),
      _date.getDate(),
      _date.getHours(),
      _date.getMinutes(),
      _date.getSeconds(),
      _date.getMilliseconds()
    )
  );
  utcDate.setUTCFullYear(_date.getFullYear());
  return +date - +utcDate;
}

// node_modules/date-fns/startOfDay.js
function startOfDay(date, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

// node_modules/date-fns/differenceInCalendarDays.js
function differenceInCalendarDays(laterDate, earlierDate, options) {
  const [laterDate_, earlierDate_] = normalizeDates(
    options == null ? void 0 : options.in,
    laterDate,
    earlierDate
  );
  const laterStartOfDay = startOfDay(laterDate_);
  const earlierStartOfDay = startOfDay(earlierDate_);
  const laterTimestamp = +laterStartOfDay - getTimezoneOffsetInMilliseconds(laterStartOfDay);
  const earlierTimestamp = +earlierStartOfDay - getTimezoneOffsetInMilliseconds(earlierStartOfDay);
  return Math.round((laterTimestamp - earlierTimestamp) / millisecondsInDay);
}

// node_modules/date-fns/startOfISOWeekYear.js
function startOfISOWeekYear(date, options) {
  const year = getISOWeekYear(date, options);
  const fourthOfJanuary = constructFrom((options == null ? void 0 : options.in) || date, 0);
  fourthOfJanuary.setFullYear(year, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  return startOfISOWeek(fourthOfJanuary);
}

// node_modules/date-fns/addQuarters.js
function addQuarters(date, amount, options) {
  return addMonths(date, amount * 3, options);
}

// node_modules/date-fns/addYears.js
function addYears(date, amount, options) {
  return addMonths(date, amount * 12, options);
}

// node_modules/date-fns/compareAsc.js
function compareAsc(dateLeft, dateRight) {
  const diff = +toDate(dateLeft) - +toDate(dateRight);
  if (diff < 0) return -1;
  else if (diff > 0) return 1;
  return diff;
}

// node_modules/date-fns/isDate.js
function isDate(value) {
  return value instanceof Date || typeof value === "object" && Object.prototype.toString.call(value) === "[object Date]";
}

// node_modules/date-fns/isValid.js
function isValid(date) {
  return !(!isDate(date) && typeof date !== "number" || isNaN(+toDate(date)));
}

// node_modules/date-fns/getQuarter.js
function getQuarter(date, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  const quarter = Math.trunc(_date.getMonth() / 3) + 1;
  return quarter;
}

// node_modules/date-fns/differenceInCalendarYears.js
function differenceInCalendarYears(laterDate, earlierDate, options) {
  const [laterDate_, earlierDate_] = normalizeDates(
    options == null ? void 0 : options.in,
    laterDate,
    earlierDate
  );
  return laterDate_.getFullYear() - earlierDate_.getFullYear();
}

// node_modules/date-fns/_lib/getRoundingMethod.js
function getRoundingMethod(method) {
  return (number) => {
    const round2 = method ? Math[method] : Math.trunc;
    const result = round2(number);
    return result === 0 ? 0 : result;
  };
}

// node_modules/date-fns/differenceInYears.js
function differenceInYears(laterDate, earlierDate, options) {
  const [laterDate_, earlierDate_] = normalizeDates(
    options == null ? void 0 : options.in,
    laterDate,
    earlierDate
  );
  const sign = compareAsc(laterDate_, earlierDate_);
  const diff = Math.abs(differenceInCalendarYears(laterDate_, earlierDate_));
  laterDate_.setFullYear(1584);
  earlierDate_.setFullYear(1584);
  const partial = compareAsc(laterDate_, earlierDate_) === -sign;
  const result = sign * (diff - +partial);
  return result === 0 ? 0 : result;
}

// node_modules/date-fns/_lib/normalizeInterval.js
function normalizeInterval(context, interval) {
  const [start, end] = normalizeDates(context, interval.start, interval.end);
  return { start, end };
}

// node_modules/date-fns/eachDayOfInterval.js
function eachDayOfInterval(interval, options) {
  const { start, end } = normalizeInterval(options == null ? void 0 : options.in, interval);
  let reversed = +start > +end;
  const endTime = reversed ? +start : +end;
  const date = reversed ? end : start;
  date.setHours(0, 0, 0, 0);
  let step = (options == null ? void 0 : options.step) ?? 1;
  if (!step) return [];
  if (step < 0) {
    step = -step;
    reversed = !reversed;
  }
  const dates = [];
  while (+date <= endTime) {
    dates.push(constructFrom(start, date));
    date.setDate(date.getDate() + step);
    date.setHours(0, 0, 0, 0);
  }
  return reversed ? dates.reverse() : dates;
}

// node_modules/date-fns/startOfQuarter.js
function startOfQuarter(date, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  const currentMonth = _date.getMonth();
  const month = currentMonth - currentMonth % 3;
  _date.setMonth(month, 1);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

// node_modules/date-fns/eachQuarterOfInterval.js
function eachQuarterOfInterval(interval, options) {
  const { start, end } = normalizeInterval(options == null ? void 0 : options.in, interval);
  let reversed = +start > +end;
  const endTime = reversed ? +startOfQuarter(start) : +startOfQuarter(end);
  let date = reversed ? startOfQuarter(end) : startOfQuarter(start);
  let step = (options == null ? void 0 : options.step) ?? 1;
  if (!step) return [];
  if (step < 0) {
    step = -step;
    reversed = !reversed;
  }
  const dates = [];
  while (+date <= endTime) {
    dates.push(constructFrom(start, date));
    date = addQuarters(date, step);
  }
  return reversed ? dates.reverse() : dates;
}

// node_modules/date-fns/startOfMonth.js
function startOfMonth(date, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  _date.setDate(1);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

// node_modules/date-fns/endOfYear.js
function endOfYear(date, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  const year = _date.getFullYear();
  _date.setFullYear(year + 1, 0, 0);
  _date.setHours(23, 59, 59, 999);
  return _date;
}

// node_modules/date-fns/startOfYear.js
function startOfYear(date, options) {
  const date_ = toDate(date, options == null ? void 0 : options.in);
  date_.setFullYear(date_.getFullYear(), 0, 1);
  date_.setHours(0, 0, 0, 0);
  return date_;
}

// node_modules/date-fns/endOfWeek.js
function endOfWeek(date, options) {
  var _a, _b, _c, _d;
  const defaultOptions = getDefaultOptions();
  const weekStartsOn = (options == null ? void 0 : options.weekStartsOn) ?? ((_b = (_a = options == null ? void 0 : options.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.weekStartsOn) ?? defaultOptions.weekStartsOn ?? ((_d = (_c = defaultOptions.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.weekStartsOn) ?? 0;
  const _date = toDate(date, options == null ? void 0 : options.in);
  const day = _date.getDay();
  const diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);
  _date.setDate(_date.getDate() + diff);
  _date.setHours(23, 59, 59, 999);
  return _date;
}

// node_modules/date-fns/endOfQuarter.js
function endOfQuarter(date, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  const currentMonth = _date.getMonth();
  const month = currentMonth - currentMonth % 3 + 3;
  _date.setMonth(month, 0);
  _date.setHours(23, 59, 59, 999);
  return _date;
}

// node_modules/date-fns/getDayOfYear.js
function getDayOfYear(date, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  const diff = differenceInCalendarDays(_date, startOfYear(_date));
  const dayOfYear = diff + 1;
  return dayOfYear;
}

// node_modules/date-fns/getISOWeek.js
function getISOWeek(date, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  const diff = +startOfISOWeek(_date) - +startOfISOWeekYear(_date);
  return Math.round(diff / millisecondsInWeek) + 1;
}

// node_modules/date-fns/getWeekYear.js
function getWeekYear(date, options) {
  var _a, _b, _c, _d;
  const _date = toDate(date, options == null ? void 0 : options.in);
  const year = _date.getFullYear();
  const defaultOptions = getDefaultOptions();
  const firstWeekContainsDate = (options == null ? void 0 : options.firstWeekContainsDate) ?? ((_b = (_a = options == null ? void 0 : options.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.firstWeekContainsDate) ?? defaultOptions.firstWeekContainsDate ?? ((_d = (_c = defaultOptions.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.firstWeekContainsDate) ?? 1;
  const firstWeekOfNextYear = constructFrom((options == null ? void 0 : options.in) || date, 0);
  firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setHours(0, 0, 0, 0);
  const startOfNextYear = startOfWeek(firstWeekOfNextYear, options);
  const firstWeekOfThisYear = constructFrom((options == null ? void 0 : options.in) || date, 0);
  firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setHours(0, 0, 0, 0);
  const startOfThisYear = startOfWeek(firstWeekOfThisYear, options);
  if (+_date >= +startOfNextYear) {
    return year + 1;
  } else if (+_date >= +startOfThisYear) {
    return year;
  } else {
    return year - 1;
  }
}

// node_modules/date-fns/startOfWeekYear.js
function startOfWeekYear(date, options) {
  var _a, _b, _c, _d;
  const defaultOptions = getDefaultOptions();
  const firstWeekContainsDate = (options == null ? void 0 : options.firstWeekContainsDate) ?? ((_b = (_a = options == null ? void 0 : options.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.firstWeekContainsDate) ?? defaultOptions.firstWeekContainsDate ?? ((_d = (_c = defaultOptions.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.firstWeekContainsDate) ?? 1;
  const year = getWeekYear(date, options);
  const firstWeek = constructFrom((options == null ? void 0 : options.in) || date, 0);
  firstWeek.setFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setHours(0, 0, 0, 0);
  const _date = startOfWeek(firstWeek, options);
  return _date;
}

// node_modules/date-fns/getWeek.js
function getWeek(date, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  const diff = +startOfWeek(_date, options) - +startOfWeekYear(_date, options);
  return Math.round(diff / millisecondsInWeek) + 1;
}

// node_modules/date-fns/_lib/addLeadingZeros.js
function addLeadingZeros(number, targetLength) {
  const sign = number < 0 ? "-" : "";
  const output = Math.abs(number).toString().padStart(targetLength, "0");
  return sign + output;
}

// node_modules/date-fns/_lib/format/lightFormatters.js
var lightFormatters = {
  // Year
  y(date, token) {
    const signedYear = date.getFullYear();
    const year = signedYear > 0 ? signedYear : 1 - signedYear;
    return addLeadingZeros(token === "yy" ? year % 100 : year, token.length);
  },
  // Month
  M(date, token) {
    const month = date.getMonth();
    return token === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
  },
  // Day of the month
  d(date, token) {
    return addLeadingZeros(date.getDate(), token.length);
  },
  // AM or PM
  a(date, token) {
    const dayPeriodEnumValue = date.getHours() / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return dayPeriodEnumValue.toUpperCase();
      case "aaa":
        return dayPeriodEnumValue;
      case "aaaaa":
        return dayPeriodEnumValue[0];
      case "aaaa":
      default:
        return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
    }
  },
  // Hour [1-12]
  h(date, token) {
    return addLeadingZeros(date.getHours() % 12 || 12, token.length);
  },
  // Hour [0-23]
  H(date, token) {
    return addLeadingZeros(date.getHours(), token.length);
  },
  // Minute
  m(date, token) {
    return addLeadingZeros(date.getMinutes(), token.length);
  },
  // Second
  s(date, token) {
    return addLeadingZeros(date.getSeconds(), token.length);
  },
  // Fraction of second
  S(date, token) {
    const numberOfDigits = token.length;
    const milliseconds = date.getMilliseconds();
    const fractionalSeconds = Math.trunc(
      milliseconds * Math.pow(10, numberOfDigits - 3)
    );
    return addLeadingZeros(fractionalSeconds, token.length);
  }
};

// node_modules/date-fns/_lib/format/formatters.js
var dayPeriodEnum = {
  am: "am",
  pm: "pm",
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
};
var formatters = {
  // Era
  G: function(date, token, localize) {
    const era = date.getFullYear() > 0 ? 1 : 0;
    switch (token) {
      case "G":
      case "GG":
      case "GGG":
        return localize.era(era, { width: "abbreviated" });
      case "GGGGG":
        return localize.era(era, { width: "narrow" });
      case "GGGG":
      default:
        return localize.era(era, { width: "wide" });
    }
  },
  // Year
  y: function(date, token, localize) {
    if (token === "yo") {
      const signedYear = date.getFullYear();
      const year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize.ordinalNumber(year, { unit: "year" });
    }
    return lightFormatters.y(date, token);
  },
  // Local week-numbering year
  Y: function(date, token, localize, options) {
    const signedWeekYear = getWeekYear(date, options);
    const weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
    if (token === "YY") {
      const twoDigitYear = weekYear % 100;
      return addLeadingZeros(twoDigitYear, 2);
    }
    if (token === "Yo") {
      return localize.ordinalNumber(weekYear, { unit: "year" });
    }
    return addLeadingZeros(weekYear, token.length);
  },
  // ISO week-numbering year
  R: function(date, token) {
    const isoWeekYear = getISOWeekYear(date);
    return addLeadingZeros(isoWeekYear, token.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function(date, token) {
    const year = date.getFullYear();
    return addLeadingZeros(year, token.length);
  },
  // Quarter
  Q: function(date, token, localize) {
    const quarter = Math.ceil((date.getMonth() + 1) / 3);
    switch (token) {
      case "Q":
        return String(quarter);
      case "QQ":
        return addLeadingZeros(quarter, 2);
      case "Qo":
        return localize.ordinalNumber(quarter, { unit: "quarter" });
      case "QQQ":
        return localize.quarter(quarter, {
          width: "abbreviated",
          context: "formatting"
        });
      case "QQQQQ":
        return localize.quarter(quarter, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return localize.quarter(quarter, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone quarter
  q: function(date, token, localize) {
    const quarter = Math.ceil((date.getMonth() + 1) / 3);
    switch (token) {
      case "q":
        return String(quarter);
      case "qq":
        return addLeadingZeros(quarter, 2);
      case "qo":
        return localize.ordinalNumber(quarter, { unit: "quarter" });
      case "qqq":
        return localize.quarter(quarter, {
          width: "abbreviated",
          context: "standalone"
        });
      case "qqqqq":
        return localize.quarter(quarter, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return localize.quarter(quarter, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Month
  M: function(date, token, localize) {
    const month = date.getMonth();
    switch (token) {
      case "M":
      case "MM":
        return lightFormatters.M(date, token);
      case "Mo":
        return localize.ordinalNumber(month + 1, { unit: "month" });
      case "MMM":
        return localize.month(month, {
          width: "abbreviated",
          context: "formatting"
        });
      case "MMMMM":
        return localize.month(month, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return localize.month(month, { width: "wide", context: "formatting" });
    }
  },
  // Stand-alone month
  L: function(date, token, localize) {
    const month = date.getMonth();
    switch (token) {
      case "L":
        return String(month + 1);
      case "LL":
        return addLeadingZeros(month + 1, 2);
      case "Lo":
        return localize.ordinalNumber(month + 1, { unit: "month" });
      case "LLL":
        return localize.month(month, {
          width: "abbreviated",
          context: "standalone"
        });
      case "LLLLL":
        return localize.month(month, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return localize.month(month, { width: "wide", context: "standalone" });
    }
  },
  // Local week of year
  w: function(date, token, localize, options) {
    const week = getWeek(date, options);
    if (token === "wo") {
      return localize.ordinalNumber(week, { unit: "week" });
    }
    return addLeadingZeros(week, token.length);
  },
  // ISO week of year
  I: function(date, token, localize) {
    const isoWeek = getISOWeek(date);
    if (token === "Io") {
      return localize.ordinalNumber(isoWeek, { unit: "week" });
    }
    return addLeadingZeros(isoWeek, token.length);
  },
  // Day of the month
  d: function(date, token, localize) {
    if (token === "do") {
      return localize.ordinalNumber(date.getDate(), { unit: "date" });
    }
    return lightFormatters.d(date, token);
  },
  // Day of year
  D: function(date, token, localize) {
    const dayOfYear = getDayOfYear(date);
    if (token === "Do") {
      return localize.ordinalNumber(dayOfYear, { unit: "dayOfYear" });
    }
    return addLeadingZeros(dayOfYear, token.length);
  },
  // Day of week
  E: function(date, token, localize) {
    const dayOfWeek = date.getDay();
    switch (token) {
      case "E":
      case "EE":
      case "EEE":
        return localize.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "EEEEE":
        return localize.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return localize.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "EEEE":
      default:
        return localize.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Local day of week
  e: function(date, token, localize, options) {
    const dayOfWeek = date.getDay();
    const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      case "e":
        return String(localDayOfWeek);
      case "ee":
        return addLeadingZeros(localDayOfWeek, 2);
      case "eo":
        return localize.ordinalNumber(localDayOfWeek, { unit: "day" });
      case "eee":
        return localize.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "eeeee":
        return localize.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return localize.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "eeee":
      default:
        return localize.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone local day of week
  c: function(date, token, localize, options) {
    const dayOfWeek = date.getDay();
    const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      case "c":
        return String(localDayOfWeek);
      case "cc":
        return addLeadingZeros(localDayOfWeek, token.length);
      case "co":
        return localize.ordinalNumber(localDayOfWeek, { unit: "day" });
      case "ccc":
        return localize.day(dayOfWeek, {
          width: "abbreviated",
          context: "standalone"
        });
      case "ccccc":
        return localize.day(dayOfWeek, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return localize.day(dayOfWeek, {
          width: "short",
          context: "standalone"
        });
      case "cccc":
      default:
        return localize.day(dayOfWeek, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // ISO day of week
  i: function(date, token, localize) {
    const dayOfWeek = date.getDay();
    const isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
    switch (token) {
      case "i":
        return String(isoDayOfWeek);
      case "ii":
        return addLeadingZeros(isoDayOfWeek, token.length);
      case "io":
        return localize.ordinalNumber(isoDayOfWeek, { unit: "day" });
      case "iii":
        return localize.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "iiiii":
        return localize.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "iiiiii":
        return localize.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "iiii":
      default:
        return localize.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM or PM
  a: function(date, token, localize) {
    const hours = date.getHours();
    const dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM, PM, midnight, noon
  b: function(date, token, localize) {
    const hours = date.getHours();
    let dayPeriodEnumValue;
    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    }
    switch (token) {
      case "b":
      case "bb":
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function(date, token, localize) {
    const hours = date.getHours();
    let dayPeriodEnumValue;
    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }
    switch (token) {
      case "B":
      case "BB":
      case "BBB":
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Hour [1-12]
  h: function(date, token, localize) {
    if (token === "ho") {
      let hours = date.getHours() % 12;
      if (hours === 0) hours = 12;
      return localize.ordinalNumber(hours, { unit: "hour" });
    }
    return lightFormatters.h(date, token);
  },
  // Hour [0-23]
  H: function(date, token, localize) {
    if (token === "Ho") {
      return localize.ordinalNumber(date.getHours(), { unit: "hour" });
    }
    return lightFormatters.H(date, token);
  },
  // Hour [0-11]
  K: function(date, token, localize) {
    const hours = date.getHours() % 12;
    if (token === "Ko") {
      return localize.ordinalNumber(hours, { unit: "hour" });
    }
    return addLeadingZeros(hours, token.length);
  },
  // Hour [1-24]
  k: function(date, token, localize) {
    let hours = date.getHours();
    if (hours === 0) hours = 24;
    if (token === "ko") {
      return localize.ordinalNumber(hours, { unit: "hour" });
    }
    return addLeadingZeros(hours, token.length);
  },
  // Minute
  m: function(date, token, localize) {
    if (token === "mo") {
      return localize.ordinalNumber(date.getMinutes(), { unit: "minute" });
    }
    return lightFormatters.m(date, token);
  },
  // Second
  s: function(date, token, localize) {
    if (token === "so") {
      return localize.ordinalNumber(date.getSeconds(), { unit: "second" });
    }
    return lightFormatters.s(date, token);
  },
  // Fraction of second
  S: function(date, token) {
    return lightFormatters.S(date, token);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function(date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();
    if (timezoneOffset === 0) {
      return "Z";
    }
    switch (token) {
      case "X":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "XXXX":
      case "XX":
        return formatTimezone(timezoneOffset);
      case "XXXXX":
      case "XXX":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function(date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();
    switch (token) {
      case "x":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "xxxx":
      case "xx":
        return formatTimezone(timezoneOffset);
      case "xxxxx":
      case "xxx":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (GMT)
  O: function(date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();
    switch (token) {
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "OOOO":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (specific non-location)
  z: function(date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();
    switch (token) {
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "zzzz":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  // Seconds timestamp
  t: function(date, token, _localize) {
    const timestamp2 = Math.trunc(+date / 1e3);
    return addLeadingZeros(timestamp2, token.length);
  },
  // Milliseconds timestamp
  T: function(date, token, _localize) {
    return addLeadingZeros(+date, token.length);
  }
};
function formatTimezoneShort(offset3, delimiter = "") {
  const sign = offset3 > 0 ? "-" : "+";
  const absOffset = Math.abs(offset3);
  const hours = Math.trunc(absOffset / 60);
  const minutes = absOffset % 60;
  if (minutes === 0) {
    return sign + String(hours);
  }
  return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
}
function formatTimezoneWithOptionalMinutes(offset3, delimiter) {
  if (offset3 % 60 === 0) {
    const sign = offset3 > 0 ? "-" : "+";
    return sign + addLeadingZeros(Math.abs(offset3) / 60, 2);
  }
  return formatTimezone(offset3, delimiter);
}
function formatTimezone(offset3, delimiter = "") {
  const sign = offset3 > 0 ? "-" : "+";
  const absOffset = Math.abs(offset3);
  const hours = addLeadingZeros(Math.trunc(absOffset / 60), 2);
  const minutes = addLeadingZeros(absOffset % 60, 2);
  return sign + hours + delimiter + minutes;
}

// node_modules/date-fns/_lib/format/longFormatters.js
var dateLongFormatter = (pattern, formatLong) => {
  switch (pattern) {
    case "P":
      return formatLong.date({ width: "short" });
    case "PP":
      return formatLong.date({ width: "medium" });
    case "PPP":
      return formatLong.date({ width: "long" });
    case "PPPP":
    default:
      return formatLong.date({ width: "full" });
  }
};
var timeLongFormatter = (pattern, formatLong) => {
  switch (pattern) {
    case "p":
      return formatLong.time({ width: "short" });
    case "pp":
      return formatLong.time({ width: "medium" });
    case "ppp":
      return formatLong.time({ width: "long" });
    case "pppp":
    default:
      return formatLong.time({ width: "full" });
  }
};
var dateTimeLongFormatter = (pattern, formatLong) => {
  const matchResult = pattern.match(/(P+)(p+)?/) || [];
  const datePattern = matchResult[1];
  const timePattern = matchResult[2];
  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong);
  }
  let dateTimeFormat;
  switch (datePattern) {
    case "P":
      dateTimeFormat = formatLong.dateTime({ width: "short" });
      break;
    case "PP":
      dateTimeFormat = formatLong.dateTime({ width: "medium" });
      break;
    case "PPP":
      dateTimeFormat = formatLong.dateTime({ width: "long" });
      break;
    case "PPPP":
    default:
      dateTimeFormat = formatLong.dateTime({ width: "full" });
      break;
  }
  return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong)).replace("{{time}}", timeLongFormatter(timePattern, formatLong));
};
var longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};

// node_modules/date-fns/_lib/protectedTokens.js
var dayOfYearTokenRE = /^D+$/;
var weekYearTokenRE = /^Y+$/;
var throwTokens = ["D", "DD", "YY", "YYYY"];
function isProtectedDayOfYearToken(token) {
  return dayOfYearTokenRE.test(token);
}
function isProtectedWeekYearToken(token) {
  return weekYearTokenRE.test(token);
}
function warnOrThrowProtectedError(token, format2, input) {
  const _message = message(token, format2, input);
  console.warn(_message);
  if (throwTokens.includes(token)) throw new RangeError(_message);
}
function message(token, format2, input) {
  const subject = token[0] === "Y" ? "years" : "days of the month";
  return `Use \`${token.toLowerCase()}\` instead of \`${token}\` (in \`${format2}\`) for formatting ${subject} to the input \`${input}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
}

// node_modules/date-fns/format.js
var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
function format(date, formatStr, options) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const defaultOptions = getDefaultOptions();
  const locale = (options == null ? void 0 : options.locale) ?? defaultOptions.locale ?? enUS;
  const firstWeekContainsDate = (options == null ? void 0 : options.firstWeekContainsDate) ?? ((_b = (_a = options == null ? void 0 : options.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.firstWeekContainsDate) ?? defaultOptions.firstWeekContainsDate ?? ((_d = (_c = defaultOptions.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.firstWeekContainsDate) ?? 1;
  const weekStartsOn = (options == null ? void 0 : options.weekStartsOn) ?? ((_f = (_e = options == null ? void 0 : options.locale) == null ? void 0 : _e.options) == null ? void 0 : _f.weekStartsOn) ?? defaultOptions.weekStartsOn ?? ((_h = (_g = defaultOptions.locale) == null ? void 0 : _g.options) == null ? void 0 : _h.weekStartsOn) ?? 0;
  const originalDate = toDate(date, options == null ? void 0 : options.in);
  if (!isValid(originalDate)) {
    throw new RangeError("Invalid time value");
  }
  let parts = formatStr.match(longFormattingTokensRegExp).map((substring) => {
    const firstCharacter = substring[0];
    if (firstCharacter === "p" || firstCharacter === "P") {
      const longFormatter = longFormatters[firstCharacter];
      return longFormatter(substring, locale.formatLong);
    }
    return substring;
  }).join("").match(formattingTokensRegExp).map((substring) => {
    if (substring === "''") {
      return { isToken: false, value: "'" };
    }
    const firstCharacter = substring[0];
    if (firstCharacter === "'") {
      return { isToken: false, value: cleanEscapedString(substring) };
    }
    if (formatters[firstCharacter]) {
      return { isToken: true, value: substring };
    }
    if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
      throw new RangeError(
        "Format string contains an unescaped latin alphabet character `" + firstCharacter + "`"
      );
    }
    return { isToken: false, value: substring };
  });
  if (locale.localize.preprocessor) {
    parts = locale.localize.preprocessor(originalDate, parts);
  }
  const formatterOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale
  };
  return parts.map((part) => {
    if (!part.isToken) return part.value;
    const token = part.value;
    if (!(options == null ? void 0 : options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(token) || !(options == null ? void 0 : options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(token)) {
      warnOrThrowProtectedError(token, formatStr, String(date));
    }
    const formatter = formatters[token[0]];
    return formatter(originalDate, token, locale.localize, formatterOptions);
  }).join("");
}
function cleanEscapedString(input) {
  const matched = input.match(escapedStringRegExp);
  if (!matched) {
    return input;
  }
  return matched[1].replace(doubleQuoteRegExp, "'");
}

// node_modules/date-fns/getDay.js
function getDay(date, options) {
  return toDate(date, options == null ? void 0 : options.in).getDay();
}

// node_modules/date-fns/getDaysInMonth.js
function getDaysInMonth(date, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  const year = _date.getFullYear();
  const monthIndex = _date.getMonth();
  const lastDayOfMonth2 = constructFrom(_date, 0);
  lastDayOfMonth2.setFullYear(year, monthIndex + 1, 0);
  lastDayOfMonth2.setHours(0, 0, 0, 0);
  return lastDayOfMonth2.getDate();
}

// node_modules/date-fns/getDefaultOptions.js
function getDefaultOptions2() {
  return Object.assign({}, getDefaultOptions());
}

// node_modules/date-fns/getHours.js
function getHours(date, options) {
  return toDate(date, options == null ? void 0 : options.in).getHours();
}

// node_modules/date-fns/getISODay.js
function getISODay(date, options) {
  const day = toDate(date, options == null ? void 0 : options.in).getDay();
  return day === 0 ? 7 : day;
}

// node_modules/date-fns/getMinutes.js
function getMinutes(date, options) {
  return toDate(date, options == null ? void 0 : options.in).getMinutes();
}

// node_modules/date-fns/getMonth.js
function getMonth(date, options) {
  return toDate(date, options == null ? void 0 : options.in).getMonth();
}

// node_modules/date-fns/getSeconds.js
function getSeconds(date) {
  return toDate(date).getSeconds();
}

// node_modules/date-fns/getYear.js
function getYear(date, options) {
  return toDate(date, options == null ? void 0 : options.in).getFullYear();
}

// node_modules/date-fns/isAfter.js
function isAfter(date, dateToCompare) {
  return +toDate(date) > +toDate(dateToCompare);
}

// node_modules/date-fns/isBefore.js
function isBefore(date, dateToCompare) {
  return +toDate(date) < +toDate(dateToCompare);
}

// node_modules/date-fns/isEqual.js
function isEqual(leftDate, rightDate) {
  return +toDate(leftDate) === +toDate(rightDate);
}

// node_modules/date-fns/transpose.js
function transpose(date, constructor) {
  const date_ = isConstructor(constructor) ? new constructor(0) : constructFrom(constructor, 0);
  date_.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
  date_.setHours(
    date.getHours(),
    date.getMinutes(),
    date.getSeconds(),
    date.getMilliseconds()
  );
  return date_;
}
function isConstructor(constructor) {
  var _a;
  return typeof constructor === "function" && ((_a = constructor.prototype) == null ? void 0 : _a.constructor) === constructor;
}

// node_modules/date-fns/parse/_lib/Setter.js
var TIMEZONE_UNIT_PRIORITY = 10;
var Setter = class {
  constructor() {
    __publicField(this, "subPriority", 0);
  }
  validate(_utcDate, _options) {
    return true;
  }
};
var ValueSetter = class extends Setter {
  constructor(value, validateValue, setValue, priority, subPriority) {
    super();
    this.value = value;
    this.validateValue = validateValue;
    this.setValue = setValue;
    this.priority = priority;
    if (subPriority) {
      this.subPriority = subPriority;
    }
  }
  validate(date, options) {
    return this.validateValue(date, this.value, options);
  }
  set(date, flags, options) {
    return this.setValue(date, flags, this.value, options);
  }
};
var DateTimezoneSetter = class extends Setter {
  constructor(context, reference) {
    super();
    __publicField(this, "priority", TIMEZONE_UNIT_PRIORITY);
    __publicField(this, "subPriority", -1);
    this.context = context || ((date) => constructFrom(reference, date));
  }
  set(date, flags) {
    if (flags.timestampIsSet) return date;
    return constructFrom(date, transpose(date, this.context));
  }
};

// node_modules/date-fns/parse/_lib/Parser.js
var Parser = class {
  run(dateString, token, match, options) {
    const result = this.parse(dateString, token, match, options);
    if (!result) {
      return null;
    }
    return {
      setter: new ValueSetter(
        result.value,
        this.validate,
        this.set,
        this.priority,
        this.subPriority
      ),
      rest: result.rest
    };
  }
  validate(_utcDate, _value, _options) {
    return true;
  }
};

// node_modules/date-fns/parse/_lib/parsers/EraParser.js
var EraParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 140);
    __publicField(this, "incompatibleTokens", ["R", "u", "t", "T"]);
  }
  parse(dateString, token, match) {
    switch (token) {
      case "G":
      case "GG":
      case "GGG":
        return match.era(dateString, { width: "abbreviated" }) || match.era(dateString, { width: "narrow" });
      case "GGGGG":
        return match.era(dateString, { width: "narrow" });
      case "GGGG":
      default:
        return match.era(dateString, { width: "wide" }) || match.era(dateString, { width: "abbreviated" }) || match.era(dateString, { width: "narrow" });
    }
  }
  set(date, flags, value) {
    flags.era = value;
    date.setFullYear(value, 0, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/constants.js
var numericPatterns = {
  month: /^(1[0-2]|0?\d)/,
  // 0 to 12
  date: /^(3[0-1]|[0-2]?\d)/,
  // 0 to 31
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  // 0 to 366
  week: /^(5[0-3]|[0-4]?\d)/,
  // 0 to 53
  hour23h: /^(2[0-3]|[0-1]?\d)/,
  // 0 to 23
  hour24h: /^(2[0-4]|[0-1]?\d)/,
  // 0 to 24
  hour11h: /^(1[0-1]|0?\d)/,
  // 0 to 11
  hour12h: /^(1[0-2]|0?\d)/,
  // 0 to 12
  minute: /^[0-5]?\d/,
  // 0 to 59
  second: /^[0-5]?\d/,
  // 0 to 59
  singleDigit: /^\d/,
  // 0 to 9
  twoDigits: /^\d{1,2}/,
  // 0 to 99
  threeDigits: /^\d{1,3}/,
  // 0 to 999
  fourDigits: /^\d{1,4}/,
  // 0 to 9999
  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/,
  // 0 to 9, -0 to -9
  twoDigitsSigned: /^-?\d{1,2}/,
  // 0 to 99, -0 to -99
  threeDigitsSigned: /^-?\d{1,3}/,
  // 0 to 999, -0 to -999
  fourDigitsSigned: /^-?\d{1,4}/
  // 0 to 9999, -0 to -9999
};
var timezonePatterns = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};

// node_modules/date-fns/parse/_lib/utils.js
function mapValue(parseFnResult, mapFn) {
  if (!parseFnResult) {
    return parseFnResult;
  }
  return {
    value: mapFn(parseFnResult.value),
    rest: parseFnResult.rest
  };
}
function parseNumericPattern(pattern, dateString) {
  const matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }
  return {
    value: parseInt(matchResult[0], 10),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseTimezonePattern(pattern, dateString) {
  const matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }
  if (matchResult[0] === "Z") {
    return {
      value: 0,
      rest: dateString.slice(1)
    };
  }
  const sign = matchResult[1] === "+" ? 1 : -1;
  const hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
  const minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
  const seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
  return {
    value: sign * (hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * millisecondsInSecond),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseAnyDigitsSigned(dateString) {
  return parseNumericPattern(numericPatterns.anyDigitsSigned, dateString);
}
function parseNDigits(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigit, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigits, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigits, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigits, dateString);
    default:
      return parseNumericPattern(new RegExp("^\\d{1," + n + "}"), dateString);
  }
}
function parseNDigitsSigned(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigitSigned, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigitsSigned, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigitsSigned, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigitsSigned, dateString);
    default:
      return parseNumericPattern(new RegExp("^-?\\d{1," + n + "}"), dateString);
  }
}
function dayPeriodEnumToHours(dayPeriod) {
  switch (dayPeriod) {
    case "morning":
      return 4;
    case "evening":
      return 17;
    case "pm":
    case "noon":
    case "afternoon":
      return 12;
    case "am":
    case "midnight":
    case "night":
    default:
      return 0;
  }
}
function normalizeTwoDigitYear(twoDigitYear, currentYear) {
  const isCommonEra = currentYear > 0;
  const absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
  let result;
  if (absCurrentYear <= 50) {
    result = twoDigitYear || 100;
  } else {
    const rangeEnd = absCurrentYear + 50;
    const rangeEndCentury = Math.trunc(rangeEnd / 100) * 100;
    const isPreviousCentury = twoDigitYear >= rangeEnd % 100;
    result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
  }
  return isCommonEra ? result : 1 - result;
}
function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}

// node_modules/date-fns/parse/_lib/parsers/YearParser.js
var YearParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 130);
    __publicField(this, "incompatibleTokens", ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]);
  }
  parse(dateString, token, match) {
    const valueCallback = (year) => ({
      year,
      isTwoDigitYear: token === "yy"
    });
    switch (token) {
      case "y":
        return mapValue(parseNDigits(4, dateString), valueCallback);
      case "yo":
        return mapValue(
          match.ordinalNumber(dateString, {
            unit: "year"
          }),
          valueCallback
        );
      default:
        return mapValue(parseNDigits(token.length, dateString), valueCallback);
    }
  }
  validate(_date, value) {
    return value.isTwoDigitYear || value.year > 0;
  }
  set(date, flags, value) {
    const currentYear = date.getFullYear();
    if (value.isTwoDigitYear) {
      const normalizedTwoDigitYear = normalizeTwoDigitYear(
        value.year,
        currentYear
      );
      date.setFullYear(normalizedTwoDigitYear, 0, 1);
      date.setHours(0, 0, 0, 0);
      return date;
    }
    const year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
    date.setFullYear(year, 0, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/LocalWeekYearParser.js
var LocalWeekYearParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 130);
    __publicField(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "Q",
      "q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "i",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match) {
    const valueCallback = (year) => ({
      year,
      isTwoDigitYear: token === "YY"
    });
    switch (token) {
      case "Y":
        return mapValue(parseNDigits(4, dateString), valueCallback);
      case "Yo":
        return mapValue(
          match.ordinalNumber(dateString, {
            unit: "year"
          }),
          valueCallback
        );
      default:
        return mapValue(parseNDigits(token.length, dateString), valueCallback);
    }
  }
  validate(_date, value) {
    return value.isTwoDigitYear || value.year > 0;
  }
  set(date, flags, value, options) {
    const currentYear = getWeekYear(date, options);
    if (value.isTwoDigitYear) {
      const normalizedTwoDigitYear = normalizeTwoDigitYear(
        value.year,
        currentYear
      );
      date.setFullYear(
        normalizedTwoDigitYear,
        0,
        options.firstWeekContainsDate
      );
      date.setHours(0, 0, 0, 0);
      return startOfWeek(date, options);
    }
    const year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
    date.setFullYear(year, 0, options.firstWeekContainsDate);
    date.setHours(0, 0, 0, 0);
    return startOfWeek(date, options);
  }
};

// node_modules/date-fns/parse/_lib/parsers/ISOWeekYearParser.js
var ISOWeekYearParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 130);
    __publicField(this, "incompatibleTokens", [
      "G",
      "y",
      "Y",
      "u",
      "Q",
      "q",
      "M",
      "L",
      "w",
      "d",
      "D",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token) {
    if (token === "R") {
      return parseNDigitsSigned(4, dateString);
    }
    return parseNDigitsSigned(token.length, dateString);
  }
  set(date, _flags, value) {
    const firstWeekOfYear = constructFrom(date, 0);
    firstWeekOfYear.setFullYear(value, 0, 4);
    firstWeekOfYear.setHours(0, 0, 0, 0);
    return startOfISOWeek(firstWeekOfYear);
  }
};

// node_modules/date-fns/parse/_lib/parsers/ExtendedYearParser.js
var ExtendedYearParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 130);
    __publicField(this, "incompatibleTokens", ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]);
  }
  parse(dateString, token) {
    if (token === "u") {
      return parseNDigitsSigned(4, dateString);
    }
    return parseNDigitsSigned(token.length, dateString);
  }
  set(date, _flags, value) {
    date.setFullYear(value, 0, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/QuarterParser.js
var QuarterParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 120);
    __publicField(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "M",
      "L",
      "w",
      "I",
      "d",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match) {
    switch (token) {
      case "Q":
      case "QQ":
        return parseNDigits(token.length, dateString);
      case "Qo":
        return match.ordinalNumber(dateString, { unit: "quarter" });
      case "QQQ":
        return match.quarter(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match.quarter(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQQ":
        return match.quarter(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return match.quarter(dateString, {
          width: "wide",
          context: "formatting"
        }) || match.quarter(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match.quarter(dateString, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 4;
  }
  set(date, _flags, value) {
    date.setMonth((value - 1) * 3, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/StandAloneQuarterParser.js
var StandAloneQuarterParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 120);
    __publicField(this, "incompatibleTokens", [
      "Y",
      "R",
      "Q",
      "M",
      "L",
      "w",
      "I",
      "d",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match) {
    switch (token) {
      case "q":
      case "qq":
        return parseNDigits(token.length, dateString);
      case "qo":
        return match.ordinalNumber(dateString, { unit: "quarter" });
      case "qqq":
        return match.quarter(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match.quarter(dateString, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqqq":
        return match.quarter(dateString, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return match.quarter(dateString, {
          width: "wide",
          context: "standalone"
        }) || match.quarter(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match.quarter(dateString, {
          width: "narrow",
          context: "standalone"
        });
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 4;
  }
  set(date, _flags, value) {
    date.setMonth((value - 1) * 3, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/MonthParser.js
var MonthParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "L",
      "w",
      "I",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
    __publicField(this, "priority", 110);
  }
  parse(dateString, token, match) {
    const valueCallback = (value) => value - 1;
    switch (token) {
      case "M":
        return mapValue(
          parseNumericPattern(numericPatterns.month, dateString),
          valueCallback
        );
      case "MM":
        return mapValue(parseNDigits(2, dateString), valueCallback);
      case "Mo":
        return mapValue(
          match.ordinalNumber(dateString, {
            unit: "month"
          }),
          valueCallback
        );
      case "MMM":
        return match.month(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match.month(dateString, { width: "narrow", context: "formatting" });
      case "MMMMM":
        return match.month(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return match.month(dateString, { width: "wide", context: "formatting" }) || match.month(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match.month(dateString, { width: "narrow", context: "formatting" });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 11;
  }
  set(date, _flags, value) {
    date.setMonth(value, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/StandAloneMonthParser.js
var StandAloneMonthParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 110);
    __publicField(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "M",
      "w",
      "I",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match) {
    const valueCallback = (value) => value - 1;
    switch (token) {
      case "L":
        return mapValue(
          parseNumericPattern(numericPatterns.month, dateString),
          valueCallback
        );
      case "LL":
        return mapValue(parseNDigits(2, dateString), valueCallback);
      case "Lo":
        return mapValue(
          match.ordinalNumber(dateString, {
            unit: "month"
          }),
          valueCallback
        );
      case "LLL":
        return match.month(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match.month(dateString, { width: "narrow", context: "standalone" });
      case "LLLLL":
        return match.month(dateString, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return match.month(dateString, { width: "wide", context: "standalone" }) || match.month(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match.month(dateString, { width: "narrow", context: "standalone" });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 11;
  }
  set(date, _flags, value) {
    date.setMonth(value, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/setWeek.js
function setWeek(date, week, options) {
  const date_ = toDate(date, options == null ? void 0 : options.in);
  const diff = getWeek(date_, options) - week;
  date_.setDate(date_.getDate() - diff * 7);
  return toDate(date_, options == null ? void 0 : options.in);
}

// node_modules/date-fns/parse/_lib/parsers/LocalWeekParser.js
var LocalWeekParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 100);
    __publicField(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "i",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match) {
    switch (token) {
      case "w":
        return parseNumericPattern(numericPatterns.week, dateString);
      case "wo":
        return match.ordinalNumber(dateString, { unit: "week" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 53;
  }
  set(date, _flags, value, options) {
    return startOfWeek(setWeek(date, value, options), options);
  }
};

// node_modules/date-fns/setISOWeek.js
function setISOWeek(date, week, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  const diff = getISOWeek(_date, options) - week;
  _date.setDate(_date.getDate() - diff * 7);
  return _date;
}

// node_modules/date-fns/parse/_lib/parsers/ISOWeekParser.js
var ISOWeekParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 100);
    __publicField(this, "incompatibleTokens", [
      "y",
      "Y",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "w",
      "d",
      "D",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match) {
    switch (token) {
      case "I":
        return parseNumericPattern(numericPatterns.week, dateString);
      case "Io":
        return match.ordinalNumber(dateString, { unit: "week" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 53;
  }
  set(date, _flags, value) {
    return startOfISOWeek(setISOWeek(date, value));
  }
};

// node_modules/date-fns/parse/_lib/parsers/DateParser.js
var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DAYS_IN_MONTH_LEAP_YEAR = [
  31,
  29,
  31,
  30,
  31,
  30,
  31,
  31,
  30,
  31,
  30,
  31
];
var DateParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 90);
    __publicField(this, "subPriority", 1);
    __publicField(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "w",
      "I",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match) {
    switch (token) {
      case "d":
        return parseNumericPattern(numericPatterns.date, dateString);
      case "do":
        return match.ordinalNumber(dateString, { unit: "date" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(date, value) {
    const year = date.getFullYear();
    const isLeapYear2 = isLeapYearIndex(year);
    const month = date.getMonth();
    if (isLeapYear2) {
      return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
    } else {
      return value >= 1 && value <= DAYS_IN_MONTH[month];
    }
  }
  set(date, _flags, value) {
    date.setDate(value);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/DayOfYearParser.js
var DayOfYearParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 90);
    __publicField(this, "subpriority", 1);
    __publicField(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "M",
      "L",
      "w",
      "I",
      "d",
      "E",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match) {
    switch (token) {
      case "D":
      case "DD":
        return parseNumericPattern(numericPatterns.dayOfYear, dateString);
      case "Do":
        return match.ordinalNumber(dateString, { unit: "date" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(date, value) {
    const year = date.getFullYear();
    const isLeapYear2 = isLeapYearIndex(year);
    if (isLeapYear2) {
      return value >= 1 && value <= 366;
    } else {
      return value >= 1 && value <= 365;
    }
  }
  set(date, _flags, value) {
    date.setMonth(0, value);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/setDay.js
function setDay(date, day, options) {
  var _a, _b, _c, _d;
  const defaultOptions = getDefaultOptions();
  const weekStartsOn = (options == null ? void 0 : options.weekStartsOn) ?? ((_b = (_a = options == null ? void 0 : options.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.weekStartsOn) ?? defaultOptions.weekStartsOn ?? ((_d = (_c = defaultOptions.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.weekStartsOn) ?? 0;
  const date_ = toDate(date, options == null ? void 0 : options.in);
  const currentDay = date_.getDay();
  const remainder = day % 7;
  const dayIndex = (remainder + 7) % 7;
  const delta = 7 - weekStartsOn;
  const diff = day < 0 || day > 6 ? day - (currentDay + delta) % 7 : (dayIndex + delta) % 7 - (currentDay + delta) % 7;
  return addDays(date_, diff, options);
}

// node_modules/date-fns/parse/_lib/parsers/DayParser.js
var DayParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 90);
    __publicField(this, "incompatibleTokens", ["D", "i", "e", "c", "t", "T"]);
  }
  parse(dateString, token, match) {
    switch (token) {
      case "E":
      case "EE":
      case "EEE":
        return match.day(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match.day(dateString, { width: "short", context: "formatting" }) || match.day(dateString, { width: "narrow", context: "formatting" });
      case "EEEEE":
        return match.day(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return match.day(dateString, { width: "short", context: "formatting" }) || match.day(dateString, { width: "narrow", context: "formatting" });
      case "EEEE":
      default:
        return match.day(dateString, { width: "wide", context: "formatting" }) || match.day(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match.day(dateString, { width: "short", context: "formatting" }) || match.day(dateString, { width: "narrow", context: "formatting" });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 6;
  }
  set(date, _flags, value, options) {
    date = setDay(date, value, options);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/LocalDayParser.js
var LocalDayParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 90);
    __publicField(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "E",
      "i",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match, options) {
    const valueCallback = (value) => {
      const wholeWeekDays = Math.floor((value - 1) / 7) * 7;
      return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
    };
    switch (token) {
      case "e":
      case "ee":
        return mapValue(parseNDigits(token.length, dateString), valueCallback);
      case "eo":
        return mapValue(
          match.ordinalNumber(dateString, {
            unit: "day"
          }),
          valueCallback
        );
      case "eee":
        return match.day(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match.day(dateString, { width: "short", context: "formatting" }) || match.day(dateString, { width: "narrow", context: "formatting" });
      case "eeeee":
        return match.day(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return match.day(dateString, { width: "short", context: "formatting" }) || match.day(dateString, { width: "narrow", context: "formatting" });
      case "eeee":
      default:
        return match.day(dateString, { width: "wide", context: "formatting" }) || match.day(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match.day(dateString, { width: "short", context: "formatting" }) || match.day(dateString, { width: "narrow", context: "formatting" });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 6;
  }
  set(date, _flags, value, options) {
    date = setDay(date, value, options);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/StandAloneLocalDayParser.js
var StandAloneLocalDayParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 90);
    __publicField(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "E",
      "i",
      "e",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match, options) {
    const valueCallback = (value) => {
      const wholeWeekDays = Math.floor((value - 1) / 7) * 7;
      return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
    };
    switch (token) {
      case "c":
      case "cc":
        return mapValue(parseNDigits(token.length, dateString), valueCallback);
      case "co":
        return mapValue(
          match.ordinalNumber(dateString, {
            unit: "day"
          }),
          valueCallback
        );
      case "ccc":
        return match.day(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match.day(dateString, { width: "short", context: "standalone" }) || match.day(dateString, { width: "narrow", context: "standalone" });
      case "ccccc":
        return match.day(dateString, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return match.day(dateString, { width: "short", context: "standalone" }) || match.day(dateString, { width: "narrow", context: "standalone" });
      case "cccc":
      default:
        return match.day(dateString, { width: "wide", context: "standalone" }) || match.day(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match.day(dateString, { width: "short", context: "standalone" }) || match.day(dateString, { width: "narrow", context: "standalone" });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 6;
  }
  set(date, _flags, value, options) {
    date = setDay(date, value, options);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/setISODay.js
function setISODay(date, day, options) {
  const date_ = toDate(date, options == null ? void 0 : options.in);
  const currentDay = getISODay(date_, options);
  const diff = day - currentDay;
  return addDays(date_, diff, options);
}

// node_modules/date-fns/parse/_lib/parsers/ISODayParser.js
var ISODayParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 90);
    __publicField(this, "incompatibleTokens", [
      "y",
      "Y",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "w",
      "d",
      "D",
      "E",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match) {
    const valueCallback = (value) => {
      if (value === 0) {
        return 7;
      }
      return value;
    };
    switch (token) {
      case "i":
      case "ii":
        return parseNDigits(token.length, dateString);
      case "io":
        return match.ordinalNumber(dateString, { unit: "day" });
      case "iii":
        return mapValue(
          match.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match.day(dateString, {
            width: "narrow",
            context: "formatting"
          }),
          valueCallback
        );
      case "iiiii":
        return mapValue(
          match.day(dateString, {
            width: "narrow",
            context: "formatting"
          }),
          valueCallback
        );
      case "iiiiii":
        return mapValue(
          match.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match.day(dateString, {
            width: "narrow",
            context: "formatting"
          }),
          valueCallback
        );
      case "iiii":
      default:
        return mapValue(
          match.day(dateString, {
            width: "wide",
            context: "formatting"
          }) || match.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match.day(dateString, {
            width: "narrow",
            context: "formatting"
          }),
          valueCallback
        );
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 7;
  }
  set(date, _flags, value) {
    date = setISODay(date, value);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/AMPMParser.js
var AMPMParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 80);
    __publicField(this, "incompatibleTokens", ["b", "B", "H", "k", "t", "T"]);
  }
  parse(dateString, token, match) {
    switch (token) {
      case "a":
      case "aa":
      case "aaa":
        return match.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaaa":
        return match.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return match.dayPeriod(dateString, {
          width: "wide",
          context: "formatting"
        }) || match.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(date, _flags, value) {
    date.setHours(dayPeriodEnumToHours(value), 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/AMPMMidnightParser.js
var AMPMMidnightParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 80);
    __publicField(this, "incompatibleTokens", ["a", "B", "H", "k", "t", "T"]);
  }
  parse(dateString, token, match) {
    switch (token) {
      case "b":
      case "bb":
      case "bbb":
        return match.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbbb":
        return match.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return match.dayPeriod(dateString, {
          width: "wide",
          context: "formatting"
        }) || match.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(date, _flags, value) {
    date.setHours(dayPeriodEnumToHours(value), 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/DayPeriodParser.js
var DayPeriodParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 80);
    __publicField(this, "incompatibleTokens", ["a", "b", "t", "T"]);
  }
  parse(dateString, token, match) {
    switch (token) {
      case "B":
      case "BB":
      case "BBB":
        return match.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBBB":
        return match.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return match.dayPeriod(dateString, {
          width: "wide",
          context: "formatting"
        }) || match.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(date, _flags, value) {
    date.setHours(dayPeriodEnumToHours(value), 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/Hour1to12Parser.js
var Hour1to12Parser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 70);
    __publicField(this, "incompatibleTokens", ["H", "K", "k", "t", "T"]);
  }
  parse(dateString, token, match) {
    switch (token) {
      case "h":
        return parseNumericPattern(numericPatterns.hour12h, dateString);
      case "ho":
        return match.ordinalNumber(dateString, { unit: "hour" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 12;
  }
  set(date, _flags, value) {
    const isPM = date.getHours() >= 12;
    if (isPM && value < 12) {
      date.setHours(value + 12, 0, 0, 0);
    } else if (!isPM && value === 12) {
      date.setHours(0, 0, 0, 0);
    } else {
      date.setHours(value, 0, 0, 0);
    }
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/Hour0to23Parser.js
var Hour0to23Parser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 70);
    __publicField(this, "incompatibleTokens", ["a", "b", "h", "K", "k", "t", "T"]);
  }
  parse(dateString, token, match) {
    switch (token) {
      case "H":
        return parseNumericPattern(numericPatterns.hour23h, dateString);
      case "Ho":
        return match.ordinalNumber(dateString, { unit: "hour" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 23;
  }
  set(date, _flags, value) {
    date.setHours(value, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/Hour0To11Parser.js
var Hour0To11Parser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 70);
    __publicField(this, "incompatibleTokens", ["h", "H", "k", "t", "T"]);
  }
  parse(dateString, token, match) {
    switch (token) {
      case "K":
        return parseNumericPattern(numericPatterns.hour11h, dateString);
      case "Ko":
        return match.ordinalNumber(dateString, { unit: "hour" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 11;
  }
  set(date, _flags, value) {
    const isPM = date.getHours() >= 12;
    if (isPM && value < 12) {
      date.setHours(value + 12, 0, 0, 0);
    } else {
      date.setHours(value, 0, 0, 0);
    }
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/Hour1To24Parser.js
var Hour1To24Parser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 70);
    __publicField(this, "incompatibleTokens", ["a", "b", "h", "H", "K", "t", "T"]);
  }
  parse(dateString, token, match) {
    switch (token) {
      case "k":
        return parseNumericPattern(numericPatterns.hour24h, dateString);
      case "ko":
        return match.ordinalNumber(dateString, { unit: "hour" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 24;
  }
  set(date, _flags, value) {
    const hours = value <= 24 ? value % 24 : value;
    date.setHours(hours, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/MinuteParser.js
var MinuteParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 60);
    __publicField(this, "incompatibleTokens", ["t", "T"]);
  }
  parse(dateString, token, match) {
    switch (token) {
      case "m":
        return parseNumericPattern(numericPatterns.minute, dateString);
      case "mo":
        return match.ordinalNumber(dateString, { unit: "minute" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 59;
  }
  set(date, _flags, value) {
    date.setMinutes(value, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/SecondParser.js
var SecondParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 50);
    __publicField(this, "incompatibleTokens", ["t", "T"]);
  }
  parse(dateString, token, match) {
    switch (token) {
      case "s":
        return parseNumericPattern(numericPatterns.second, dateString);
      case "so":
        return match.ordinalNumber(dateString, { unit: "second" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 59;
  }
  set(date, _flags, value) {
    date.setSeconds(value, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/FractionOfSecondParser.js
var FractionOfSecondParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 30);
    __publicField(this, "incompatibleTokens", ["t", "T"]);
  }
  parse(dateString, token) {
    const valueCallback = (value) => Math.trunc(value * Math.pow(10, -token.length + 3));
    return mapValue(parseNDigits(token.length, dateString), valueCallback);
  }
  set(date, _flags, value) {
    date.setMilliseconds(value);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/ISOTimezoneWithZParser.js
var ISOTimezoneWithZParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 10);
    __publicField(this, "incompatibleTokens", ["t", "T", "x"]);
  }
  parse(dateString, token) {
    switch (token) {
      case "X":
        return parseTimezonePattern(
          timezonePatterns.basicOptionalMinutes,
          dateString
        );
      case "XX":
        return parseTimezonePattern(timezonePatterns.basic, dateString);
      case "XXXX":
        return parseTimezonePattern(
          timezonePatterns.basicOptionalSeconds,
          dateString
        );
      case "XXXXX":
        return parseTimezonePattern(
          timezonePatterns.extendedOptionalSeconds,
          dateString
        );
      case "XXX":
      default:
        return parseTimezonePattern(timezonePatterns.extended, dateString);
    }
  }
  set(date, flags, value) {
    if (flags.timestampIsSet) return date;
    return constructFrom(
      date,
      date.getTime() - getTimezoneOffsetInMilliseconds(date) - value
    );
  }
};

// node_modules/date-fns/parse/_lib/parsers/ISOTimezoneParser.js
var ISOTimezoneParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 10);
    __publicField(this, "incompatibleTokens", ["t", "T", "X"]);
  }
  parse(dateString, token) {
    switch (token) {
      case "x":
        return parseTimezonePattern(
          timezonePatterns.basicOptionalMinutes,
          dateString
        );
      case "xx":
        return parseTimezonePattern(timezonePatterns.basic, dateString);
      case "xxxx":
        return parseTimezonePattern(
          timezonePatterns.basicOptionalSeconds,
          dateString
        );
      case "xxxxx":
        return parseTimezonePattern(
          timezonePatterns.extendedOptionalSeconds,
          dateString
        );
      case "xxx":
      default:
        return parseTimezonePattern(timezonePatterns.extended, dateString);
    }
  }
  set(date, flags, value) {
    if (flags.timestampIsSet) return date;
    return constructFrom(
      date,
      date.getTime() - getTimezoneOffsetInMilliseconds(date) - value
    );
  }
};

// node_modules/date-fns/parse/_lib/parsers/TimestampSecondsParser.js
var TimestampSecondsParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 40);
    __publicField(this, "incompatibleTokens", "*");
  }
  parse(dateString) {
    return parseAnyDigitsSigned(dateString);
  }
  set(date, _flags, value) {
    return [constructFrom(date, value * 1e3), { timestampIsSet: true }];
  }
};

// node_modules/date-fns/parse/_lib/parsers/TimestampMillisecondsParser.js
var TimestampMillisecondsParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 20);
    __publicField(this, "incompatibleTokens", "*");
  }
  parse(dateString) {
    return parseAnyDigitsSigned(dateString);
  }
  set(date, _flags, value) {
    return [constructFrom(date, value), { timestampIsSet: true }];
  }
};

// node_modules/date-fns/parse/_lib/parsers.js
var parsers = {
  G: new EraParser(),
  y: new YearParser(),
  Y: new LocalWeekYearParser(),
  R: new ISOWeekYearParser(),
  u: new ExtendedYearParser(),
  Q: new QuarterParser(),
  q: new StandAloneQuarterParser(),
  M: new MonthParser(),
  L: new StandAloneMonthParser(),
  w: new LocalWeekParser(),
  I: new ISOWeekParser(),
  d: new DateParser(),
  D: new DayOfYearParser(),
  E: new DayParser(),
  e: new LocalDayParser(),
  c: new StandAloneLocalDayParser(),
  i: new ISODayParser(),
  a: new AMPMParser(),
  b: new AMPMMidnightParser(),
  B: new DayPeriodParser(),
  h: new Hour1to12Parser(),
  H: new Hour0to23Parser(),
  K: new Hour0To11Parser(),
  k: new Hour1To24Parser(),
  m: new MinuteParser(),
  s: new SecondParser(),
  S: new FractionOfSecondParser(),
  X: new ISOTimezoneWithZParser(),
  x: new ISOTimezoneParser(),
  t: new TimestampSecondsParser(),
  T: new TimestampMillisecondsParser()
};

// node_modules/date-fns/parse.js
var formattingTokensRegExp2 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
var longFormattingTokensRegExp2 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp2 = /^'([^]*?)'?$/;
var doubleQuoteRegExp2 = /''/g;
var notWhitespaceRegExp = /\S/;
var unescapedLatinCharacterRegExp2 = /[a-zA-Z]/;
function parse(dateStr, formatStr, referenceDate, options) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const invalidDate = () => constructFrom((options == null ? void 0 : options.in) || referenceDate, NaN);
  const defaultOptions = getDefaultOptions2();
  const locale = (options == null ? void 0 : options.locale) ?? defaultOptions.locale ?? enUS;
  const firstWeekContainsDate = (options == null ? void 0 : options.firstWeekContainsDate) ?? ((_b = (_a = options == null ? void 0 : options.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.firstWeekContainsDate) ?? defaultOptions.firstWeekContainsDate ?? ((_d = (_c = defaultOptions.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.firstWeekContainsDate) ?? 1;
  const weekStartsOn = (options == null ? void 0 : options.weekStartsOn) ?? ((_f = (_e = options == null ? void 0 : options.locale) == null ? void 0 : _e.options) == null ? void 0 : _f.weekStartsOn) ?? defaultOptions.weekStartsOn ?? ((_h = (_g = defaultOptions.locale) == null ? void 0 : _g.options) == null ? void 0 : _h.weekStartsOn) ?? 0;
  if (!formatStr)
    return dateStr ? invalidDate() : toDate(referenceDate, options == null ? void 0 : options.in);
  const subFnOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale
  };
  const setters = [new DateTimezoneSetter(options == null ? void 0 : options.in, referenceDate)];
  const tokens = formatStr.match(longFormattingTokensRegExp2).map((substring) => {
    const firstCharacter = substring[0];
    if (firstCharacter in longFormatters) {
      const longFormatter = longFormatters[firstCharacter];
      return longFormatter(substring, locale.formatLong);
    }
    return substring;
  }).join("").match(formattingTokensRegExp2);
  const usedTokens = [];
  for (let token of tokens) {
    if (!(options == null ? void 0 : options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(token)) {
      warnOrThrowProtectedError(token, formatStr, dateStr);
    }
    if (!(options == null ? void 0 : options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(token)) {
      warnOrThrowProtectedError(token, formatStr, dateStr);
    }
    const firstCharacter = token[0];
    const parser = parsers[firstCharacter];
    if (parser) {
      const { incompatibleTokens } = parser;
      if (Array.isArray(incompatibleTokens)) {
        const incompatibleToken = usedTokens.find(
          (usedToken) => incompatibleTokens.includes(usedToken.token) || usedToken.token === firstCharacter
        );
        if (incompatibleToken) {
          throw new RangeError(
            `The format string mustn't contain \`${incompatibleToken.fullToken}\` and \`${token}\` at the same time`
          );
        }
      } else if (parser.incompatibleTokens === "*" && usedTokens.length > 0) {
        throw new RangeError(
          `The format string mustn't contain \`${token}\` and any other token at the same time`
        );
      }
      usedTokens.push({ token: firstCharacter, fullToken: token });
      const parseResult = parser.run(
        dateStr,
        token,
        locale.match,
        subFnOptions
      );
      if (!parseResult) {
        return invalidDate();
      }
      setters.push(parseResult.setter);
      dateStr = parseResult.rest;
    } else {
      if (firstCharacter.match(unescapedLatinCharacterRegExp2)) {
        throw new RangeError(
          "Format string contains an unescaped latin alphabet character `" + firstCharacter + "`"
        );
      }
      if (token === "''") {
        token = "'";
      } else if (firstCharacter === "'") {
        token = cleanEscapedString2(token);
      }
      if (dateStr.indexOf(token) === 0) {
        dateStr = dateStr.slice(token.length);
      } else {
        return invalidDate();
      }
    }
  }
  if (dateStr.length > 0 && notWhitespaceRegExp.test(dateStr)) {
    return invalidDate();
  }
  const uniquePrioritySetters = setters.map((setter) => setter.priority).sort((a, b) => b - a).filter((priority, index, array) => array.indexOf(priority) === index).map(
    (priority) => setters.filter((setter) => setter.priority === priority).sort((a, b) => b.subPriority - a.subPriority)
  ).map((setterArray) => setterArray[0]);
  let date = toDate(referenceDate, options == null ? void 0 : options.in);
  if (isNaN(+date)) return invalidDate();
  const flags = {};
  for (const setter of uniquePrioritySetters) {
    if (!setter.validate(date, subFnOptions)) {
      return invalidDate();
    }
    const result = setter.set(date, flags, subFnOptions);
    if (Array.isArray(result)) {
      date = result[0];
      Object.assign(flags, result[1]);
    } else {
      date = result;
    }
  }
  return date;
}
function cleanEscapedString2(input) {
  return input.match(escapedStringRegExp2)[1].replace(doubleQuoteRegExp2, "'");
}

// node_modules/date-fns/isSameQuarter.js
function isSameQuarter(laterDate, earlierDate, options) {
  const [dateLeft_, dateRight_] = normalizeDates(
    options == null ? void 0 : options.in,
    laterDate,
    earlierDate
  );
  return +startOfQuarter(dateLeft_) === +startOfQuarter(dateRight_);
}

// node_modules/date-fns/subDays.js
function subDays(date, amount, options) {
  return addDays(date, -amount, options);
}

// node_modules/date-fns/roundToNearestMinutes.js
function roundToNearestMinutes(date, options) {
  const nearestTo = (options == null ? void 0 : options.nearestTo) ?? 1;
  if (nearestTo < 1 || nearestTo > 30) return constructFrom(date, NaN);
  const date_ = toDate(date, options == null ? void 0 : options.in);
  const fractionalSeconds = date_.getSeconds() / 60;
  const fractionalMilliseconds = date_.getMilliseconds() / 1e3 / 60;
  const minutes = date_.getMinutes() + fractionalSeconds + fractionalMilliseconds;
  const method = (options == null ? void 0 : options.roundingMethod) ?? "round";
  const roundingMethod = getRoundingMethod(method);
  const roundedMinutes = roundingMethod(minutes / nearestTo) * nearestTo;
  date_.setMinutes(roundedMinutes, 0, 0);
  return date_;
}

// node_modules/date-fns/setMonth.js
function setMonth(date, month, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  const year = _date.getFullYear();
  const day = _date.getDate();
  const midMonth = constructFrom((options == null ? void 0 : options.in) || date, 0);
  midMonth.setFullYear(year, month, 15);
  midMonth.setHours(0, 0, 0, 0);
  const daysInMonth = getDaysInMonth(midMonth);
  _date.setMonth(month, Math.min(day, daysInMonth));
  return _date;
}

// node_modules/date-fns/set.js
function set(date, values, options) {
  let _date = toDate(date, options == null ? void 0 : options.in);
  if (isNaN(+_date)) return constructFrom((options == null ? void 0 : options.in) || date, NaN);
  if (values.year != null) _date.setFullYear(values.year);
  if (values.month != null) _date = setMonth(_date, values.month);
  if (values.date != null) _date.setDate(values.date);
  if (values.hours != null) _date.setHours(values.hours);
  if (values.minutes != null) _date.setMinutes(values.minutes);
  if (values.seconds != null) _date.setSeconds(values.seconds);
  if (values.milliseconds != null) _date.setMilliseconds(values.milliseconds);
  return _date;
}

// node_modules/date-fns/setMilliseconds.js
function setMilliseconds(date, milliseconds, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  _date.setMilliseconds(milliseconds);
  return _date;
}

// node_modules/date-fns/setSeconds.js
function setSeconds(date, seconds, options) {
  const _date = toDate(date, options == null ? void 0 : options.in);
  _date.setSeconds(seconds);
  return _date;
}

// node_modules/date-fns/setYear.js
function setYear(date, year, options) {
  const date_ = toDate(date, options == null ? void 0 : options.in);
  if (isNaN(+date_)) return constructFrom((options == null ? void 0 : options.in) || date, NaN);
  date_.setFullYear(year);
  return date_;
}

// node_modules/date-fns/subMonths.js
function subMonths(date, amount, options) {
  return addMonths(date, -amount, options);
}

// node_modules/date-fns/sub.js
function sub(date, duration, options) {
  const {
    years = 0,
    months = 0,
    weeks = 0,
    days = 0,
    hours = 0,
    minutes = 0,
    seconds = 0
  } = duration;
  const withoutMonths = subMonths(date, months + years * 12, options);
  const withoutDays = subDays(withoutMonths, days + weeks * 7, options);
  const minutesToSub = minutes + hours * 60;
  const secondsToSub = seconds + minutesToSub * 60;
  const msToSub = secondsToSub * 1e3;
  return constructFrom((options == null ? void 0 : options.in) || date, +withoutDays - msToSub);
}

// node_modules/date-fns/subYears.js
function subYears(date, amount, options) {
  return addYears(date, -amount, options);
}

// node_modules/@date-fns/tz/constants/index.js
var constructFromSymbol = Symbol.for("constructDateFrom");

// node_modules/@date-fns/tz/tzName/index.js
function tzName(timeZone, date, format2 = "long") {
  return new Intl.DateTimeFormat("en-US", {
    // Enforces engine to render the time. Without the option JavaScriptCore omits it.
    hour: "numeric",
    timeZone,
    timeZoneName: format2
  }).format(date).split(/\s/g).slice(2).join(" ");
}

// node_modules/@date-fns/tz/tzOffset/index.js
var offsetFormatCache = {};
var offsetCache = {};
function tzOffset(timeZone, date) {
  try {
    const format2 = offsetFormatCache[timeZone] || (offsetFormatCache[timeZone] = new Intl.DateTimeFormat("en-US", {
      timeZone,
      timeZoneName: "longOffset"
    }).format);
    const offsetStr = format2(date).split("GMT")[1];
    if (offsetStr in offsetCache) return offsetCache[offsetStr];
    return calcOffset(offsetStr, offsetStr.split(":"));
  } catch {
    if (timeZone in offsetCache) return offsetCache[timeZone];
    const captures = timeZone == null ? void 0 : timeZone.match(offsetRe);
    if (captures) return calcOffset(timeZone, captures.slice(1));
    return NaN;
  }
}
var offsetRe = /([+-]\d\d):?(\d\d)?/;
function calcOffset(cacheStr, values) {
  const hours = +(values[0] || 0);
  const minutes = +(values[1] || 0);
  const seconds = +(values[2] || 0) / 60;
  return offsetCache[cacheStr] = hours * 60 + minutes > 0 ? hours * 60 + minutes + seconds : hours * 60 - minutes - seconds;
}

// node_modules/@date-fns/tz/date/mini.js
var TZDateMini = class _TZDateMini extends Date {
  //#region static
  constructor(...args) {
    super();
    if (args.length > 1 && typeof args[args.length - 1] === "string") {
      this.timeZone = args.pop();
    }
    this.internal = /* @__PURE__ */ new Date();
    if (isNaN(tzOffset(this.timeZone, this))) {
      this.setTime(NaN);
    } else {
      if (!args.length) {
        this.setTime(Date.now());
      } else if (typeof args[0] === "number" && (args.length === 1 || args.length === 2 && typeof args[1] !== "number")) {
        this.setTime(args[0]);
      } else if (typeof args[0] === "string") {
        this.setTime(+new Date(args[0]));
      } else if (args[0] instanceof Date) {
        this.setTime(+args[0]);
      } else {
        this.setTime(+new Date(...args));
        adjustToSystemTZ(this, NaN);
        syncToInternal(this);
      }
    }
  }
  static tz(tz, ...args) {
    return args.length ? new _TZDateMini(...args, tz) : new _TZDateMini(Date.now(), tz);
  }
  //#endregion
  //#region time zone
  withTimeZone(timeZone) {
    return new _TZDateMini(+this, timeZone);
  }
  getTimezoneOffset() {
    const offset3 = -tzOffset(this.timeZone, this);
    return offset3 > 0 ? Math.floor(offset3) : Math.ceil(offset3);
  }
  //#endregion
  //#region time
  setTime(time) {
    Date.prototype.setTime.apply(this, arguments);
    syncToInternal(this);
    return +this;
  }
  //#endregion
  //#region date-fns integration
  [Symbol.for("constructDateFrom")](date) {
    return new _TZDateMini(+new Date(date), this.timeZone);
  }
  //#endregion
};
var re = /^(get|set)(?!UTC)/;
Object.getOwnPropertyNames(Date.prototype).forEach((method) => {
  if (!re.test(method)) return;
  const utcMethod = method.replace(re, "$1UTC");
  if (!TZDateMini.prototype[utcMethod]) return;
  if (method.startsWith("get")) {
    TZDateMini.prototype[method] = function() {
      return this.internal[utcMethod]();
    };
  } else {
    TZDateMini.prototype[method] = function() {
      Date.prototype[utcMethod].apply(this.internal, arguments);
      syncFromInternal(this);
      return +this;
    };
    TZDateMini.prototype[utcMethod] = function() {
      Date.prototype[utcMethod].apply(this, arguments);
      syncToInternal(this);
      return +this;
    };
  }
});
function syncToInternal(date) {
  date.internal.setTime(+date);
  date.internal.setUTCSeconds(date.internal.getUTCSeconds() - Math.round(-tzOffset(date.timeZone, date) * 60));
}
function syncFromInternal(date) {
  Date.prototype.setFullYear.call(date, date.internal.getUTCFullYear(), date.internal.getUTCMonth(), date.internal.getUTCDate());
  Date.prototype.setHours.call(date, date.internal.getUTCHours(), date.internal.getUTCMinutes(), date.internal.getUTCSeconds(), date.internal.getUTCMilliseconds());
  adjustToSystemTZ(date);
}
function adjustToSystemTZ(date) {
  const baseOffset = tzOffset(date.timeZone, date);
  const offset3 = baseOffset > 0 ? Math.floor(baseOffset) : Math.ceil(baseOffset);
  const prevHour = /* @__PURE__ */ new Date(+date);
  prevHour.setUTCHours(prevHour.getUTCHours() - 1);
  const systemOffset = -(/* @__PURE__ */ new Date(+date)).getTimezoneOffset();
  const prevHourSystemOffset = -(/* @__PURE__ */ new Date(+prevHour)).getTimezoneOffset();
  const systemDSTChange = systemOffset - prevHourSystemOffset;
  const dstShift = Date.prototype.getHours.apply(date) !== date.internal.getUTCHours();
  if (systemDSTChange && dstShift) date.internal.setUTCMinutes(date.internal.getUTCMinutes() + systemDSTChange);
  const offsetDiff = systemOffset - offset3;
  if (offsetDiff) Date.prototype.setUTCMinutes.call(date, Date.prototype.getUTCMinutes.call(date) + offsetDiff);
  const systemDate = /* @__PURE__ */ new Date(+date);
  systemDate.setUTCSeconds(0);
  const systemSecondsOffset = systemOffset > 0 ? systemDate.getSeconds() : (systemDate.getSeconds() - 60) % 60;
  const secondsOffset = Math.round(-(tzOffset(date.timeZone, date) * 60)) % 60;
  if (secondsOffset || systemSecondsOffset) {
    date.internal.setUTCSeconds(date.internal.getUTCSeconds() + secondsOffset);
    Date.prototype.setUTCSeconds.call(date, Date.prototype.getUTCSeconds.call(date) + secondsOffset + systemSecondsOffset);
  }
  const postBaseOffset = tzOffset(date.timeZone, date);
  const postOffset = postBaseOffset > 0 ? Math.floor(postBaseOffset) : Math.ceil(postBaseOffset);
  const postSystemOffset = -(/* @__PURE__ */ new Date(+date)).getTimezoneOffset();
  const postOffsetDiff = postSystemOffset - postOffset;
  const offsetChanged = postOffset !== offset3;
  const postDiff = postOffsetDiff - offsetDiff;
  if (offsetChanged && postDiff) {
    Date.prototype.setUTCMinutes.call(date, Date.prototype.getUTCMinutes.call(date) + postDiff);
    const newBaseOffset = tzOffset(date.timeZone, date);
    const newOffset = newBaseOffset > 0 ? Math.floor(newBaseOffset) : Math.ceil(newBaseOffset);
    const offsetChange = postOffset - newOffset;
    if (offsetChange) {
      date.internal.setUTCMinutes(date.internal.getUTCMinutes() + offsetChange);
      Date.prototype.setUTCMinutes.call(date, Date.prototype.getUTCMinutes.call(date) + offsetChange);
    }
  }
}

// node_modules/@date-fns/tz/date/index.js
var TZDate = class _TZDate extends TZDateMini {
  //#region static
  static tz(tz, ...args) {
    return args.length ? new _TZDate(...args, tz) : new _TZDate(Date.now(), tz);
  }
  //#endregion
  //#region representation
  toISOString() {
    const [sign, hours, minutes] = this.tzComponents();
    const tz = `${sign}${hours}:${minutes}`;
    return this.internal.toISOString().slice(0, -1) + tz;
  }
  toString() {
    return `${this.toDateString()} ${this.toTimeString()}`;
  }
  toDateString() {
    const [day, date, month, year] = this.internal.toUTCString().split(" ");
    return `${day == null ? void 0 : day.slice(0, -1)} ${month} ${date} ${year}`;
  }
  toTimeString() {
    const time = this.internal.toUTCString().split(" ")[4];
    const [sign, hours, minutes] = this.tzComponents();
    return `${time} GMT${sign}${hours}${minutes} (${tzName(this.timeZone, this)})`;
  }
  toLocaleString(locales, options) {
    return Date.prototype.toLocaleString.call(this, locales, {
      ...options,
      timeZone: (options == null ? void 0 : options.timeZone) || this.timeZone
    });
  }
  toLocaleDateString(locales, options) {
    return Date.prototype.toLocaleDateString.call(this, locales, {
      ...options,
      timeZone: (options == null ? void 0 : options.timeZone) || this.timeZone
    });
  }
  toLocaleTimeString(locales, options) {
    return Date.prototype.toLocaleTimeString.call(this, locales, {
      ...options,
      timeZone: (options == null ? void 0 : options.timeZone) || this.timeZone
    });
  }
  //#endregion
  //#region private
  tzComponents() {
    const offset3 = this.getTimezoneOffset();
    const sign = offset3 > 0 ? "-" : "+";
    const hours = String(Math.floor(Math.abs(offset3) / 60)).padStart(2, "0");
    const minutes = String(Math.abs(offset3) % 60).padStart(2, "0");
    return [sign, hours, minutes];
  }
  //#endregion
  withTimeZone(timeZone) {
    return new _TZDate(+this, timeZone);
  }
  //#region date-fns integration
  [Symbol.for("constructDateFrom")](date) {
    return new _TZDate(+new Date(date), this.timeZone);
  }
  //#endregion
};

// node_modules/@vuepic/vue-datepicker/dist/vue-datepicker.js
function Kt() {
  return h(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon",
      role: "img"
    },
    [
      h("path", {
        d: "M29.333 8c0-2.208-1.792-4-4-4h-18.667c-2.208 0-4 1.792-4 4v18.667c0 2.208 1.792 4 4 4h18.667c2.208 0 4-1.792 4-4v-18.667zM26.667 8v18.667c0 0.736-0.597 1.333-1.333 1.333 0 0-18.667 0-18.667 0-0.736 0-1.333-0.597-1.333-1.333 0 0 0-18.667 0-18.667 0-0.736 0.597-1.333 1.333-1.333 0 0 18.667 0 18.667 0 0.736 0 1.333 0.597 1.333 1.333z"
      }),
      h("path", {
        d: "M20 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z"
      }),
      h("path", {
        d: "M9.333 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z"
      }),
      h("path", {
        d: "M4 14.667h24c0.736 0 1.333-0.597 1.333-1.333s-0.597-1.333-1.333-1.333h-24c-0.736 0-1.333 0.597-1.333 1.333s0.597 1.333 1.333 1.333z"
      })
    ]
  );
}
function Fn() {
  return h(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon",
      role: "img"
    },
    [
      h("path", {
        d: "M23.057 7.057l-16 16c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l16-16c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0z"
      }),
      h("path", {
        d: "M7.057 8.943l16 16c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885l-16-16c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z"
      })
    ]
  );
}
function La() {
  return h(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon",
      role: "img"
    },
    [
      h("path", {
        d: "M20.943 23.057l-7.057-7.057c0 0 7.057-7.057 7.057-7.057 0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-8 8c-0.521 0.521-0.521 1.365 0 1.885l8 8c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z"
      })
    ]
  );
}
function Ha() {
  return h(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon",
      role: "img"
    },
    [
      h("path", {
        d: "M12.943 24.943l8-8c0.521-0.521 0.521-1.365 0-1.885l-8-8c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885l7.057 7.057c0 0-7.057 7.057-7.057 7.057-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0z"
      })
    ]
  );
}
function Ka() {
  return h(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon",
      role: "img"
    },
    [
      h("path", {
        d: "M16 1.333c-8.095 0-14.667 6.572-14.667 14.667s6.572 14.667 14.667 14.667c8.095 0 14.667-6.572 14.667-14.667s-6.572-14.667-14.667-14.667zM16 4c6.623 0 12 5.377 12 12s-5.377 12-12 12c-6.623 0-12-5.377-12-12s5.377-12 12-12z"
      }),
      h("path", {
        d: "M14.667 8v8c0 0.505 0.285 0.967 0.737 1.193l5.333 2.667c0.658 0.329 1.46 0.062 1.789-0.596s0.062-1.46-0.596-1.789l-4.596-2.298c0 0 0-7.176 0-7.176 0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z"
      })
    ]
  );
}
function ja() {
  return h(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon",
      role: "img"
    },
    [
      h("path", {
        d: "M24.943 19.057l-8-8c-0.521-0.521-1.365-0.521-1.885 0l-8 8c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l7.057-7.057c0 0 7.057 7.057 7.057 7.057 0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z"
      })
    ]
  );
}
function za() {
  return h(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon",
      role: "img"
    },
    [
      h("path", {
        d: "M7.057 12.943l8 8c0.521 0.521 1.365 0.521 1.885 0l8-8c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-7.057 7.057c0 0-7.057-7.057-7.057-7.057-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z"
      })
    ]
  );
}
var Oe = reactive({
  monthYear: [],
  calendar: [],
  time: [],
  actionRow: [],
  selectionGrid: [],
  timePicker: {
    0: [],
    1: []
  },
  monthPicker: []
});
var ya = ref(null);
var Jt = ref(false);
var ba = ref(false);
var ka = ref(false);
var wa = ref(false);
var Ke = ref(0);
var Ve = ref(0);
var yt = () => {
  const e = computed(() => Jt.value ? [...Oe.selectionGrid, Oe.actionRow].filter((f) => f.length) : ba.value ? [
    ...Oe.timePicker[0],
    ...Oe.timePicker[1],
    wa.value ? [] : [ya.value],
    Oe.actionRow
  ].filter((f) => f.length) : ka.value ? [...Oe.monthPicker, Oe.actionRow] : [Oe.monthYear, ...Oe.calendar, Oe.time, Oe.actionRow].filter((f) => f.length)), w = (f) => {
    Ke.value = f ? Ke.value + 1 : Ke.value - 1;
    let W = null;
    e.value[Ve.value] && (W = e.value[Ve.value][Ke.value]), !W && e.value[Ve.value + (f ? 1 : -1)] ? (Ve.value = Ve.value + (f ? 1 : -1), Ke.value = f ? 0 : e.value[Ve.value].length - 1) : W || (Ke.value = f ? Ke.value - 1 : Ke.value + 1);
  }, h2 = (f) => {
    if (Ve.value === 0 && !f || Ve.value === e.value.length && f) return;
    Ve.value = f ? Ve.value + 1 : Ve.value - 1, e.value[Ve.value] ? e.value[Ve.value] && !e.value[Ve.value][Ke.value] && Ke.value !== 0 && (Ke.value = e.value[Ve.value].length - 1) : Ve.value = f ? Ve.value - 1 : Ve.value + 1;
  }, r = (f) => {
    let W = null;
    e.value[Ve.value] && (W = e.value[Ve.value][Ke.value]), W ? W.focus({ preventScroll: !Jt.value }) : Ke.value = f ? Ke.value - 1 : Ke.value + 1;
  }, o = () => {
    w(true), r(true);
  }, s = () => {
    w(false), r(false);
  }, a = () => {
    h2(false), r(true);
  }, l = () => {
    h2(true), r(true);
  }, d = (f, W) => {
    Oe[W] = f;
  }, x = (f, W) => {
    Oe[W] = f;
  }, P = () => {
    Ke.value = 0, Ve.value = 0;
  };
  return {
    buildMatrix: d,
    buildMultiLevelMatrix: x,
    setTimePickerBackRef: (f) => {
      ya.value = f;
    },
    setSelectionGrid: (f) => {
      Jt.value = f, P(), f || (Oe.selectionGrid = []);
    },
    setTimePicker: (f, W = false) => {
      ba.value = f, wa.value = W, P(), f || (Oe.timePicker[0] = [], Oe.timePicker[1] = []);
    },
    setTimePickerElements: (f, W = 0) => {
      Oe.timePicker[W] = f;
    },
    arrowRight: o,
    arrowLeft: s,
    arrowUp: a,
    arrowDown: l,
    clearArrowNav: () => {
      Oe.monthYear = [], Oe.calendar = [], Oe.time = [], Oe.actionRow = [], Oe.selectionGrid = [], Oe.timePicker[0] = [], Oe.timePicker[1] = [], Jt.value = false, ba.value = false, wa.value = false, ka.value = false, P(), ya.value = null;
    },
    setMonthPicker: (f) => {
      ka.value = f, P();
    },
    refSets: Oe
    // exposed for testing
  };
};
var lt = ((e) => (e.month = "month", e.year = "year", e))(lt || {});
var _t = ((e) => (e.header = "header", e.calendar = "calendar", e.timePicker = "timePicker", e))(_t || {});
var Qe = ((e) => (e.month = "month", e.year = "year", e.calendar = "calendar", e.time = "time", e.minutes = "minutes", e.hours = "hours", e.seconds = "seconds", e))(Qe || {});
var Nn = ["timestamp", "date", "iso"];
var qe = ((e) => (e.up = "up", e.down = "down", e.left = "left", e.right = "right", e))(qe || {});
var xe = ((e) => (e.arrowUp = "ArrowUp", e.arrowDown = "ArrowDown", e.arrowLeft = "ArrowLeft", e.arrowRight = "ArrowRight", e.enter = "Enter", e.space = " ", e.esc = "Escape", e.tab = "Tab", e.home = "Home", e.end = "End", e.pageUp = "PageUp", e.pageDown = "PageDown", e))(xe || {});
var St = ((e) => (e.MONTH_AND_YEAR = "MM-yyyy", e.YEAR = "yyyy", e.DATE = "dd-MM-yyyy", e))(St || {});
var Wn = () => {
  const { checkPartialRangeValue: e, checkRangeEnabled: w, isValidDate: h2 } = nt(), { convertType: r, errorMapper: o } = Fe(), {
    getDate: s,
    rootEmit: a,
    state: l,
    rootProps: d,
    inputValue: x,
    defaults: { textInput: P, range: O, multiDates: M, timeConfig: i, formats: _ },
    modelValue: u,
    updateTime: T
  } = Se(), { setTime: f, getWeekFromDate: W } = ze(), { formatSelectedDate: B, formatForTextInput: D } = kt();
  watch(
    u,
    (b, X) => {
      a("internal-model-change", u.value), JSON.stringify(X ?? {}) !== JSON.stringify(b ?? {}) && T();
    },
    { deep: true }
  ), watch(O, (b, X) => {
    b.enabled !== X.enabled && (u.value = null);
  }), watch(
    () => _.value.input,
    () => {
      ne();
    }
  );
  const F = (b) => b ? d.modelType ? ye(b) : {
    hours: getHours(b),
    minutes: getMinutes(b),
    seconds: i.value.enableSeconds ? getSeconds(b) : 0
  } : null, Q = (b) => d.modelType ? ye(b) : { month: getMonth(b), year: getYear(b) }, I = (b) => Array.isArray(b) ? M.value.enabled ? b.map((X) => y(X, setYear(s(), X))) : w(
    () => [
      setYear(s(), b[0]),
      b[1] ? setYear(s(), b[1]) : e(O.value.partialRange)
    ],
    O.value.enabled
  ) : setYear(s(), +b), y = (b, X) => (typeof b == "string" || typeof b == "number") && d.modelType ? ie(b) : X, m = (b) => Array.isArray(b) ? [
    y(b[0], f(b[0])),
    y(b[1], f(b[1]))
  ] : y(b, f(b)), k = (b) => {
    const X = set(s(), { date: 1 });
    return Array.isArray(b) ? M.value.enabled ? b.map(
      (L) => y(L, set(X, { month: +L.month, year: +L.year }))
    ) : w(
      () => [
        y(b[0], set(X, { month: +b[0].month, year: +b[0].year })),
        y(
          b[1],
          b[1] ? set(X, { month: +b[1].month, year: +b[1].year }) : e(O.value.partialRange)
        )
      ],
      O.value.enabled
    ) : y(b, set(X, { month: +b.month, year: +b.year }));
  }, R = (b) => {
    if (Array.isArray(b))
      return b.map((X) => ie(X));
    throw new Error(o.dateArr("multi-dates"));
  }, z = (b) => {
    if (Array.isArray(b) && O.value.enabled) {
      const X = b[0], L = b[1];
      return [
        s(Array.isArray(X) ? X[0] : null),
        Array.isArray(L) && L.length ? s(L[0]) : null
      ];
    }
    return s(b[0]);
  }, Z = (b) => d.modelAuto ? Array.isArray(b) ? [ie(b[0]), ie(b[1])] : d.autoApply ? [ie(b)] : [ie(b), null] : Array.isArray(b) ? w(
    () => b[1] ? [
      ie(b[0]),
      b[1] ? ie(b[1]) : e(O.value.partialRange)
    ] : [ie(b[0])],
    O.value.enabled
  ) : ie(b), te = () => {
    Array.isArray(u.value) && O.value.enabled && u.value.length === 1 && u.value.push(e(O.value.partialRange));
  }, de = () => {
    const b = u.value;
    return [
      ye(b[0]),
      b[1] ? ye(b[1]) : e(O.value.partialRange)
    ];
  }, ge = () => Array.isArray(u.value) ? u.value[1] ? de() : ye(r(u.value[0])) : [], H = () => (u.value || []).map((b) => ye(b)), se = (b = false) => (b || te(), d.modelAuto ? ge() : M.value.enabled ? H() : Array.isArray(u.value) ? w(() => de(), O.value.enabled) : ye(r(u.value))), E = (b) => !b || Array.isArray(b) && !b.length ? null : d.timePicker ? m(r(b)) : d.monthPicker ? k(r(b)) : d.yearPicker ? I(r(b)) : M.value.enabled ? R(r(b)) : d.weekPicker ? z(r(b)) : Z(r(b)), ae = (b) => {
    if (l.isTextInputDate) return;
    const X = E(b);
    h2(r(X)) ? (u.value = r(X), ne()) : (u.value = null, x.value = "");
  }, K = () => u.value ? M.value.enabled ? u.value.map((b) => B(b)).join("; ") : P.value.enabled ? D() : B(u.value) : "", ne = () => {
    x.value = K();
  }, ie = (b) => d.modelType ? Nn.includes(d.modelType) ? s(b) : d.modelType === "format" && typeof _.value.input == "string" ? parse(b, _.value.input, s(), { locale: d.locale }) : parse(b, d.modelType, s(), { locale: d.locale }) : s(b), ye = (b) => b ? d.modelType ? d.modelType === "timestamp" ? +b : d.modelType === "iso" ? b.toISOString() : d.modelType === "format" && typeof _.value.input == "string" ? B(b) : B(b, d.modelType) : b : null, _e = (b) => {
    a("update:model-value", b);
  }, Ae = (b) => Array.isArray(u.value) ? M.value.enabled ? u.value.map((X) => b(X)) : [b(u.value[0]), u.value[1] ? b(u.value[1]) : null] : b(r(u.value)), le = () => {
    if (Array.isArray(u.value)) {
      const b = W(u.value[0], d.weekStart), X = u.value[1] ? W(u.value[1], d.weekStart) : [];
      return [b.map((L) => s(L)), X.map((L) => s(L))];
    }
    return W(u.value, d.weekStart).map((b) => s(b));
  }, me = (b) => _e(r(Ae(b))), $ = () => a("update:model-value", le());
  return {
    checkBeforeEmit: () => u.value ? O.value.enabled ? O.value.partialRange ? u.value.length >= 1 : u.value.length === 2 : !!u.value : false,
    parseExternalModelValue: ae,
    formatInputValue: ne,
    emitModelValue: () => (ne(), d.monthPicker ? me(Q) : d.timePicker ? me(F) : d.yearPicker ? me(getYear) : d.weekPicker ? $() : _e(se()))
  };
};
var dt = [
  { name: "clock-icon", use: ["time", "calendar", "shared"] },
  { name: "arrow-left", use: ["month-year", "calendar", "shared", "year-mode"] },
  { name: "arrow-right", use: ["month-year", "calendar", "shared", "year-mode"] },
  { name: "arrow-up", use: ["time", "calendar", "month-year", "shared"] },
  { name: "arrow-down", use: ["time", "calendar", "month-year", "shared"] },
  { name: "calendar-icon", use: ["month-year", "time", "calendar", "shared", "year-mode"] },
  { name: "day", use: ["calendar", "shared"] },
  { name: "month-overlay-value", use: ["calendar", "month-year", "shared"] },
  { name: "year-overlay-value", use: ["calendar", "month-year", "shared", "year-mode"] },
  { name: "year-overlay", use: ["month-year", "shared"] },
  { name: "month-overlay", use: ["month-year", "shared"] },
  { name: "month-overlay-header", use: ["month-year", "shared"] },
  { name: "year-overlay-header", use: ["month-year", "shared"] },
  { name: "hours-overlay-value", use: ["calendar", "time", "shared"] },
  { name: "hours-overlay-header", use: ["calendar", "time", "shared"] },
  { name: "minutes-overlay-value", use: ["calendar", "time", "shared"] },
  { name: "minutes-overlay-header", use: ["calendar", "time", "shared"] },
  { name: "seconds-overlay-value", use: ["calendar", "time", "shared"] },
  { name: "seconds-overlay-header", use: ["calendar", "time", "shared"] },
  { name: "hours", use: ["calendar", "time", "shared"] },
  { name: "minutes", use: ["calendar", "time", "shared"] },
  { name: "month", use: ["calendar", "month-year", "shared"] },
  { name: "year", use: ["calendar", "month-year", "shared", "year-mode"] },
  { name: "action-buttons", use: ["action"] },
  { name: "action-preview", use: ["action"] },
  { name: "calendar-header", use: ["calendar", "shared"] },
  { name: "marker-tooltip", use: ["calendar", "shared"] },
  { name: "action-extra", use: ["menu"] },
  { name: "time-picker-overlay", use: ["calendar", "time", "shared"] },
  { name: "am-pm-button", use: ["calendar", "time", "shared"] },
  { name: "left-sidebar", use: ["menu"] },
  { name: "right-sidebar", use: ["menu"] },
  { name: "month-year", use: ["month-year", "shared"] },
  { name: "time-picker", use: ["menu", "shared"] },
  { name: "action-row", use: ["action"] },
  { name: "marker", use: ["calendar", "shared"] },
  { name: "quarter", use: ["shared"] },
  { name: "top-extra", use: ["shared", "month-year"] },
  { name: "tp-inline-arrow-up", use: ["shared", "time"] },
  { name: "tp-inline-arrow-down", use: ["shared", "time"] },
  { name: "menu-header", use: ["menu"] }
];
var Ya = [{ name: "trigger" }, { name: "input-icon" }, { name: "clear-icon" }, { name: "dp-input" }];
var Ln = {
  all: () => dt,
  root: () => dt.concat(Ya),
  monthYear: () => dt.filter((e) => e.use.includes("month-year")),
  input: () => Ya,
  timePicker: () => dt.filter((e) => e.use.includes("time")),
  action: () => dt.filter((e) => e.use.includes("action")),
  calendar: () => dt.filter((e) => e.use.includes("calendar")),
  menu: () => dt.filter((e) => e.use.includes("menu")),
  shared: () => dt.filter((e) => e.use.includes("shared")),
  yearMode: () => dt.filter((e) => e.use.includes("year-mode"))
};
var bt = () => ({
  mapSlots: (w, h2, r) => {
    const o = [];
    for (const s of Ln[h2]())
      w[s.name] && o.push(s.name);
    if (r == null ? void 0 : r.length)
      for (const s of r)
        s.slot && o.push(s.slot);
    return o;
  }
});
var Ua = Symbol("ContextKey");
var Hn = (e, w) => {
  const { setTimeModelValue: h2 } = Fe(), r = Or(e), o = ref(null), s = reactive({
    menuFocused: false,
    shiftKeyInMenu: false,
    isInputFocused: false,
    isTextInputDate: false
  }), a = r.getDate(/* @__PURE__ */ new Date()), l = ref(""), d = ref([{ month: getMonth(a), year: getYear(a) }]), x = reactive({ hours: 0, minutes: 0, seconds: 0 });
  h2(x, null, a, r.range.value.enabled);
  const P = computed({
    get: () => o.value,
    set: (u) => {
      o.value = u;
    }
  }), O = computed(
    () => (u) => d.value[u] ? d.value[u].month : 0
  ), M = computed(
    () => (u) => d.value[u] ? d.value[u].year : 0
  ), i = (u, T) => {
    s[u] = T;
  }, _ = () => {
    h2(x, P.value, a, r.range.value.enabled);
  };
  provide(Ua, {
    rootProps: e,
    defaults: r,
    modelValue: P,
    state: readonly(s),
    rootEmit: w,
    calendars: d,
    month: O,
    year: M,
    time: x,
    today: a,
    inputValue: l,
    setState: i,
    updateTime: _,
    getDate: r.getDate
  });
};
var Se = () => {
  const e = inject(Ua);
  if (!e)
    throw new Error("Can't use context");
  return e;
};
var jt = () => {
  const {
    defaults: { transitions: e }
  } = Se(), w = computed(() => (r) => e.value ? r ? e.value.open : e.value.close : ""), h2 = computed(() => (r) => e.value ? r ? e.value.menuAppearTop : e.value.menuAppearBottom : "");
  return { transitionName: w, showTransition: !!e.value, menuTransition: h2 };
};
var zt = (e) => {
  const {
    today: w,
    time: h2,
    modelValue: r,
    defaults: { range: o }
  } = Se(), { setTimeModelValue: s } = Fe();
  watch(
    o,
    (a, l) => {
      a.enabled !== l.enabled && s(h2, r.value, w, o.value.enabled);
    },
    { deep: true }
  ), watch(
    r,
    (a, l) => {
      e && JSON.stringify(a ?? {}) !== JSON.stringify(l ?? {}) && e();
    },
    { deep: true }
  );
};
var nt = () => {
  const {
    defaults: { safeDates: e, range: w, multiDates: h2, filters: r, timeConfig: o },
    rootProps: s,
    getDate: a
  } = Se(), { getMapKeyType: l, getMapDate: d, errorMapper: x, convertType: P } = Fe(), { isDateBefore: O, isDateAfter: M, isDateEqual: i, resetDate: _, getDaysInBetween: u, setTimeValue: T, getTimeObj: f, setTime: W } = ze(), B = (p) => e.value.disabledDates ? typeof e.value.disabledDates == "function" ? e.value.disabledDates(a(p)) : !!d(p, e.value.disabledDates) : false, D = (p) => e.value.maxDate ? s.yearPicker ? getYear(p) > getYear(e.value.maxDate) : M(p, e.value.maxDate) : false, F = (p) => e.value.minDate ? s.yearPicker ? getYear(p) < getYear(e.value.minDate) : O(p, e.value.minDate) : false, Q = (p) => {
    var _a;
    if (!p) return false;
    const S = D(p), g = F(p), Y = B(p), v = r.value.months.map((he) => +he).includes(getMonth(p)), n = ((_a = r.value.weekDays) == null ? void 0 : _a.length) ? r.value.weekDays.some((he) => +he === getDay(p)) : false, V = R(p), N = getYear(p), ue = N < +s.yearRange[0] || N > +s.yearRange[1];
    return !(S || g || Y || v || ue || n || V);
  }, I = (p, S) => O(...$(e.value.minDate, p, S)) || i(...$(e.value.minDate, p, S)), y = (p, S) => M(...$(e.value.maxDate, p, S)) || i(...$(e.value.maxDate, p, S)), m = (p, S, g) => {
    let Y = false;
    return e.value.maxDate && g && y(p, S) && (Y = true), e.value.minDate && !g && I(p, S) && (Y = true), Y;
  }, k = (p, S, g, Y) => {
    let G = false;
    return Y && (e.value.minDate || e.value.maxDate) ? e.value.minDate && e.value.maxDate ? G = m(p, S, g) : (e.value.minDate && I(p, S) || e.value.maxDate && y(p, S)) && (G = true) : G = true, G;
  }, R = (p) => Array.isArray(e.value.allowedDates) && !e.value.allowedDates.length ? true : e.value.allowedDates ? !d(
    p,
    e.value.allowedDates,
    l(s.monthPicker, s.yearPicker)
  ) : false, z = (p) => !Q(p), Z = (p) => w.value.noDisabledRange ? !eachDayOfInterval({ start: p[0], end: p[1] }).some((g) => z(g)) : true, te = (p) => {
    if (p) {
      const S = getYear(p);
      return S >= +s.yearRange[0] && S <= s.yearRange[1];
    }
    return true;
  }, de = (p, S) => !!(Array.isArray(p) && p[S] && (w.value.maxRange || w.value.minRange) && te(p[S])), ge = (p, S, g = 0) => {
    if (de(S, g) && te(p)) {
      const Y = differenceInCalendarDays(p, S[g]), G = u(S[g], p), v = G.length === 1 ? 0 : G.filter((V) => z(V)).length, n = Math.abs(Y) - (w.value.minMaxRawRange ? 0 : v);
      if (w.value.minRange && w.value.maxRange)
        return n >= +w.value.minRange && n <= +w.value.maxRange;
      if (w.value.minRange) return n >= +w.value.minRange;
      if (w.value.maxRange) return n <= +w.value.maxRange;
    }
    return true;
  }, H = () => !o.value.enableTimePicker || s.monthPicker || s.yearPicker || o.value.ignoreTimeValidation, se = (p) => Array.isArray(p) ? [p[0] ? T(p[0]) : null, p[1] ? T(p[1]) : null] : T(p), E = (p, S, g) => S ? p.find(
    (Y) => +Y.hours === getHours(S) && Y.minutes === "*" ? true : +Y.minutes === getMinutes(S) && +Y.hours === getHours(S)
  ) && g : false, ae = (p, S, g) => {
    const [Y, G] = p, [v, n] = S;
    return !E(Y, v, g) && !E(G, n, g) && g;
  }, K = (p, S) => {
    const g = Array.isArray(S) ? S : [S];
    return Array.isArray(s.disabledTimes) ? Array.isArray(s.disabledTimes[0]) ? ae(s.disabledTimes, g, p) : !g.some((Y) => E(s.disabledTimes, Y, p)) : p;
  }, ne = (p, S) => {
    const g = Array.isArray(S) ? [f(S[0]), S[1] ? f(S[1]) : void 0] : f(S), Y = !s.disabledTimes(g);
    return p && Y;
  }, ie = (p, S) => s.disabledTimes ? Array.isArray(s.disabledTimes) ? K(S, p) : ne(S, p) : S, ye = (p) => {
    let S = true;
    if (!p || H()) return true;
    const g = !e.value.minDate && !e.value.maxDate ? se(p) : p;
    return (s.maxTime || e.value.maxDate) && (S = ee(
      s.maxTime,
      e.value.maxDate,
      "max",
      P(g),
      S
    )), (s.minTime || e.value.minDate) && (S = ee(
      s.minTime,
      e.value.minDate,
      "min",
      P(g),
      S
    )), ie(p, S);
  }, _e = (p) => {
    if (!s.monthPicker) return true;
    let S = true;
    const g = a(_(p));
    if (e.value.minDate && e.value.maxDate) {
      const Y = a(_(e.value.minDate)), G = a(_(e.value.maxDate));
      return M(g, Y) && O(g, G) || i(g, Y) || i(g, G);
    }
    if (e.value.minDate) {
      const Y = a(_(e.value.minDate));
      S = M(g, Y) || i(g, Y);
    }
    if (e.value.maxDate) {
      const Y = a(_(e.value.maxDate));
      S = O(g, Y) || i(g, Y);
    }
    return S;
  }, Ae = computed(() => (p) => !o.value.enableTimePicker || o.value.ignoreTimeValidation ? true : ye(p)), le = computed(() => (p) => s.monthPicker ? Array.isArray(p) && (w.value.enabled || h2.value.enabled) ? !p.filter((g) => !_e(g)).length : _e(p) : true), me = (p, S, g) => {
    if (!S || g && !e.value.maxDate || !g && !e.value.minDate) return false;
    const Y = g ? addMonths(p, 1) : subMonths(p, 1), G = [getMonth(Y), getYear(Y)];
    return g ? !y(...G) : !I(...G);
  }, $ = (p, S, g) => [set(a(p), { date: 1 }), set(a(), { month: S, year: g, date: 1 })], oe = (p, S, g, Y) => {
    if (!p) return true;
    if (Y) {
      const G = g === "max" ? isBefore(p, S) : isAfter(p, S), v = { seconds: 0, milliseconds: 0 };
      return G || isEqual(set(p, v), set(S, v));
    }
    return g === "max" ? p.getTime() <= S.getTime() : p.getTime() >= S.getTime();
  }, ee = (p, S, g, Y, G) => {
    if (Array.isArray(Y)) {
      const n = b(p, Y[0], S), V = b(p, Y[1], S);
      return oe(Y[0], n, g, !!S) && oe(Y[1], V, g, !!S) && G;
    }
    const v = b(p, Y, S);
    return oe(Y, v, g, !!S) && G;
  }, b = (p, S, g) => p ? W(p, S) : a(g ?? S);
  return {
    isDisabled: z,
    validateDate: Q,
    validateMonthYearInRange: k,
    isDateRangeAllowed: Z,
    checkMinMaxRange: ge,
    isValidTime: ye,
    validateMonthYear: me,
    validateMinDate: I,
    validateMaxDate: y,
    isValidDate: (p) => Array.isArray(p) ? isValid(p[0]) && (p[1] ? isValid(p[1]) : true) : p ? isValid(p) : false,
    checkPartialRangeValue: (p) => {
      if (p) return null;
      throw new Error(x.prop("partial-range"));
    },
    checkRangeEnabled: (p, S) => {
      if (S) return p();
      throw new Error(x.prop("range"));
    },
    checkMinMaxValue: (p, S, g) => {
      const Y = g != null, G = S != null;
      if (!Y && !G) return false;
      const v = +g, n = +S;
      return Y && G ? +p > v || +p < n : Y ? +p > v : G ? +p < n : false;
    },
    isTimeValid: Ae,
    isMonthValid: le
  };
};
var Kn = (e) => {
  const {
    rootEmit: w,
    rootProps: h2,
    defaults: { timeConfig: r, flow: o }
  } = Se(), s = ref(0), a = reactive({
    [_t.timePicker]: !r.value.enableTimePicker || h2.timePicker || h2.monthPicker,
    [_t.calendar]: false,
    [_t.header]: false
  }), l = computed(() => h2.monthPicker || h2.timePicker), d = (i) => {
    var _a, _b;
    if ((_b = (_a = o.value) == null ? void 0 : _a.steps) == null ? void 0 : _b.length) {
      if (!i && l.value) return M();
      a[i] = true, Object.keys(a).filter((_) => !a[_]).length || M();
    }
  }, x = () => {
    var _a, _b, _c, _d;
    ((_b = (_a = o.value) == null ? void 0 : _a.steps) == null ? void 0 : _b.length) && s.value !== -1 && (s.value += 1, w("flow-step", s.value), M()), ((_d = (_c = o.value) == null ? void 0 : _c.steps) == null ? void 0 : _d.length) === s.value && nextTick().then(() => P());
  }, P = () => {
    s.value = -1;
  }, O = (i, _, ...u) => {
    var _a, _b, _c;
    ((_a = o.value) == null ? void 0 : _a.steps[s.value]) === i && e.value && ((_c = (_b = e.value)[_]) == null ? void 0 : _c.call(_b, ...u));
  }, M = (i = 0) => {
    var _a;
    i && (s.value += i), O(Qe.month, "toggleMonthPicker", true), O(Qe.year, "toggleYearPicker", true), O(Qe.calendar, "toggleTimePicker", false, true), O(Qe.time, "toggleTimePicker", true, true);
    const _ = (_a = o.value) == null ? void 0 : _a.steps[s.value];
    (_ === Qe.hours || _ === Qe.minutes || _ === Qe.seconds) && O(_, "toggleTimePicker", true, true, _);
  };
  return { childMount: d, updateFlowStep: x, resetFlow: P, handleFlow: M, flowStep: s };
};
function Da(e) {
  return (w = {}) => {
    const h2 = w.width ? String(w.width) : e.defaultWidth;
    return e.formats[h2] || e.formats[e.defaultWidth];
  };
}
function Vt(e) {
  return (w, h2) => {
    const r = (h2 == null ? void 0 : h2.context) ? String(h2.context) : "standalone";
    let o;
    if (r === "formatting" && e.formattingValues) {
      const a = e.defaultFormattingWidth || e.defaultWidth, l = (h2 == null ? void 0 : h2.width) ? String(h2.width) : a;
      o = e.formattingValues[l] || e.formattingValues[a];
    } else {
      const a = e.defaultWidth, l = (h2 == null ? void 0 : h2.width) ? String(h2.width) : e.defaultWidth;
      o = e.values[l] || e.values[a];
    }
    const s = e.argumentCallback ? e.argumentCallback(w) : w;
    return o[s];
  };
}
function Et(e) {
  return (w, h2 = {}) => {
    const r = h2.width, o = r && e.matchPatterns[r] || e.matchPatterns[e.defaultMatchWidth], s = w.match(o);
    if (!s)
      return null;
    const a = s[0], l = r && e.parsePatterns[r] || e.parsePatterns[e.defaultParseWidth], d = Array.isArray(l) ? zn(l, (O) => O.test(a)) : (
      // [TODO] -- I challenge you to fix the type
      jn(l, (O) => O.test(a))
    );
    let x;
    x = e.valueCallback ? e.valueCallback(d) : d, x = h2.valueCallback ? (
      // [TODO] -- I challenge you to fix the type
      h2.valueCallback(x)
    ) : x;
    const P = w.slice(a.length);
    return { value: x, rest: P };
  };
}
function jn(e, w) {
  for (const h2 in e)
    if (Object.prototype.hasOwnProperty.call(e, h2) && w(e[h2]))
      return h2;
}
function zn(e, w) {
  for (let h2 = 0; h2 < e.length; h2++)
    if (w(e[h2]))
      return h2;
}
function Un(e) {
  return (w, h2 = {}) => {
    const r = w.match(e.matchPattern);
    if (!r) return null;
    const o = r[0], s = w.match(e.parsePattern);
    if (!s) return null;
    let a = e.valueCallback ? e.valueCallback(s[0]) : s[0];
    a = h2.valueCallback ? h2.valueCallback(a) : a;
    const l = w.slice(o.length);
    return { value: a, rest: l };
  };
}
var qn = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
};
var Qn = (e, w, h2) => {
  let r;
  const o = qn[e];
  return typeof o == "string" ? r = o : w === 1 ? r = o.one : r = o.other.replace("{{count}}", w.toString()), (h2 == null ? void 0 : h2.addSuffix) ? h2.comparison && h2.comparison > 0 ? "in " + r : r + " ago" : r;
};
var Gn = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
};
var Jn = (e, w, h2, r) => Gn[e];
var Xn = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
};
var Zn = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
};
var er = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ],
  wide: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ]
};
var tr = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ]
};
var ar = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
};
var nr = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
};
var rr = (e, w) => {
  const h2 = Number(e), r = h2 % 100;
  if (r > 20 || r < 10)
    switch (r % 10) {
      case 1:
        return h2 + "st";
      case 2:
        return h2 + "nd";
      case 3:
        return h2 + "rd";
    }
  return h2 + "th";
};
var lr = {
  ordinalNumber: rr,
  era: Vt({
    values: Xn,
    defaultWidth: "wide"
  }),
  quarter: Vt({
    values: Zn,
    defaultWidth: "wide",
    argumentCallback: (e) => e - 1
  }),
  month: Vt({
    values: er,
    defaultWidth: "wide"
  }),
  day: Vt({
    values: tr,
    defaultWidth: "wide"
  }),
  dayPeriod: Vt({
    values: ar,
    defaultWidth: "wide",
    formattingValues: nr,
    defaultFormattingWidth: "wide"
  })
};
var or = /^(\d+)(th|st|nd|rd)?/i;
var sr = /\d+/i;
var ur = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var ir = {
  any: [/^b/i, /^(a|c)/i]
};
var cr = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var dr = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var vr = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var fr = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^may/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
var mr = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var pr = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var hr = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var gr = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var yr = {
  ordinalNumber: Un({
    matchPattern: or,
    parsePattern: sr,
    valueCallback: (e) => parseInt(e, 10)
  }),
  era: Et({
    matchPatterns: ur,
    defaultMatchWidth: "wide",
    parsePatterns: ir,
    defaultParseWidth: "any"
  }),
  quarter: Et({
    matchPatterns: cr,
    defaultMatchWidth: "wide",
    parsePatterns: dr,
    defaultParseWidth: "any",
    valueCallback: (e) => e + 1
  }),
  month: Et({
    matchPatterns: vr,
    defaultMatchWidth: "wide",
    parsePatterns: fr,
    defaultParseWidth: "any"
  }),
  day: Et({
    matchPatterns: mr,
    defaultMatchWidth: "wide",
    parsePatterns: pr,
    defaultParseWidth: "any"
  }),
  dayPeriod: Et({
    matchPatterns: hr,
    defaultMatchWidth: "any",
    parsePatterns: gr,
    defaultParseWidth: "any"
  })
};
var br = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
var kr = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var wr = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var Dr = {
  date: Da({
    formats: br,
    defaultWidth: "full"
  }),
  time: Da({
    formats: kr,
    defaultWidth: "full"
  }),
  dateTime: Da({
    formats: wr,
    defaultWidth: "full"
  })
};
var Mr = {
  code: "en-US",
  formatDistance: Qn,
  formatLong: Dr,
  formatRelative: Jn,
  localize: lr,
  match: yr,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
var Oa = {
  noDisabledRange: false,
  showLastInRange: true,
  minMaxRawRange: false,
  partialRange: true,
  disableTimeRangeValidation: false,
  maxRange: void 0,
  minRange: void 0,
  autoRange: void 0,
  fixedStart: false,
  fixedEnd: false
};
var _r = {
  allowStopPropagation: true,
  closeOnScroll: false,
  modeHeight: 255,
  allowPreventDefault: false,
  closeOnClearValue: true,
  closeOnAutoApply: true,
  noSwipe: false,
  keepActionRow: false,
  onClickOutside: void 0,
  tabOutClosesMenu: true,
  arrowLeft: void 0,
  keepViewOnOffsetClick: false,
  timeArrowHoldThreshold: 0,
  shadowDom: false,
  mobileBreakpoint: 600,
  setDateOnMenuClose: false,
  escClose: true,
  spaceConfirm: true,
  monthChangeOnArrows: true,
  monthChangeOnScroll: true
};
var xa = {
  enterSubmit: true,
  tabSubmit: true,
  openMenu: "open",
  selectOnFocus: false,
  rangeSeparator: " - ",
  escClose: true,
  format: void 0,
  maskFormat: void 0
};
var Ar = {
  dates: [],
  years: [],
  months: [],
  quarters: [],
  weeks: [],
  weekdays: [],
  options: { highlightDisabled: false }
};
var Pr = {
  showSelect: true,
  showCancel: true,
  showNow: false,
  showPreview: true,
  selectBtnLabel: "Select",
  cancelBtnLabel: "Cancel",
  nowBtnLabel: "Now",
  nowBtnRound: void 0
};
var Tr = {
  toggleOverlay: "Toggle overlay",
  menu: "Datepicker menu",
  input: "Datepicker input",
  openTimePicker: "Open time picker",
  closeTimePicker: "Close time Picker",
  incrementValue: (e) => `Increment ${e}`,
  decrementValue: (e) => `Decrement ${e}`,
  openTpOverlay: (e) => `Open ${e} overlay`,
  amPmButton: "Switch AM/PM mode",
  openYearsOverlay: "Open years overlay",
  openMonthsOverlay: "Open months overlay",
  nextMonth: "Next month",
  prevMonth: "Previous month",
  nextYear: "Next year",
  prevYear: "Previous year",
  day: void 0,
  weekDay: void 0,
  clearInput: "Clear value",
  calendarIcon: "Calendar icon",
  timePicker: "Time picker",
  monthPicker: (e) => `Month picker${e ? " overlay" : ""}`,
  yearPicker: (e) => `Year picker${e ? " overlay" : ""}`,
  timeOverlay: (e) => `${e} overlay`
};
var Ba = {
  menuAppearTop: "dp-menu-appear-top",
  menuAppearBottom: "dp-menu-appear-bottom",
  open: "dp-slide-down",
  close: "dp-slide-up",
  next: "calendar-next",
  previous: "calendar-prev",
  vNext: "dp-slide-up",
  vPrevious: "dp-slide-down"
};
var $r = {
  weekDays: [],
  months: [],
  years: [],
  times: { hours: [], minutes: [], seconds: [] }
};
var Sr = {
  month: "LLL",
  year: "yyyy",
  weekDay: "EEEEEE",
  quarter: "MMMM",
  day: "d",
  input: void 0,
  preview: void 0
};
var Rr = {
  enableTimePicker: true,
  ignoreTimeValidation: false,
  enableSeconds: false,
  enableMinutes: true,
  is24: true,
  noHoursOverlay: false,
  noMinutesOverlay: false,
  noSecondsOverlay: false,
  hoursGridIncrement: 1,
  minutesGridIncrement: 5,
  secondsGridIncrement: 5,
  hoursIncrement: 1,
  minutesIncrement: 1,
  secondsIncrement: 1,
  timePickerInline: false,
  startTime: void 0
};
var Cr = {
  flowStep: 0,
  menuWrapRef: null,
  collapse: false
};
var Yr = {
  weekStart: 1,
  yearRange: () => [1900, 2100],
  ui: () => ({}),
  locale: () => Mr,
  dark: false,
  transitions: true,
  hideNavigation: () => [],
  vertical: false,
  hideMonthYearSelect: false,
  disableYearSelect: false,
  autoApply: false,
  disabledDates: () => [],
  hideOffsetDates: false,
  noToday: false,
  markers: () => [],
  presetDates: () => [],
  preventMinMaxNavigation: false,
  reverseYears: false,
  weekPicker: false,
  arrowNavigation: false,
  monthPicker: false,
  yearPicker: false,
  quarterPicker: false,
  timePicker: false,
  modelAuto: false,
  multiDates: false,
  range: false,
  inline: false,
  sixWeeks: false,
  focusStartDate: false,
  yearFirst: false,
  loading: false,
  centered: false
};
var Ia = {
  name: void 0,
  required: false,
  autocomplete: "off",
  state: void 0,
  clearable: true,
  alwaysClearable: false,
  hideInputIcon: false,
  id: void 0,
  inputmode: "none"
};
var Xt = {
  type: "local",
  hideOnOffsetDates: false,
  label: "W"
};
var Or = (e) => {
  const { getMapKey: w, getMapKeyType: h2, getTimeObjFromCurrent: r } = Fe();
  function o(H, se) {
    let E;
    return e.timezone ? E = new TZDate(H ?? /* @__PURE__ */ new Date(), e.timezone) : E = H ? new Date(H) : /* @__PURE__ */ new Date(), se ? set(E, { hours: 0, minutes: 0, seconds: 0, milliseconds: 0 }) : E;
  }
  const s = () => {
    const H = Z.value.enableSeconds ? ":ss" : "", se = Z.value.enableMinutes ? ":mm" : "";
    return Z.value.is24 ? `HH${se}${H}` : `hh${se}${H} aa`;
  }, a = () => {
    var _a;
    return e.monthPicker ? "MM/yyyy" : e.timePicker ? s() : e.weekPicker ? `${((_a = Q.value) == null ? void 0 : _a.type) === "iso" ? "II" : "ww"}-RR` : e.yearPicker ? "yyyy" : e.quarterPicker ? "QQQ/yyyy" : Z.value.enableTimePicker ? `MM/dd/yyyy, ${s()}` : "MM/dd/yyyy";
  }, l = (H) => r(o(), H, Z.value.enableSeconds), d = () => m.value.enabled ? Z.value.startTime && Array.isArray(Z.value.startTime) ? [l(Z.value.startTime[0]), l(Z.value.startTime[1])] : null : Z.value.startTime && !Array.isArray(Z.value.startTime) ? l(Z.value.startTime) : null, x = (H) => H ? typeof H == "boolean" ? H ? 2 : 0 : Math.max(+H, 2) : 0, P = (H) => {
    const se = h2(e.monthPicker, e.yearPicker);
    return new Map(
      H.map((E) => {
        const ae = o(E, O.value);
        return [w(ae, se), ae];
      })
    );
  }, O = computed(() => e.monthPicker || e.yearPicker || e.quarterPicker), M = computed(() => {
    const H = typeof e.multiCalendars == "object" && e.multiCalendars, se = {
      static: true,
      solo: false
    };
    if (!e.multiCalendars) return { ...se, count: x(false) };
    const E = H ? e.multiCalendars : {}, ae = H ? E.count ?? true : e.multiCalendars, K = x(ae);
    return Object.assign(se, E, { count: K });
  }), i = computed(() => d()), _ = computed(() => ({ ...Tr, ...e.ariaLabels })), u = computed(() => ({ ...$r, ...e.filters })), T = computed(() => typeof e.transitions == "boolean" ? e.transitions ? Ba : false : { ...Ba, ...e.transitions }), f = computed(() => ({ ...Pr, ...e.actionRow })), W = computed(() => typeof e.textInput == "object" ? {
    ...xa,
    ...e.textInput,
    format: typeof e.textInput.format == "string" ? e.textInput.format : R.value.input,
    pattern: e.textInput.format ?? R.value.input,
    enabled: true
  } : {
    ...xa,
    format: R.value.input,
    pattern: R.value.input,
    enabled: e.textInput
  }), B = computed(() => {
    const H = { input: false };
    return typeof e.inline == "object" ? { ...H, ...e.inline, enabled: true } : {
      enabled: e.inline,
      ...H
    };
  }), D = computed(() => ({ ..._r, ...e.config })), F = computed(() => typeof e.highlight == "function" ? e.highlight : {
    ...Ar,
    ...e.highlight
  }), Q = computed(() => {
    var _a, _b;
    return typeof e.weekNumbers == "object" ? {
      type: ((_a = e.weekNumbers) == null ? void 0 : _a.type) ?? Xt.type,
      hideOnOffsetDates: ((_b = e.weekNumbers) == null ? void 0 : _b.hideOnOffsetDates) ?? Xt.hideOnOffsetDates,
      label: e.weekNumbers.label ?? Xt.label
    } : e.weekNumbers ? Xt : void 0;
  }), I = computed(() => {
    var _a, _b;
    return typeof e.multiDates == "boolean" ? { enabled: e.multiDates, dragSelect: true, limit: null } : {
      enabled: !!e.multiDates,
      limit: ((_a = e.multiDates) == null ? void 0 : _a.limit) ? +e.multiDates.limit : null,
      dragSelect: ((_b = e.multiDates) == null ? void 0 : _b.dragSelect) ?? true
    };
  }), y = computed(() => {
    var _a;
    return {
      minDate: e.minDate ? o(e.minDate) : null,
      maxDate: e.maxDate ? o(e.maxDate) : null,
      disabledDates: Array.isArray(e.disabledDates) ? P(e.disabledDates) : e.disabledDates,
      allowedDates: Array.isArray(e.allowedDates) ? P(e.allowedDates) : null,
      highlight: typeof F.value == "object" && Array.isArray(F.value.dates) ? P(F.value.dates) : F.value,
      markers: ((_a = e.markers) == null ? void 0 : _a.length) ? new Map(
        e.markers.map((H) => {
          const se = o(H.date);
          return [w(se, St.DATE), H];
        })
      ) : null
    };
  }), m = computed(() => typeof e.range == "object" ? { enabled: true, ...Oa, ...e.range } : {
    enabled: e.range,
    ...Oa
  }), k = computed(() => ({
    ...Object.fromEntries(
      Object.keys(e.ui).map((se) => {
        const E = se, ae = e.ui[E];
        if (E === "dayClass") return [E, e.ui[E]];
        const K = typeof e.ui[E] == "string" ? { [ae]: true } : Object.fromEntries(ae.map((ne) => [ne, true]));
        return [se, K];
      })
    )
  })), R = computed(() => {
    var _a, _b;
    return {
      ...Sr,
      ...e.formats,
      input: ((_a = e.formats) == null ? void 0 : _a.input) ?? a(),
      preview: ((_b = e.formats) == null ? void 0 : _b.preview) ?? a()
    };
  }), z = computed(() => {
    if (e.teleport)
      return typeof e.teleport == "string" ? e.teleport : typeof e.teleport == "boolean" ? "body" : e.teleport;
  }), Z = computed(() => ({ ...Rr, ...e.timeConfig })), te = computed(() => {
    if (e.flow)
      return { steps: [], partial: false, ...e.flow };
  }), de = computed(() => {
    const H = W.value.enabled ? "text" : "none";
    return e.inputAttrs ? { ...Ia, inputmode: H, ...e.inputAttrs } : { ...Ia, inputmode: H };
  }), ge = computed(() => {
    var _a, _b, _c, _d;
    return {
      offset: ((_a = e.floating) == null ? void 0 : _a.offset) ?? 10,
      arrow: ((_b = e.floating) == null ? void 0 : _b.arrow) ?? true,
      strategy: ((_c = e.floating) == null ? void 0 : _c.strategy) ?? void 0,
      placement: ((_d = e.floating) == null ? void 0 : _d.placement) ?? void 0
    };
  });
  return {
    transitions: T,
    multiCalendars: M,
    startTime: i,
    ariaLabels: _,
    filters: u,
    actionRow: f,
    textInput: W,
    inline: B,
    config: D,
    highlight: F,
    weekNumbers: Q,
    range: m,
    safeDates: y,
    multiDates: I,
    ui: k,
    formats: R,
    teleport: z,
    timeConfig: Z,
    flow: te,
    inputAttrs: de,
    floatingConfig: ge,
    getDate: o
  };
};
var Fe = () => {
  const e = (D, F) => format(D, F ?? St.DATE), w = (D, F) => D ? St.MONTH_AND_YEAR : F ? St.YEAR : St.DATE, h2 = (D, F, Q) => F.get(e(D, Q)), r = (D) => D, o = (D) => D === 0 ? D : !D || Number.isNaN(+D) ? null : +D, s = () => [
    "a[href]",
    "area[href]",
    "input:not([disabled]):not([type='hidden'])",
    "select:not([disabled])",
    "textarea:not([disabled])",
    "button:not([disabled])",
    "[tabindex]:not([tabindex='-1'])",
    "[data-datepicker-instance]"
  ].join(", "), a = (D, F) => {
    let Q = [...document.querySelectorAll(s())];
    Q = Q.filter((y) => !D.contains(y) || "datepicker-instance" in y.dataset);
    const I = Q.indexOf(D);
    if (I >= 0 && (F ? I - 1 >= 0 : I + 1 <= Q.length))
      return Q[I + (F ? -1 : 1)];
  }, l = (D) => String(D).padStart(2, "0"), d = (D, F) => D == null ? void 0 : D.querySelector(`[data-dp-element="${F}"]`), x = (D, F, Q = false) => {
    D && F.allowStopPropagation && (Q && D.stopImmediatePropagation(), D.stopPropagation());
  }, P = (D, F, Q = false, I) => {
    if (D.key === xe.enter || D.key === xe.space)
      return Q && D.preventDefault(), F();
    if (I) return I(D);
  }, O = (D, F) => {
    F.allowStopPropagation && D.stopPropagation(), F.allowPreventDefault && D.preventDefault();
  }, M = (D) => {
    if (D)
      return [...D.querySelectorAll("input, button, select, textarea, a[href]")][0];
  }, i = () => "ontouchstart" in globalThis || navigator.maxTouchPoints > 0, _ = (D) => [12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11][D], u = (D) => {
    const F = [], Q = (I) => I.filter((y) => !!y);
    for (let I = 0; I < D.length; I += 3) {
      const y = [D[I], D[I + 1], D[I + 2]];
      F.push(Q(y));
    }
    return F;
  }, T = {
    prop: (D) => `"${D}" prop must be enabled!`,
    dateArr: (D) => `You need to use array as "model-value" binding in order to support "${D}"`
  }, f = (D, F, Q, I, y) => {
    const m = {
      hours: getHours,
      minutes: getMinutes,
      seconds: getSeconds
    };
    if (!F) return I ? [m[D](Q), m[D](Q)] : m[D](Q);
    if (Array.isArray(F) && I) {
      const k = F[0] ?? Q, R = F[1];
      return [m[D](k), R ? m[D](R) : y[D][1] ?? m[D](Q)];
    }
    return Array.isArray(F) && !I ? m[D](F[F.length - 1] ?? Q) : m[D](F);
  };
  return {
    getMapKey: e,
    getMapKeyType: w,
    getMapDate: h2,
    convertType: r,
    getNumVal: o,
    findNextFocusableElement: a,
    padZero: l,
    getElWithin: d,
    checkStopPropagation: x,
    checkKeyDown: P,
    handleEventPropagation: O,
    findFocusableEl: M,
    isTouchDevice: i,
    hoursToAmPmHours: _,
    getGroupedList: u,
    setTimeModelValue: (D, F, Q, I) => {
      D.hours = f("hours", F, Q, I, D), D.minutes = f("minutes", F, Q, I, D), D.seconds = f("seconds", F, Q, I, D);
    },
    getTimeObjFromCurrent: (D, F, Q) => {
      const I = {
        hours: getHours(D),
        minutes: getMinutes(D),
        seconds: Q ? getSeconds(D) : 0
      };
      return Object.assign(I, F);
    },
    errorMapper: T
  };
};
var ze = () => {
  const { getDate: e } = Se(), { getMapDate: w, getGroupedList: h2 } = Fe(), r = (m, k) => {
    if (!m) return e();
    const R = e(m), z = set(R, { hours: 0, minutes: 0, seconds: 0, milliseconds: 0 });
    return k ? startOfMonth(z) : z;
  }, o = (m, k) => {
    const R = e(k);
    return set(R, {
      hours: +(m.hours ?? getHours(R)),
      minutes: +(m.minutes ?? getMinutes(R)),
      seconds: +(m.seconds ?? getSeconds(R)),
      milliseconds: 0
    });
  }, s = (m, k) => {
    const R = startOfWeek(m, { weekStartsOn: +k }), z = endOfWeek(m, { weekStartsOn: +k });
    return [R, z];
  }, a = (m, k) => !m || !k ? false : isBefore(r(m), r(k)), l = (m, k) => !m || !k ? false : isEqual(r(m), r(k)), d = (m, k) => !m || !k ? false : isAfter(r(m), r(k)), x = (m, k, R) => (m == null ? void 0 : m[0]) && (m == null ? void 0 : m[1]) ? d(R, m[0]) && a(R, m[1]) : (m == null ? void 0 : m[0]) && k ? d(R, m[0]) && a(R, k) || a(R, m[0]) && d(R, k) : false, P = (m, k) => {
    const R = d(m, k) ? k : m, z = d(k, m) ? k : m;
    return eachDayOfInterval({ start: R, end: z });
  }, O = (m) => `dp-${format(m, "yyyy-MM-dd")}`, M = (m) => r(set(e(m), { date: 1 })), i = (m, k) => {
    if (k) {
      const R = getYear(e(k));
      if (R > m) return 12;
      if (R === m) return getMonth(e(k));
    }
  }, _ = (m, k) => {
    if (k) {
      const R = getYear(e(k));
      return R < m ? -1 : R === m ? getMonth(e(k)) : void 0;
    }
  }, u = (m) => {
    if (m) return getYear(e(m));
  }, T = (m) => ({
    hours: getHours(m),
    minutes: getMinutes(m),
    seconds: getSeconds(m)
  });
  return {
    resetDateTime: r,
    groupListAndMap: (m, k) => h2(m).map((R) => R.map((z) => {
      const { active: Z, disabled: te, isBetween: de, highlighted: ge } = k(z);
      return {
        ...z,
        active: Z,
        disabled: te,
        className: {
          dp__overlay_cell_active: Z,
          dp__overlay_cell: !Z,
          dp__overlay_cell_disabled: te,
          dp__overlay_cell_pad: true,
          dp__overlay_cell_active_disabled: te && Z,
          dp__cell_in_between: de,
          "dp--highlighted": ge
        }
      };
    })),
    setTime: o,
    getWeekFromDate: s,
    isDateAfter: d,
    isDateBefore: a,
    isDateBetween: x,
    isDateEqual: l,
    getDaysInBetween: P,
    getCellId: O,
    resetDate: M,
    getMinMonth: i,
    getMaxMonth: _,
    getYearFromDate: u,
    getTimeObj: T,
    setTimeValue: (m) => set(e(), T(m)),
    sanitizeTime: (m, k, R) => k && (R || R === 0) ? Object.fromEntries(
      ["hours", "minutes", "seconds"].map((z) => z === k ? [z, R] : [z, Number.isNaN(+m[z]) ? void 0 : +m[z]])
    ) : {
      hours: Number.isNaN(+m.hours) ? void 0 : +m.hours,
      minutes: Number.isNaN(+m.minutes) ? void 0 : +m.minutes,
      seconds: Number.isNaN(+(m.seconds ?? "")) ? void 0 : +m.seconds
    },
    getBeforeAndAfterInRange: (m, k) => {
      const R = subDays(r(k), m), z = addDays(r(k), m);
      return { before: R, after: z };
    },
    isModelAuto: (m) => Array.isArray(m) ? !!m[0] && !!m[1] : false,
    matchDate: (m, k) => m ? k ? k instanceof Map ? !!w(m, k) : k(e(m)) : false : true,
    checkHighlightMonth: (m, k, R) => typeof m == "function" ? m({ month: k, year: R }) : m.months.some((z) => z.month === k && z.year === R),
    checkHighlightYear: (m, k) => typeof m == "function" ? m(k) : m.years.includes(k)
  };
};
var na = () => {
  const {
    defaults: { config: e }
  } = Se(), w = ref(0);
  onMounted(() => {
    h2(), globalThis.addEventListener("resize", h2, { passive: true });
  }), onUnmounted(() => {
    globalThis.removeEventListener("resize", h2);
  });
  const h2 = () => {
    w.value = globalThis.document.documentElement.clientWidth;
  };
  return {
    isMobile: computed(() => w.value <= e.value.mobileBreakpoint ? true : void 0)
  };
};
var kt = () => {
  const {
    getDate: e,
    state: w,
    modelValue: h2,
    rootProps: r,
    defaults: { formats: o, textInput: s }
  } = Se(), a = (T) => format(setYear(e(), T), o.value.year, { locale: r.locale }), l = (T) => format(setMonth(e(), T), o.value.month, { locale: r.locale }), d = (T) => format(T, o.value.weekDay, { locale: r.locale }), x = (T) => format(T, o.value.quarter, { locale: r.locale }), P = (T, f) => [T, f].map((W) => x(W)).join("-"), O = (T) => format(T, o.value.day, { locale: r.locale }), M = (T, f, W) => {
    const B = W ? o.value.preview : o.value.input;
    if (!T) return "";
    if (typeof B == "function") return B(T);
    const D = f ?? B, F = { locale: r.locale };
    return Array.isArray(T) ? `${format(T[0], D, F)}${r.modelAuto && !T[1] ? "" : s.value.rangeSeparator}${T[1] ? format(T[1], D, F) : ""}` : format(T, D, F);
  }, i = () => {
    const T = (f) => format(f, s.value.format);
    return Array.isArray(h2.value) ? `${T(h2.value[0])} ${s.value.rangeSeparator} ${h2.value[1] ? T(h2.value[1]) : ""}` : "";
  };
  return {
    formatYear: a,
    formatMonth: l,
    formatWeekDay: d,
    formatQuarter: x,
    formatSelectedDate: M,
    formatForTextInput: () => w.isInputFocused && h2.value ? Array.isArray(h2.value) ? i() : format(h2.value, s.value.format) : M(h2.value),
    formatPreview: (T) => M(T, void 0, true),
    formatQuarterText: P,
    formatDay: O
  };
};
var ra = () => {
  const { rootProps: e } = Se(), { formatYear: w, formatMonth: h2 } = kt();
  return {
    getMonths: () => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].map((a) => ({
      text: h2(a),
      value: a
    })),
    getYears: () => {
      const a = [];
      for (let l = +e.yearRange[0]; l <= +e.yearRange[1]; l++)
        a.push({ value: +l, text: w(l) });
      return e.reverseYears ? a.reverse() : a;
    },
    isOutOfYearRange: (a) => a < +e.yearRange[0] || a > +e.yearRange[1]
  };
};
var xr = (e) => ({
  openMenu: () => {
    var _a;
    return (_a = e.value) == null ? void 0 : _a.openMenu();
  },
  closeMenu: () => {
    var _a;
    return (_a = e.value) == null ? void 0 : _a.closeMenu();
  },
  selectDate: () => {
    var _a;
    return (_a = e.value) == null ? void 0 : _a.selectDate();
  },
  clearValue: () => {
    var _a;
    return (_a = e.value) == null ? void 0 : _a.clearValue();
  },
  formatInputValue: () => {
    var _a;
    return (_a = e.value) == null ? void 0 : _a.formatInputValue();
  },
  updateInternalModelValue: (M) => {
    var _a;
    return (_a = e.value) == null ? void 0 : _a.updateInternalModelValue(M);
  },
  setMonthYear: (M, i) => {
    var _a;
    return (_a = e.value) == null ? void 0 : _a.setMonthYear(M, i);
  },
  parseModel: () => {
    var _a;
    return (_a = e.value) == null ? void 0 : _a.parseModel();
  },
  switchView: (M, i) => {
    var _a;
    return (_a = e.value) == null ? void 0 : _a.switchView(M, i);
  },
  handleFlow: () => {
    var _a;
    return (_a = e.value) == null ? void 0 : _a.handleFlow();
  },
  toggleMenu: () => {
    var _a;
    return (_a = e.value) == null ? void 0 : _a.toggleMenu();
  }
});
var Ot = () => ({
  boolHtmlAttribute: (w) => w ? true : void 0
});
var Br = () => {
  const {
    getDate: e,
    rootProps: w,
    defaults: { textInput: h2, startTime: r, timeConfig: o }
  } = Se(), { getTimeObjFromCurrent: s } = Fe(), a = ref(false), l = computed(
    () => Array.isArray(r.value) ? r.value[0] : r.value ?? s(e(), {}, o.value.enableSeconds)
  ), d = (M, i, _) => {
    const u = parse(M, i.slice(0, M.length), e(), { locale: w.locale });
    return isValid(u) && isDate(u) ? _ || a.value ? u : set(u, {
      hours: +l.value.hours,
      minutes: +l.value.minutes,
      seconds: +(l.value.seconds ?? 0),
      milliseconds: 0
    }) : null;
  };
  return {
    textPasted: a,
    parseFreeInput: (M, i) => {
      if (typeof h2.value.pattern == "string")
        return d(M, h2.value.pattern, i);
      if (Array.isArray(h2.value.pattern)) {
        let _ = null;
        for (const u of h2.value.pattern)
          if (_ = d(M, u, i), _)
            break;
        return _;
      }
      return typeof h2.value.pattern == "function" ? h2.value.pattern(M) : null;
    },
    applyMaxValues: (M, i) => {
      const _ = {
        MM: 12,
        DD: 31,
        hh: 23,
        mm: 59,
        ss: 59
      };
      let u = "", T = 0;
      for (let f = 0; f < i.length; f++) {
        const W = i[f], B = W.length, D = M.slice(T, T + B);
        if (!D) break;
        if (D.length < B)
          u += D;
        else {
          let F = Number.parseInt(D, 10);
          _[W] && F > _[W] && (F = _[W]), u += F.toString().padStart(B, "0").slice(0, B);
        }
        T += B;
      }
      return u;
    },
    createMaskedValue: (M, i) => {
      const _ = /(YYYY|MM|DD|hh|mm|ss)/g, u = [...i.matchAll(_)].map((D) => D[0]), T = i.replace(_, "|").split("|").filter(Boolean), f = u.map((D) => D.length);
      let W = "", B = 0;
      for (let D = 0; D < u.length; D++) {
        const F = f[D], Q = M.slice(B, B + F);
        if (!Q) break;
        W += Q, Q.length === F && T[D] && (W += T[D]), B += F;
      }
      return W;
    }
  };
};
var Ir = {
  key: 1,
  class: "dp__input_wrap"
};
var Vr = ["id", "name", "inputmode", "placeholder", "disabled", "readonly", "required", "value", "autocomplete", "aria-label", "aria-disabled", "aria-invalid"];
var Er = {
  key: 2,
  class: "dp--clear-btn"
};
var Fr = ["aria-label"];
var Nr = defineComponent({
  __name: "DatepickerInput",
  props: {
    isMenuOpen: { type: Boolean, default: false }
  },
  emits: ["clear", "open", "set-input-date", "close", "select-date", "set-empty-date", "toggle", "focus", "blur", "real-blur"],
  setup(e, { expose: w, emit: h2 }) {
    const r = h2, o = e, {
      rootEmit: s,
      inputValue: a,
      rootProps: l,
      defaults: { textInput: d, ariaLabels: x, inline: P, config: O, range: M, multiDates: i, ui: _, inputAttrs: u }
    } = Se(), { checkMinMaxRange: T, isValidDate: f } = nt(), { parseFreeInput: W, textPasted: B, createMaskedValue: D, applyMaxValues: F } = Br(), { checkKeyDown: Q, checkStopPropagation: I } = Fe(), { boolHtmlAttribute: y } = Ot(), m = useTemplateRef("dp-input"), k = ref(null), R = ref(false), z = computed(
      () => ({
        dp__pointer: !l.disabled && !l.readonly && !d.value.enabled,
        dp__disabled: l.disabled,
        dp__input_readonly: !d.value.enabled,
        dp__input: true,
        dp__input_not_clearable: !u.value.clearable,
        dp__input_icon_pad: !u.value.hideInputIcon,
        dp__input_valid: typeof u.value.state == "boolean" ? u.value.state : false,
        dp__input_invalid: typeof u.value.state == "boolean" ? !u.value.state : false,
        dp__input_focus: R.value || o.isMenuOpen,
        dp__input_reg: !d.value.enabled,
        ..._.value.input
      })
    ), Z = () => {
      r("set-input-date", null), u && l.autoApply && (r("set-empty-date"), k.value = null);
    }, te = ($) => {
      const { rangeSeparator: oe } = d.value, [ee, b] = $.split(`${oe}`);
      if (ee) {
        const X = W(ee.trim(), a.value), L = b ? W(b.trim(), a.value) : void 0;
        if (isAfter(X, L)) return;
        const ve = X && L ? [X, L] : [X];
        T(L, ve, 0) && (k.value = X ? ve : null);
      }
    }, de = () => {
      B.value = true;
    }, ge = ($) => {
      if (M.value.enabled)
        te($);
      else if (i.value.enabled) {
        const oe = $.split(";");
        k.value = oe.map((ee) => W(ee.trim())).filter((ee) => !!ee);
      } else
        k.value = W($, a.value);
    }, H = ($) => {
      var _a, _b;
      const oe = typeof $ == "string" ? $ : (_a = $.target) == null ? void 0 : _a.value, ee = (_b = d == null ? void 0 : d.value) == null ? void 0 : _b.maskFormat;
      let b = oe;
      if (typeof ee == "string") {
        const X = /(YYYY|MM|DD|hh|mm|ss)/g, ve = [...ee.matchAll(X)].map((S) => S[0]), c = oe.replace(/\D/g, ""), p = F(c, ve);
        b = D(p, ee);
      }
      b === "" ? Z() : (d.value.openMenu && !o.isMenuOpen && r("open"), ge(b), r("set-input-date", k.value)), B.value = false, a.value = b, s("text-input", $, k.value);
    }, se = ($) => {
      d.value.enabled ? (ge($.target.value), d.value.enterSubmit && f(k.value) && a.value !== "" ? (r("set-input-date", k.value, true), k.value = null) : d.value.enterSubmit && a.value === "" && (k.value = null, r("clear"))) : K($);
    }, E = ($, oe) => {
      d.value.enabled && d.value.tabSubmit && !oe && ge($.target.value), d.value.tabSubmit && f(k.value) && a.value !== "" ? (r("set-input-date", k.value, true, true), k.value = null) : d.value.tabSubmit && a.value === "" && (k.value = null, r("clear"));
    }, ae = () => {
      R.value = true, r("focus"), nextTick().then(() => {
        var _a;
        d.value.enabled && d.value.selectOnFocus && ((_a = m.value) == null ? void 0 : _a.select());
      });
    }, K = ($) => {
      if (I($, O.value, true), d.value.enabled && d.value.openMenu && !P.value.input) {
        if (d.value.openMenu === "open" && !o.isMenuOpen) return r("open");
        if (d.value.openMenu === "toggle") return r("toggle");
      } else d.value.enabled || r("toggle");
    }, ne = () => {
      r("real-blur"), R.value = false, (!o.isMenuOpen || P.value.enabled && P.value.input) && r("blur"), l.autoApply && d.value.enabled && k.value && !o.isMenuOpen && (r("set-input-date", k.value), r("select-date"), k.value = null);
    }, ie = ($) => {
      I($, O.value, true), r("clear");
    }, ye = () => {
      r("close");
    }, _e = ($) => {
      if ($.key === "Tab" && E($), $.key === "Enter" && se($), $.key === "Escape" && d.value.escClose && ye(), !d.value.enabled) {
        if ($.code === "Tab") return;
        $.preventDefault();
      }
    }, Ae = () => {
      var _a;
      (_a = m.value) == null ? void 0 : _a.focus({ preventScroll: true });
    }, le = ($) => {
      k.value = $;
    }, me = ($) => {
      $.key === xe.tab && E($, true);
    };
    return w({
      focusInput: Ae,
      setParsedDate: le
    }), ($, oe) => {
      var _a, _b;
      return openBlock(), createElementBlock("div", { onClick: K }, [
        $.$slots.trigger && !$.$slots["dp-input"] && !unref(P).enabled ? renderSlot($.$slots, "trigger", { key: 0 }) : createCommentVNode("", true),
        !$.$slots.trigger && (!unref(P).enabled || unref(P).input) ? (openBlock(), createElementBlock("div", Ir, [
          $.$slots["dp-input"] && !$.$slots.trigger && (!unref(P).enabled || unref(P).enabled && unref(P).input) ? renderSlot($.$slots, "dp-input", {
            key: 0,
            value: unref(a),
            isMenuOpen: e.isMenuOpen,
            onInput: H,
            onEnter: se,
            onTab: E,
            onClear: ie,
            onBlur: ne,
            onKeypress: _e,
            onPaste: de,
            onFocus: ae,
            openMenu: () => $.$emit("open"),
            closeMenu: () => $.$emit("close"),
            toggleMenu: () => $.$emit("toggle")
          }) : createCommentVNode("", true),
          $.$slots["dp-input"] ? createCommentVNode("", true) : (openBlock(), createElementBlock("input", {
            key: 1,
            id: unref(u).id,
            ref: "dp-input",
            "data-test-id": "dp-input",
            name: unref(u).name,
            class: normalizeClass(z.value),
            inputmode: unref(u).inputmode,
            placeholder: unref(l).placeholder,
            disabled: unref(y)(unref(l).disabled),
            readonly: unref(y)(unref(l).readonly),
            required: unref(y)(unref(u).required),
            value: unref(a),
            autocomplete: unref(u).autocomplete,
            "aria-label": unref(x).input,
            "aria-disabled": unref(l).disabled || void 0,
            "aria-invalid": unref(u).state === false ? true : void 0,
            onInput: H,
            onBlur: ne,
            onFocus: ae,
            onKeypress: _e,
            onKeydown: oe[0] || (oe[0] = (ee) => _e(ee)),
            onPaste: de,
            onInvalid: oe[1] || (oe[1] = (ee) => unref(s)("invalid", ee))
          }, null, 42, Vr)),
          createBaseVNode("div", {
            onClick: oe[4] || (oe[4] = (ee) => r("toggle"))
          }, [
            $.$slots["input-icon"] && !unref(u).hideInputIcon ? (openBlock(), createElementBlock("span", {
              key: 0,
              class: "dp__input_icon",
              onClick: oe[2] || (oe[2] = (ee) => r("toggle"))
            }, [
              renderSlot($.$slots, "input-icon")
            ])) : createCommentVNode("", true),
            !$.$slots["input-icon"] && !unref(u).hideInputIcon && !$.$slots["dp-input"] ? (openBlock(), createBlock(unref(Kt), {
              key: 1,
              "aria-label": (_a = unref(x)) == null ? void 0 : _a.calendarIcon,
              class: "dp__input_icon dp__input_icons",
              onClick: oe[3] || (oe[3] = (ee) => r("toggle"))
            }, null, 8, ["aria-label"])) : createCommentVNode("", true)
          ]),
          $.$slots["clear-icon"] && (unref(u).alwaysClearable || unref(a) && unref(u).clearable && !unref(l).disabled && !unref(l).readonly) ? (openBlock(), createElementBlock("span", Er, [
            renderSlot($.$slots, "clear-icon", { clear: ie })
          ])) : createCommentVNode("", true),
          !$.$slots["clear-icon"] && (unref(u).alwaysClearable || unref(u).clearable && unref(a) && !unref(l).disabled && !unref(l).readonly) ? (openBlock(), createElementBlock("button", {
            key: 3,
            "aria-label": (_b = unref(x)) == null ? void 0 : _b.clearInput,
            class: "dp--clear-btn",
            type: "button",
            "data-test-id": "clear-input-value-btn",
            onKeydown: oe[5] || (oe[5] = (ee) => unref(Q)(ee, () => ie(ee), true, me)),
            onClick: oe[6] || (oe[6] = withModifiers((ee) => ie(ee), ["prevent"]))
          }, [
            createVNode(unref(Fn), { class: "dp__input_icons" })
          ], 40, Fr)) : createCommentVNode("", true)
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});
var Wr = {
  ref: "action-row",
  class: "dp__action_row"
};
var Lr = ["title"];
var Hr = {
  ref: "action-buttons-container",
  class: "dp__action_buttons",
  "data-dp-element": "action-row"
};
var Kr = ["disabled"];
var jr = defineComponent({
  __name: "ActionRow",
  props: {
    menuMount: { type: Boolean, default: false },
    calendarWidth: { default: 0 }
  },
  emits: ["close-picker", "select-date", "select-now"],
  setup(e, { emit: w }) {
    const h2 = w, r = e, {
      rootEmit: o,
      rootProps: s,
      modelValue: a,
      defaults: { actionRow: l, multiCalendars: d, inline: x, range: P, multiDates: O, formats: M }
    } = Se(), { isTimeValid: i, isMonthValid: _ } = nt(), { buildMatrix: u } = yt(), { formatPreview: T } = kt(), { checkKeyDown: f, convertType: W } = Fe(), { boolHtmlAttribute: B } = Ot(), D = useTemplateRef("cancel-btn"), F = useTemplateRef("select-btn"), Q = useTemplateRef("action-buttons-container"), I = useTemplateRef("action-row"), y = ref(false), m = ref({});
    onMounted(() => {
      s.arrowNavigation && u([unrefElement(D), unrefElement(F)], "actionRow"), k(), globalThis.addEventListener("resize", k);
    }), onUnmounted(() => {
      globalThis.removeEventListener("resize", k);
    });
    const k = () => {
      y.value = false, setTimeout(() => {
        var _a, _b;
        const E = (_a = Q.value) == null ? void 0 : _a.getBoundingClientRect(), ae = (_b = I.value) == null ? void 0 : _b.getBoundingClientRect();
        E && ae && (m.value.maxWidth = `${ae.width - E.width - 20}px`), y.value = true;
      }, 0);
    }, R = computed(() => P.value.enabled && !P.value.partialRange && a.value ? a.value.length === 2 : true), z = computed(
      () => !i.value(a.value) || !_.value(a.value) || !R.value
    ), Z = () => {
      const E = M.value.preview;
      return s.timePicker || s.monthPicker, E(W(a.value));
    }, te = () => {
      const E = a.value;
      return d.value.count > 0 ? `${T(E[0])} - ${T(E[1])}` : [T(E[0]), T(E[1])];
    }, de = computed(() => !a.value || !r.menuMount ? "" : typeof M.value.preview == "string" ? Array.isArray(a.value) ? a.value.length === 2 && a.value[1] ? te() : O.value.enabled ? a.value.map((E) => `${T(E)}`) : s.modelAuto ? `${T(a.value[0])}` : `${T(a.value[0])} -` : T(a.value) : Z()), ge = () => O.value.enabled ? "; " : " - ", H = computed(
      () => Array.isArray(de.value) ? de.value.join(ge()) : de.value
    ), se = () => {
      i.value(a.value) && _.value(a.value) && R.value ? h2("select-date") : o("invalid-select");
    };
    return (E, ae) => (openBlock(), createElementBlock("div", Wr, [
      E.$slots["action-row"] ? renderSlot(E.$slots, "action-row", normalizeProps(mergeProps({ key: 0 }, {
        modelValue: unref(a),
        disabled: z.value,
        selectDate: () => E.$emit("select-date"),
        closePicker: () => E.$emit("close-picker")
      }))) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
        unref(l).showPreview ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "dp__selection_preview",
          title: H.value || void 0,
          style: normalizeStyle(m.value)
        }, [
          E.$slots["action-preview"] && y.value ? renderSlot(E.$slots, "action-preview", {
            key: 0,
            value: unref(a)
          }) : createCommentVNode("", true),
          !E.$slots["action-preview"] && y.value ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            createTextVNode(toDisplayString(H.value), 1)
          ], 64)) : createCommentVNode("", true)
        ], 12, Lr)) : createCommentVNode("", true),
        createBaseVNode("div", Hr, [
          E.$slots["action-buttons"] ? renderSlot(E.$slots, "action-buttons", {
            key: 0,
            value: unref(a)
          }) : createCommentVNode("", true),
          E.$slots["action-buttons"] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            !unref(x).enabled && unref(l).showCancel ? (openBlock(), createElementBlock("button", {
              key: 0,
              ref: "cancel-btn",
              type: "button",
              class: "dp__action_button dp__action_cancel",
              onClick: ae[0] || (ae[0] = (K) => E.$emit("close-picker")),
              onKeydown: ae[1] || (ae[1] = (K) => unref(f)(K, () => E.$emit("close-picker")))
            }, toDisplayString(unref(l).cancelBtnLabel), 545)) : createCommentVNode("", true),
            unref(l).showNow ? (openBlock(), createElementBlock("button", {
              key: 1,
              type: "button",
              class: "dp__action_button dp__action_cancel",
              onClick: ae[2] || (ae[2] = (K) => E.$emit("select-now")),
              onKeydown: ae[3] || (ae[3] = (K) => unref(f)(K, () => E.$emit("select-now")))
            }, toDisplayString(unref(l).nowBtnLabel), 33)) : createCommentVNode("", true),
            unref(l).showSelect ? (openBlock(), createElementBlock("button", {
              key: 2,
              ref: "select-btn",
              type: "button",
              class: "dp__action_button dp__action_select",
              disabled: unref(B)(z.value),
              "data-test-id": "select-button",
              onKeydown: ae[4] || (ae[4] = (K) => unref(f)(K, () => se())),
              onClick: se
            }, toDisplayString(unref(l).selectBtnLabel), 41, Kr)) : createCommentVNode("", true)
          ], 64))
        ], 512)
      ], 64))
    ], 512));
  }
});
var la = () => {
  const {
    rootProps: e,
    defaults: { multiCalendars: w }
  } = Se(), h2 = computed(() => (s) => {
    var _a;
    return (_a = e.hideNavigation) == null ? void 0 : _a.includes(s);
  }), r = computed(() => (s) => w.value.count ? w.value.solo ? true : s === 0 : true), o = computed(() => (s) => w.value.count ? w.value.solo ? true : s === w.value.count - 1 : true);
  return { hideNavigationButtons: h2, showLeftIcon: r, showRightIcon: o };
};
var zr = ["role", "aria-label", "tabindex"];
var Ur = { class: "dp__selection_grid_header" };
var qr = ["aria-selected", "aria-disabled", "data-test-id", "onClick", "onKeydown", "onMouseover"];
var Qr = ["aria-label"];
var Ut = defineComponent({
  __name: "SelectionOverlay",
  props: {
    items: {},
    type: {},
    isLast: { type: Boolean },
    skipButtonRef: { type: Boolean },
    headerRefs: {},
    useRelative: { type: Boolean },
    height: {},
    noOverlayFocus: { type: Boolean },
    focusValue: {},
    menuWrapRef: {},
    overlayLabel: {}
  },
  emits: ["selected", "toggle", "reset-flow", "hover-value"],
  setup(e, { expose: w, emit: h2 }) {
    const { setSelectionGrid: r, buildMultiLevelMatrix: o, setMonthPicker: s } = yt(), a = h2, l = e, {
      rootProps: d,
      defaults: { ariaLabels: x, textInput: P, config: O }
    } = Se(), { hideNavigationButtons: M } = la(), { handleEventPropagation: i, convertType: _, checkKeyDown: u, checkStopPropagation: T, getElWithin: f, findFocusableEl: W } = Fe(), B = useTemplateRef("toggle-button"), D = useTemplateRef("overlay-container"), F = useTemplateRef("grid-wrap"), Q = ref(false), I = ref(null), y = ref([]), m = ref(), k = ref(0);
    onBeforeUpdate(() => {
      I.value = null;
    }), onMounted(() => {
      nextTick().then(() => se()), l.noOverlayFocus || z(), R(true);
    }), onUnmounted(() => R(false));
    const R = ($) => {
      var _a;
      d.arrowNavigation && (((_a = l.headerRefs) == null ? void 0 : _a.length) ? s($) : r($));
    }, z = () => {
      var _a;
      const $ = unrefElement(F);
      $ && (P.value.enabled || (I.value ? (_a = I.value) == null ? void 0 : _a.focus({ preventScroll: true }) : $.focus({ preventScroll: true })), Q.value = $.clientHeight < $.scrollHeight);
    }, Z = computed(
      () => ({
        dp__overlay: true,
        "dp--overlay-absolute": !l.useRelative,
        "dp--overlay-relative": l.useRelative
      })
    ), te = computed(
      () => l.useRelative ? { height: `${l.height}px`, width: "var(--dp-menu-min-width)" } : void 0
    ), de = computed(() => ({
      dp__overlay_col: true
    })), ge = computed(
      () => ({
        dp__btn: true,
        dp__button: true,
        dp__overlay_action: true,
        dp__over_action_scroll: Q.value,
        dp__button_bottom: l.isLast
      })
    ), H = computed(() => {
      var _a, _b;
      return {
        dp__overlay_container: true,
        dp__container_flex: ((_a = l.items) == null ? void 0 : _a.length) <= 6,
        dp__container_block: ((_b = l.items) == null ? void 0 : _b.length) > 6
      };
    });
    watch(
      () => l.items,
      () => se(false),
      { deep: true }
    );
    const se = ($ = true) => {
      nextTick().then(() => {
        const oe = unrefElement(I), ee = unrefElement(F), b = unrefElement(B), X = unrefElement(D), L = b ? b.getBoundingClientRect().height : 0;
        ee && (ee.getBoundingClientRect().height ? k.value = ee.getBoundingClientRect().height - L : k.value = O.value.modeHeight - L), oe && X && $ && (X.scrollTop = oe.offsetTop - X.offsetTop - (k.value / 2 - oe.getBoundingClientRect().height) - L);
      });
    }, E = ($) => {
      $.disabled || a("selected", $.value);
    }, ae = () => {
      a("toggle"), a("reset-flow");
    }, K = ($) => {
      O.value.escClose && (ae(), i($, O.value));
    }, ne = ($, oe, ee, b) => {
      $ && ((oe.active || oe.value === l.focusValue) && (I.value = $), d.arrowNavigation && (Array.isArray(y.value[ee]) ? y.value[ee][b] = $ : y.value[ee] = [$], ie()));
    }, ie = () => {
      var _a, _b;
      const $ = ((_a = l.headerRefs) == null ? void 0 : _a.length) ? [l.headerRefs].concat(y.value) : y.value.concat([l.skipButtonRef ? [] : [B.value]]);
      o(_($), ((_b = l.headerRefs) == null ? void 0 : _b.length) ? "monthPicker" : "selectionGrid");
    }, ye = ($) => {
      d.arrowNavigation || T($, O.value, true);
    }, _e = ($) => {
      m.value = $, a("hover-value", $);
    }, Ae = () => {
      var _a;
      if (ae(), !l.isLast) {
        const $ = f(l.menuWrapRef ?? null, "action-row");
        $ && ((_a = W($)) == null ? void 0 : _a.focus());
      }
    }, le = ($) => {
      switch ($.key) {
        case xe.esc:
          return K($);
        case xe.arrowLeft:
          return ye($);
        case xe.arrowRight:
          return ye($);
        case xe.arrowUp:
          return ye($);
        case xe.arrowDown:
          return ye($);
        default:
          return;
      }
    }, me = ($) => {
      if ($.key === xe.enter) return ae();
      if ($.key === xe.tab) return Ae();
    };
    return w({ focusGrid: z }), ($, oe) => {
      var _a;
      return openBlock(), createElementBlock("div", {
        ref: "grid-wrap",
        class: normalizeClass(Z.value),
        style: normalizeStyle(te.value),
        role: e.useRelative ? void 0 : "dialog",
        "aria-label": e.overlayLabel,
        tabindex: e.useRelative ? void 0 : "0",
        onKeydown: le,
        onClick: oe[0] || (oe[0] = withModifiers(() => {
        }, ["prevent"]))
      }, [
        createBaseVNode("div", {
          ref: "overlay-container",
          class: normalizeClass(H.value),
          style: normalizeStyle({ "--dp-overlay-height": `${k.value}px` }),
          role: "grid"
        }, [
          createBaseVNode("div", Ur, [
            renderSlot($.$slots, "header")
          ]),
          $.$slots.overlay ? renderSlot($.$slots, "overlay", { key: 0 }) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(e.items, (ee, b) => (openBlock(), createElementBlock("div", {
            key: b,
            class: normalizeClass(["dp__overlay_row", { dp__flex_row: e.items.length >= 3 }]),
            role: "row"
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(ee, (X, L) => (openBlock(), createElementBlock("div", {
              key: X.value,
              ref_for: true,
              ref: (ve) => ne(ve, X, b, L),
              role: "gridcell",
              class: normalizeClass(de.value),
              "aria-selected": X.active || void 0,
              "aria-disabled": X.disabled || void 0,
              tabindex: "0",
              "data-test-id": X.text,
              onClick: withModifiers((ve) => E(X), ["prevent"]),
              onKeydown: (ve) => unref(u)(ve, () => E(X), true),
              onMouseover: (ve) => _e(X.value)
            }, [
              createBaseVNode("div", {
                class: normalizeClass(X.className)
              }, [
                $.$slots.item ? renderSlot($.$slots, "item", {
                  key: 0,
                  item: X
                }) : createCommentVNode("", true),
                $.$slots.item ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                  createTextVNode(toDisplayString(X.text), 1)
                ], 64))
              ], 2)
            ], 42, qr))), 128))
          ], 2))), 128))
        ], 6),
        $.$slots["button-icon"] ? withDirectives((openBlock(), createElementBlock("button", {
          key: 0,
          ref: "toggle-button",
          type: "button",
          "aria-label": (_a = unref(x)) == null ? void 0 : _a.toggleOverlay,
          class: normalizeClass(ge.value),
          tabindex: "0",
          onClick: ae,
          onKeydown: me
        }, [
          renderSlot($.$slots, "button-icon")
        ], 42, Qr)), [
          [vShow, !unref(M)(e.type)]
        ]) : createCommentVNode("", true)
      ], 46, zr);
    };
  }
});
var Gr = ["data-dp-mobile"];
var oa = defineComponent({
  __name: "InstanceWrap",
  props: {
    stretch: { type: Boolean },
    collapse: { type: Boolean }
  },
  setup(e) {
    const {
      defaults: { multiCalendars: w }
    } = Se(), { isMobile: h2 } = na(), r = computed(
      () => w.value.count > 0 ? [...new Array(w.value.count).keys()] : [0]
    );
    return (o, s) => (openBlock(), createElementBlock("div", {
      class: normalizeClass({
        dp__menu_inner: !e.stretch,
        "dp--menu--inner-stretched": e.stretch,
        dp__flex_display: unref(w).count > 0,
        "dp--flex-display-collapsed": e.collapse
      }),
      "data-dp-mobile": unref(h2)
    }, [
      renderSlot(o.$slots, "default", {
        instances: r.value,
        wrapClass: { dp__instance_calendar: unref(w).count > 0 }
      })
    ], 10, Gr));
  }
});
var Jr = ["data-dp-element", "aria-label", "aria-disabled"];
var Nt = defineComponent({
  __name: "ArrowBtn",
  props: {
    ariaLabel: {},
    elName: {},
    disabled: { type: Boolean }
  },
  emits: ["activate", "set-ref"],
  setup(e, { emit: w }) {
    const { checkKeyDown: h2 } = Fe(), r = w, o = useTemplateRef("arrow-btn");
    return onMounted(() => r("set-ref", o)), (s, a) => (openBlock(), createElementBlock("button", {
      ref: "arrow-btn",
      type: "button",
      "data-dp-element": e.elName,
      class: "dp__btn dp--arrow-btn-nav",
      tabindex: "0",
      "aria-label": e.ariaLabel,
      "aria-disabled": e.disabled || void 0,
      onClick: a[0] || (a[0] = (l) => r("activate")),
      onKeydown: a[1] || (a[1] = (l) => unref(h2)(l, () => r("activate"), true))
    }, [
      createBaseVNode("span", {
        class: normalizeClass(["dp__inner_nav", { dp__inner_nav_disabled: e.disabled }])
      }, [
        renderSlot(s.$slots, "default")
      ], 2)
    ], 40, Jr));
  }
});
var Xr = ["aria-label", "data-test-id"];
var qa = defineComponent({
  __name: "YearModePicker",
  props: {
    items: {},
    instance: {},
    year: {},
    showYearPicker: { type: Boolean, default: false },
    isDisabled: {}
  },
  emits: ["handle-year", "year-select", "toggle-year-picker"],
  setup(e, { emit: w }) {
    const h2 = w, r = e, { showRightIcon: o, showLeftIcon: s } = la(), {
      rootProps: a,
      defaults: { config: l, ariaLabels: d, ui: x }
    } = Se(), { showTransition: P, transitionName: O } = jt(), { formatYear: M } = kt(), { boolHtmlAttribute: i } = Ot(), _ = ref(false), u = computed(() => M(r.year)), T = (B = false, D) => {
      _.value = !_.value, h2("toggle-year-picker", { flow: B, show: D });
    }, f = (B) => {
      _.value = false, h2("year-select", B);
    }, W = (B = false) => {
      h2("handle-year", B);
    };
    return (B, D) => {
      var _a, _b, _c, _d, _e;
      return openBlock(), createElementBlock(Fragment, null, [
        createBaseVNode("div", {
          class: normalizeClass(["dp--year-mode-picker", { "dp--hidden-el": _.value }])
        }, [
          unref(s)(e.instance) ? (openBlock(), createBlock(Nt, {
            key: 0,
            ref: "mpPrevIconRef",
            "aria-label": (_a = unref(d)) == null ? void 0 : _a.prevYear,
            disabled: unref(i)(e.isDisabled(false)),
            class: normalizeClass((_b = unref(x)) == null ? void 0 : _b.navBtnPrev),
            onActivate: D[0] || (D[0] = (F) => W(false))
          }, {
            default: withCtx(() => [
              B.$slots["arrow-left"] ? renderSlot(B.$slots, "arrow-left", { key: 0 }) : createCommentVNode("", true),
              B.$slots["arrow-left"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(La), { key: 1 }))
            ]),
            _: 3
          }, 8, ["aria-label", "disabled", "class"])) : createCommentVNode("", true),
          createBaseVNode("button", {
            ref: "mpYearButtonRef",
            class: "dp__btn dp--year-select",
            type: "button",
            "aria-label": `${e.year}-${(_c = unref(d)) == null ? void 0 : _c.openYearsOverlay}`,
            "data-test-id": `year-mode-btn-${e.instance}`,
            onClick: D[1] || (D[1] = () => T(false)),
            onKeydown: D[2] || (D[2] = withKeys(() => T(false), ["enter"]))
          }, [
            B.$slots.year ? renderSlot(B.$slots, "year", {
              key: 0,
              text: u.value,
              value: e.year
            }) : createCommentVNode("", true),
            B.$slots.year ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createTextVNode(toDisplayString(e.year), 1)
            ], 64))
          ], 40, Xr),
          unref(o)(e.instance) ? (openBlock(), createBlock(Nt, {
            key: 1,
            ref: "mpNextIconRef",
            "aria-label": (_d = unref(d)) == null ? void 0 : _d.nextYear,
            disabled: unref(i)(e.isDisabled(true)),
            class: normalizeClass((_e = unref(x)) == null ? void 0 : _e.navBtnNext),
            onActivate: D[3] || (D[3] = (F) => W(true))
          }, {
            default: withCtx(() => [
              B.$slots["arrow-right"] ? renderSlot(B.$slots, "arrow-right", { key: 0 }) : createCommentVNode("", true),
              B.$slots["arrow-right"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Ha), { key: 1 }))
            ]),
            _: 3
          }, 8, ["aria-label", "disabled", "class"])) : createCommentVNode("", true)
        ], 2),
        createVNode(Transition, {
          name: unref(O)(e.showYearPicker),
          css: unref(P)
        }, {
          default: withCtx(() => {
            var _a2, _b2;
            return [
              e.showYearPicker ? (openBlock(), createBlock(Ut, {
                key: 0,
                items: e.items,
                config: unref(l),
                "is-last": unref(a).autoApply && !unref(l).keepActionRow,
                "overlay-label": (_b2 = (_a2 = unref(d)) == null ? void 0 : _a2.yearPicker) == null ? void 0 : _b2.call(_a2, true),
                type: "year",
                onToggle: T,
                onSelected: D[4] || (D[4] = (F) => f(F))
              }, createSlots({
                "button-icon": withCtx(() => [
                  B.$slots["calendar-icon"] ? renderSlot(B.$slots, "calendar-icon", { key: 0 }) : createCommentVNode("", true),
                  B.$slots["calendar-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Kt), { key: 1 }))
                ]),
                _: 2
              }, [
                B.$slots["year-overlay-value"] ? {
                  name: "item",
                  fn: withCtx(({ item: F }) => [
                    renderSlot(B.$slots, "year-overlay-value", {
                      text: F.text,
                      value: F.value
                    })
                  ]),
                  key: "0"
                } : void 0
              ]), 1032, ["items", "config", "is-last", "overlay-label"])) : createCommentVNode("", true)
            ];
          }),
          _: 3
        }, 8, ["name", "css"])
      ], 64);
    };
  }
});
var Qa = (e) => {
  const {
    getDate: w,
    rootEmit: h2,
    state: r,
    month: o,
    year: s,
    modelValue: a,
    calendars: l,
    rootProps: d,
    defaults: { multiCalendars: x, range: P, safeDates: O, filters: M, highlight: i }
  } = Se(), { resetDate: _, getYearFromDate: u, checkHighlightYear: T, groupListAndMap: f } = ze(), { getYears: W } = ra(), { validateMonthYear: B, checkMinMaxValue: D } = nt(), F = ref([false]), Q = computed(() => W()), I = computed(() => (K, ne) => {
    const ie = set(_(w()), {
      month: o.value(K),
      year: s.value(K)
    }), ye = ne ? endOfYear(ie) : startOfYear(ie);
    return B(ye, d.preventMinMaxNavigation, ne);
  }), y = () => Array.isArray(a.value) && x.value.solo && a.value[1], m = () => {
    for (let K = 0; K < x.value.count; K++)
      if (K === 0)
        l.value[K] = l.value[0];
      else if (K === x.value.count - 1 && y())
        l.value[K] = {
          month: getMonth(a.value[1]),
          year: getYear(a.value[1])
        };
      else {
        const ne = set(w(), l.value[K - 1]);
        l.value[K] = { month: getMonth(ne), year: getYear(addYears(ne, 1)) };
      }
  }, k = (K) => {
    if (!K) return m();
    const ne = set(w(), l.value[K]);
    return l.value[0].year = getYear(subYears(ne, x.value.count - 1)), m();
  }, R = (K, ne) => {
    const ie = differenceInYears(ne, K);
    return P.value.showLastInRange && ie > 1 ? ne : K;
  }, z = (K) => d.focusStartDate || x.value.solo ? K[0] : K[1] ? R(K[0], K[1]) : K[0], Z = () => {
    if (a.value) {
      const K = Array.isArray(a.value) ? z(a.value) : a.value;
      l.value[0] = { month: getMonth(K), year: getYear(K) };
    }
  }, te = () => {
    Z(), x.value.count && m();
  };
  watch(a, (K, ne) => {
    r.isTextInputDate && JSON.stringify(K ?? {}) !== JSON.stringify(ne ?? {}) && te();
  }), onMounted(() => {
    te();
  });
  const de = (K, ne) => {
    l.value[ne].year = K, h2("update-month-year", { instance: ne, year: K, month: l.value[ne].month }), x.value.count && !x.value.solo && k(ne);
  }, ge = computed(() => (K) => f(Q.value, (ne) => {
    var _a;
    const ie = s.value(K) === ne.value, ye = D(
      ne.value,
      u(O.value.minDate),
      u(O.value.maxDate)
    ) || ((_a = M.value.years) == null ? void 0 : _a.includes(s.value(K))), _e = T(i.value, ne.value);
    return { active: ie, disabled: ye, highlighted: _e };
  })), H = (K, ne) => {
    de(K, ne), E(ne);
  }, se = (K, ne = false) => {
    if (!I.value(K, ne)) {
      const ie = ne ? s.value(K) + 1 : s.value(K) - 1;
      de(ie, K);
    }
  }, E = (K, ne = false, ie) => {
    ne || e("reset-flow"), ie === void 0 ? F.value[K] = !F.value[K] : F.value[K] = ie, F.value[K] ? h2("overlay-toggle", { open: true, overlay: Qe.year }) : h2("overlay-toggle", { open: false, overlay: Qe.year });
  };
  return {
    isDisabled: I,
    groupedYears: ge,
    showYearPicker: F,
    selectYear: de,
    setStartDate: () => {
      d.startDate && (a.value && d.focusStartDate || !a.value) && de(getYear(w(d.startDate)), 0);
    },
    toggleYearPicker: E,
    handleYearSelect: H,
    handleYear: se
  };
};
var sa = () => {
  const { isDateAfter: e, isDateBefore: w, isDateEqual: h2 } = ze(), {
    getDate: r,
    rootEmit: o,
    rootProps: s,
    modelValue: a,
    defaults: { range: l }
  } = Se();
  return {
    getRangeWithFixedDate: (i) => Array.isArray(a.value) && (a.value.length === 2 || a.value.length === 1 && l.value.partialRange) ? l.value.fixedStart && (e(i, a.value[0]) || h2(i, a.value[0])) ? [a.value[0], i] : l.value.fixedEnd && (w(i, a.value[1]) || h2(i, a.value[1])) ? [i, a.value[1]] : (o("invalid-fixed-range", i), a.value) : [],
    setPresetDate: (i) => {
      Array.isArray(i.value) && i.value.length <= 2 && l.value.enabled ? a.value = i.value.map((_) => r(_)) : Array.isArray(i.value) || (a.value = r(i.value));
    },
    checkRangeAutoApply: (i, _, u) => {
      l && (i[0] && i[1] && s.autoApply && _("auto-apply", u), i[0] && !i[1] && (s.modelAuto || l.value.partialRange) && s.autoApply && _("auto-apply", u));
    },
    setMonthOrYearRange: (i) => {
      let _ = a.value ? a.value.slice() : [];
      return _.length === 2 && _[1] !== null && (_ = []), _.length ? (w(i, _[0]) ? _.unshift(i) : _[1] = i, o("range-end", i)) : (_ = [i], o("range-start", i)), _;
    },
    handleMultiDatesSelect: (i, _) => {
      if (a.value && Array.isArray(a.value))
        if (a.value.some((u) => h2(i, u))) {
          const u = a.value.filter((T) => !h2(T, i));
          a.value = u.length ? u : null;
        } else (_ && +_ > a.value.length || !_) && a.value.push(i);
      else
        a.value = [i];
    }
  };
};
var Zr = (e, w) => {
  const {
    getDate: h2,
    rootEmit: r,
    state: o,
    calendars: s,
    year: a,
    modelValue: l,
    rootProps: d,
    defaults: { range: x, highlight: P, safeDates: O, filters: M, multiDates: i }
  } = Se();
  zt(() => {
    o.isTextInputDate && H(getYear(h2(d.startDate)), 0);
  });
  const { checkMinMaxRange: _, checkMinMaxValue: u } = nt(), { isDateBetween: T, resetDateTime: f, resetDate: W, getMinMonth: B, getMaxMonth: D, checkHighlightMonth: F, groupListAndMap: Q } = ze(), { checkRangeAutoApply: I, getRangeWithFixedDate: y, handleMultiDatesSelect: m, setMonthOrYearRange: k, setPresetDate: R } = sa(), { padZero: z } = Fe(), { getMonths: Z, isOutOfYearRange: te } = ra(), de = computed(() => Z()), ge = ref(null), {
    selectYear: H,
    groupedYears: se,
    showYearPicker: E,
    toggleYearPicker: ae,
    handleYearSelect: K,
    handleYear: ne,
    isDisabled: ie,
    setStartDate: ye
  } = Qa(w);
  onMounted(() => {
    ye();
  });
  const _e = (v) => v ? { month: getMonth(v), year: getYear(v) } : { month: null, year: null }, Ae = () => l.value ? Array.isArray(l.value) ? l.value.map((v) => _e(v)) : _e(l.value) : _e(), le = (v, n) => {
    const V = s.value[v], N = Ae();
    return Array.isArray(N) ? N.some((ue) => ue.year === (V == null ? void 0 : V.year) && ue.month === n) : (V == null ? void 0 : V.year) === N.year && n === N.month;
  }, me = (v, n, V) => {
    var _a, _b;
    const N = Ae();
    return Array.isArray(N) ? a.value(n) === ((_a = N[V]) == null ? void 0 : _a.year) && v === ((_b = N[V]) == null ? void 0 : _b.month) : false;
  }, $ = (v, n) => {
    if (x.value.enabled) {
      const V = Ae();
      if (Array.isArray(l.value) && Array.isArray(V)) {
        const N = me(v, n, 0) || me(v, n, 1), ue = set(W(h2()), { month: v, year: a.value(n) });
        return T(l.value, ge.value, ue) && !N;
      }
      return false;
    }
    return false;
  }, oe = computed(() => (v) => Q(de.value, (n) => {
    var _a;
    const V = le(v, n.value), N = u(
      n.value,
      B(a.value(v), O.value.minDate),
      D(a.value(v), O.value.maxDate)
    ) || Y(O.value.disabledDates, a.value(v), n.value) || ((_a = M.value.months) == null ? void 0 : _a.includes(n.value)) || !G(O.value.allowedDates, a.value(v), n.value) || te(a.value(v)), ue = $(n.value, v), he = F(P.value, n.value, a.value(v));
    return { active: V, disabled: N, isBetween: ue, highlighted: he };
  })), ee = (v, n) => set(W(h2()), { month: v, year: a.value(n) }), b = (v, n) => {
    const V = l.value ? l.value : W(h2());
    l.value = set(V, { month: v, year: a.value(n) }), w("auto-apply"), w("update-flow-step");
  }, X = (v, n) => {
    const V = ee(v, n);
    x.value.fixedEnd || x.value.fixedStart ? l.value = y(V) : l.value ? _(V, l.value) && (l.value = k(ee(v, n))) : l.value = [ee(v, n)], nextTick().then(() => {
      I(l.value, w, l.value.length < 2);
    });
  }, L = (v, n) => {
    m(ee(v, n), i.value.limit), w("auto-apply", true);
  }, ve = (v, n) => (s.value[n].month = v, p(n, s.value[n].year, v), i.value.enabled ? L(v, n) : x.value.enabled ? X(v, n) : b(v, n)), c = (v, n) => {
    H(v, n), p(n, v, null);
  }, p = (v, n, V) => {
    let N = V;
    if (!N && N !== 0) {
      const ue = Ae();
      N = Array.isArray(ue) ? ue[v].month : ue.month;
    }
    r("update-month-year", { instance: v, year: n, month: N });
  }, S = (v, n) => {
    ge.value = ee(v, n);
  }, g = (v) => {
    R({
      value: v
    }), w("auto-apply");
  }, Y = (v, n, V) => {
    if (v instanceof Map) {
      const N = `${z(V + 1)}-${n}`;
      return v.size ? v.has(N) : false;
    }
    return typeof v == "function" ? v(f(set(h2(), { month: V, year: n }), true)) : false;
  }, G = (v, n, V) => {
    if (v instanceof Map) {
      const N = `${z(V + 1)}-${n}`;
      return v.size ? v.has(N) : true;
    }
    return true;
  };
  return {
    groupedMonths: oe,
    groupedYears: se,
    year: a,
    isDisabled: ie,
    showYearPicker: E,
    modelValue: l,
    toggleYearPicker: ae,
    handleYearSelect: K,
    handleYear: ne,
    presetDate: g,
    setHoverDate: S,
    selectMonth: ve,
    selectYear: c,
    getModelMonthYear: Ae
  };
};
var el = defineComponent({
  __name: "MonthPicker",
  props: {
    flowStep: {},
    collapse: { type: Boolean },
    menuWrapRef: {},
    noOverlayFocus: { type: Boolean }
  },
  emits: ["reset-flow", "auto-apply", "update-flow-step", "mount"],
  setup(e, { expose: w, emit: h2 }) {
    const r = h2, o = e, s = useSlots(), { mapSlots: a } = bt(), {
      rootProps: l,
      defaults: { config: d }
    } = Se(), x = a(s, "yearMode");
    onMounted(() => {
      r("mount");
    });
    const {
      groupedMonths: P,
      groupedYears: O,
      year: M,
      isDisabled: i,
      showYearPicker: _,
      modelValue: u,
      presetDate: T,
      setHoverDate: f,
      selectMonth: W,
      selectYear: B,
      toggleYearPicker: D,
      handleYearSelect: F,
      handleYear: Q,
      getModelMonthYear: I
    } = Zr(o, r);
    return w({ getSidebarProps: () => ({
      modelValue: u,
      year: M,
      getModelMonthYear: I,
      selectMonth: W,
      selectYear: B,
      handleYear: Q
    }), presetDate: T, toggleYearPicker: (m) => D(0, m) }), (m, k) => (openBlock(), createBlock(oa, {
      collapse: e.collapse,
      stretch: ""
    }, {
      default: withCtx(({ instances: R, wrapClass: z }) => [
        (openBlock(true), createElementBlock(Fragment, null, renderList(R, (Z) => (openBlock(), createElementBlock("div", {
          key: Z,
          class: normalizeClass(z)
        }, [
          m.$slots["top-extra"] ? renderSlot(m.$slots, "top-extra", {
            key: 0,
            value: unref(u)
          }) : createCommentVNode("", true),
          m.$slots["month-year"] ? renderSlot(m.$slots, "month-year", mergeProps({
            key: 1,
            ref_for: true
          }, {
            year: unref(M),
            months: unref(P)(Z),
            years: unref(O)(Z),
            selectMonth: unref(W),
            selectYear: unref(B),
            instance: Z
          })) : (openBlock(), createBlock(Ut, {
            key: 2,
            items: unref(P)(Z),
            "is-last": unref(l).autoApply && !unref(d).keepActionRow,
            height: unref(d).modeHeight,
            "no-overlay-focus": !!(e.noOverlayFocus || unref(l).textInput),
            "use-relative": "",
            type: "month",
            onSelected: (te) => unref(W)(te, Z),
            onHoverValue: (te) => unref(f)(te, Z)
          }, createSlots({
            header: withCtx(() => [
              createVNode(qa, {
                items: unref(O)(Z),
                instance: Z,
                "show-year-picker": unref(_)[Z],
                year: unref(M)(Z),
                "is-disabled": (te) => unref(i)(Z, te),
                onHandleYear: (te) => unref(Q)(Z, te),
                onYearSelect: (te) => unref(F)(te, Z),
                onToggleYearPicker: (te) => unref(D)(Z, te == null ? void 0 : te.flow, te == null ? void 0 : te.show)
              }, createSlots({ _: 2 }, [
                renderList(unref(x), (te, de) => ({
                  name: te,
                  fn: withCtx((ge) => [
                    renderSlot(m.$slots, te, mergeProps({ ref_for: true }, ge))
                  ])
                }))
              ]), 1032, ["items", "instance", "show-year-picker", "year", "is-disabled", "onHandleYear", "onYearSelect", "onToggleYearPicker"])
            ]),
            _: 2
          }, [
            m.$slots["month-overlay-value"] ? {
              name: "item",
              fn: withCtx(({ item: te }) => [
                renderSlot(m.$slots, "month-overlay-value", {
                  text: te.text,
                  value: te.value
                })
              ]),
              key: "0"
            } : void 0
          ]), 1032, ["items", "is-last", "height", "no-overlay-focus", "onSelected", "onHoverValue"]))
        ], 2))), 128))
      ]),
      _: 3
    }, 8, ["collapse"]));
  }
});
var tl = (e, w) => {
  const {
    rootEmit: h2,
    getDate: r,
    state: o,
    modelValue: s,
    rootProps: a,
    defaults: { highlight: l, multiDates: d, filters: x, range: P, safeDates: O }
  } = Se(), { getYears: M } = ra(), { isDateBetween: i, resetDate: _, resetDateTime: u, getYearFromDate: T, checkHighlightYear: f, groupListAndMap: W } = ze(), { checkRangeAutoApply: B, setMonthOrYearRange: D } = sa(), { checkMinMaxValue: F, checkMinMaxRange: Q } = nt();
  zt(() => {
    o.isTextInputDate && (y.value = getYear(r(a.startDate)));
  });
  const I = ref(null), y = ref();
  onMounted(() => {
    a.startDate && (s.value && a.focusStartDate || !s.value) && (y.value = getYear(r(a.startDate)));
  });
  const m = (H) => Array.isArray(s.value) ? s.value.some((se) => getYear(se) === H) : s.value ? getYear(s.value) === H : false, k = (H) => P.value.enabled && Array.isArray(s.value) ? i(s.value, I.value, te(H)) : false, R = (H) => {
    var _a;
    return ((_a = O.value.allowedDates) == null ? void 0 : _a.size) ? O.value.allowedDates.has(`${H}`) : true;
  }, z = (H) => O.value.disabledDates instanceof Map ? O.value.disabledDates.size ? O.value.disabledDates.has(`${H}`) : false : typeof O.value.disabledDates == "function" ? O.value.disabledDates(setYear(u(startOfYear(r())), H)) : true, Z = computed(() => W(M(), (H) => {
    const se = m(H.value), E = F(
      H.value,
      T(O.value.minDate),
      T(O.value.maxDate)
    ) || x.value.years.includes(H.value) || !R(H.value) || z(H.value), ae = k(H.value) && !se, K = f(l.value, H.value);
    return { active: se, disabled: E, isBetween: ae, highlighted: K };
  })), te = (H) => setYear(_(startOfYear(r())), H);
  return {
    groupedYears: Z,
    focusYear: y,
    setHoverValue: (H) => {
      I.value = setYear(_(r()), H);
    },
    selectYear: (H) => {
      var _a;
      if (h2("update-month-year", { instance: 0, year: H, month: Number.NaN }), d.value.enabled)
        return s.value ? Array.isArray(s.value) && (((_a = s.value) == null ? void 0 : _a.map((E) => getYear(E))).includes(H) ? s.value = s.value.filter((E) => getYear(E) !== H) : s.value.push(setYear(u(r()), H))) : s.value = [setYear(u(startOfYear(r())), H)], w("auto-apply", true);
      P.value.enabled ? Q(te(H), s.value) && (s.value = D(te(H)), nextTick().then(() => {
        B(s.value, w, s.value.length < 2);
      })) : (s.value = te(H), w("auto-apply"));
    }
  };
};
var al = defineComponent({
  __name: "YearPicker",
  props: {
    flowStep: {},
    collapse: { type: Boolean },
    menuWrapRef: {},
    noOverlayFocus: { type: Boolean }
  },
  emits: ["reset-flow", "auto-apply"],
  setup(e, { expose: w, emit: h2 }) {
    const r = h2, o = e, {
      modelValue: s,
      defaults: { config: a },
      rootProps: l
    } = Se(), { groupedYears: d, focusYear: x, selectYear: P, setHoverValue: O } = tl(o, r);
    return w({ getSidebarProps: () => ({
      modelValue: s,
      selectYear: P
    }) }), (i, _) => (openBlock(), createElementBlock("div", null, [
      i.$slots["top-extra"] ? renderSlot(i.$slots, "top-extra", {
        key: 0,
        value: unref(s)
      }) : createCommentVNode("", true),
      i.$slots["month-year"] ? renderSlot(i.$slots, "month-year", normalizeProps(mergeProps({ key: 1 }, {
        years: unref(d),
        selectYear: unref(P)
      }))) : (openBlock(), createBlock(Ut, {
        key: 2,
        items: unref(d),
        "is-last": unref(l).autoApply && !unref(a).keepActionRow,
        height: unref(a).modeHeight,
        "no-overlay-focus": !!(e.noOverlayFocus || unref(l).textInput),
        "focus-value": unref(x),
        type: "year",
        "use-relative": "",
        onSelected: unref(P),
        onHoverValue: unref(O)
      }, createSlots({ _: 2 }, [
        i.$slots["year-overlay-value"] ? {
          name: "item",
          fn: withCtx(({ item: u }) => [
            renderSlot(i.$slots, "year-overlay-value", {
              text: u.text,
              value: u.value
            })
          ]),
          key: "0"
        } : void 0
      ]), 1032, ["items", "is-last", "height", "no-overlay-focus", "focus-value", "onSelected", "onHoverValue"]))
    ]));
  }
});
var nl = {
  key: 0,
  class: "dp__time_input"
};
var rl = ["data-compact", "data-collapsed"];
var ll = ["data-test-id", "aria-label", "onKeydown", "onClick", "onMousedown"];
var ol = ["aria-label", "disabled", "data-test-id", "onKeydown", "onClick"];
var sl = ["data-test-id", "aria-label", "onKeydown", "onClick", "onMousedown"];
var ul = { key: 0 };
var il = ["aria-label", "data-compact"];
var cl = defineComponent({
  __name: "TimeInput",
  props: {
    hours: {},
    minutes: {},
    seconds: {},
    order: {},
    closeTimePickerBtn: {},
    disabledTimesConfig: {},
    validateTime: {}
  },
  emits: ["update:hours", "update:minutes", "update:seconds", "overlay-opened", "overlay-closed", "set-hours", "set-minutes", "reset-flow", "mounted"],
  setup(e, { expose: w, emit: h2 }) {
    const r = h2, o = e, { setTimePickerElements: s, setTimePickerBackRef: a } = yt(), {
      getDate: l,
      rootEmit: d,
      rootProps: x,
      defaults: { ariaLabels: P, filters: O, config: M, range: i, multiCalendars: _, timeConfig: u }
    } = Se(), { checkKeyDown: T, hoursToAmPmHours: f } = Fe(), { boolHtmlAttribute: W } = Ot(), { sanitizeTime: B, groupListAndMap: D } = ze(), { transitionName: F, showTransition: Q } = jt(), I = reactive({
      hours: false,
      minutes: false,
      seconds: false
    }), y = ref("AM"), m = ref(null), k = ref([]), R = ref(), z = ref(false);
    onMounted(() => {
      r("mounted");
    });
    const Z = (n) => set(l(), {
      hours: n.hours,
      minutes: n.minutes,
      seconds: u.value.enableSeconds ? n.seconds : 0,
      milliseconds: 0
    }), te = computed(
      () => (n) => le(n, o[n]) || ge(n, o[n])
    ), de = computed(() => ({ hours: o.hours, minutes: o.minutes, seconds: o.seconds })), ge = (n, V) => i.value.enabled && !i.value.disableTimeRangeValidation ? !o.validateTime(n, V) : false, H = (n, V) => {
      if (i.value.enabled && !i.value.disableTimeRangeValidation) {
        const N = V ? +u.value[`${n}Increment`] : -+u.value[`${n}Increment`], ue = o[n] + N;
        return !o.validateTime(n, ue);
      }
      return false;
    }, se = computed(() => (n) => !b(+o[n] + +u.value[`${n}Increment`], n) || H(n, true)), E = computed(() => (n) => !b(+o[n] - +u.value[`${n}Increment`], n) || H(n, false)), ae = (n, V) => add(set(l(), n), V), K = (n, V) => sub(set(l(), n), V), ne = computed(
      () => ({
        dp__time_col: true,
        dp__time_col_block: !u.value.timePickerInline,
        dp__time_col_reg_block: !u.value.enableSeconds && u.value.is24 && !u.value.timePickerInline,
        dp__time_col_reg_inline: !u.value.enableSeconds && u.value.is24 && u.value.timePickerInline,
        dp__time_col_reg_with_button: !u.value.enableSeconds && !u.value.is24,
        dp__time_col_sec: u.value.enableSeconds && u.value.is24,
        dp__time_col_sec_with_button: u.value.enableSeconds && !u.value.is24
      })
    ), ie = computed(
      () => u.value.timePickerInline && i.value.enabled && !_.value.count
    ), ye = computed(() => {
      const n = [{ type: "hours" }];
      return u.value.enableMinutes && n.push({ type: "", separator: true }, {
        type: "minutes"
      }), u.value.enableSeconds && n.push({ type: "", separator: true }, {
        type: "seconds"
      }), n;
    }), _e = computed(() => ye.value.filter((n) => !n.separator)), Ae = computed(() => (n) => {
      if (n === "hours") {
        const V = S(+o.hours);
        return { text: V < 10 ? `0${V}` : `${V}`, value: V };
      }
      return { text: o[n] < 10 ? `0${o[n]}` : `${o[n]}`, value: o[n] };
    }), le = (n, V) => {
      var _a;
      if (!o.disabledTimesConfig) return false;
      const N = o.disabledTimesConfig(o.order, n === "hours" ? V : void 0);
      return N[n] ? !!((_a = N[n]) == null ? void 0 : _a.includes(V)) : true;
    }, me = (n, V) => V !== "hours" || y.value === "AM" ? n : n + 12, $ = (n) => {
      const V = u.value.is24 ? 24 : 12, N = n === "hours" ? V : 60, ue = +u.value[`${n}GridIncrement`], he = n === "hours" && !u.value.is24 ? ue : 0, Ie = [];
      for (let Le = he; Le < N; Le += ue)
        Ie.push({
          value: u.value.is24 ? Le : me(Le, n),
          text: Le < 10 ? `0${Le}` : `${Le}`
        });
      return n === "hours" && !u.value.is24 && Ie.unshift({ value: y.value === "PM" ? 12 : 0, text: "12" }), D(Ie, (Le) => ({ active: false, disabled: O.value.times[n].includes(Le.value) || !b(Le.value, n) || le(n, Le.value) || ge(n, Le.value) }));
    }, oe = (n) => n >= 0 ? n : 59, ee = (n) => n >= 0 ? n : 23, b = (n, V) => {
      const N = x.minTime ? Z(B(x.minTime)) : null, ue = x.maxTime ? Z(B(x.maxTime)) : null, he = Z(
        B(
          de.value,
          V,
          V === "minutes" || V === "seconds" ? oe(n) : ee(n)
        )
      );
      return N && ue ? (isBefore(he, ue) || isEqual(he, ue)) && (isAfter(he, N) || isEqual(he, N)) : N ? isAfter(he, N) || isEqual(he, N) : ue ? isBefore(he, ue) || isEqual(he, ue) : true;
    }, X = (n) => u.value[`no${n[0].toUpperCase() + n.slice(1)}Overlay`], L = (n) => {
      X(n) || (I[n] = !I[n], I[n] ? (z.value = true, r("overlay-opened", n)) : (z.value = false, r("overlay-closed", n)));
    }, ve = (n) => n === "hours" ? getHours : n === "minutes" ? getMinutes : getSeconds, c = () => {
      R.value && clearTimeout(R.value);
    }, p = (n, V = true, N) => {
      const ue = V ? ae : K, he = V ? +u.value[`${n}Increment`] : -+u.value[`${n}Increment`];
      b(+o[n] + he, n) && r(
        `update:${n}`,
        ve(n)(
          ue({ [n]: +o[n] }, { [n]: +u.value[`${n}Increment`] })
        )
      ), !(N == null ? void 0 : N.keyboard) && M.value.timeArrowHoldThreshold && (R.value = setTimeout(() => {
        p(n, V);
      }, M.value.timeArrowHoldThreshold));
    }, S = (n) => u.value.is24 ? n : (n >= 12 ? y.value = "PM" : y.value = "AM", f(n)), g = () => {
      y.value === "PM" ? (y.value = "AM", r("update:hours", o.hours - 12)) : (y.value = "PM", r("update:hours", o.hours + 12)), d("am-pm-change", y.value);
    }, Y = (n) => {
      I[n] = true;
    }, G = (n, V, N) => {
      if (n && x.arrowNavigation) {
        Array.isArray(k.value[V]) ? k.value[V][N] = n : k.value[V] = [n];
        const ue = k.value.reduce(
          (he, Ie) => Ie.map((Le, wt) => [...he[wt] || [], Ie[wt]]),
          []
        );
        a(o.closeTimePickerBtn), m.value && (ue[1] = ue[1].concat(m.value)), s(ue, o.order);
      }
    }, v = (n, V) => (L(n), r(`update:${n}`, V));
    return w({ openChildCmp: Y }), (n, V) => {
      var _a;
      return unref(x).disabled ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", nl, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(ye.value, (N, ue) => {
          var _a2, _b, _c;
          return openBlock(), createElementBlock("div", {
            key: ue,
            class: normalizeClass(ne.value),
            "data-compact": ie.value && !unref(u).enableSeconds,
            "data-collapsed": ie.value && unref(u).enableSeconds
          }, [
            N.separator ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              z.value ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                createTextVNode(":")
              ], 64))
            ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createBaseVNode("button", {
                ref_for: true,
                ref: (he) => G(he, ue, 0),
                type: "button",
                class: normalizeClass({
                  dp__btn: true,
                  dp__inc_dec_button: !unref(u).timePickerInline,
                  dp__inc_dec_button_inline: unref(u).timePickerInline,
                  dp__tp_inline_btn_top: unref(u).timePickerInline,
                  dp__inc_dec_button_disabled: se.value(N.type),
                  "dp--hidden-el": z.value
                }),
                "data-test-id": `${N.type}-time-inc-btn-${o.order}`,
                "aria-label": (_a2 = unref(P)) == null ? void 0 : _a2.incrementValue(N.type),
                tabindex: "0",
                onKeydown: (he) => unref(T)(he, () => p(N.type, true, { keyboard: true }), true),
                onClick: (he) => unref(M).timeArrowHoldThreshold ? void 0 : p(N.type, true),
                onMousedown: (he) => unref(M).timeArrowHoldThreshold ? p(N.type, true) : void 0,
                onMouseup: c
              }, [
                unref(u).timePickerInline ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                  n.$slots["tp-inline-arrow-up"] ? renderSlot(n.$slots, "tp-inline-arrow-up", { key: 0 }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                    V[2] || (V[2] = createBaseVNode("span", { class: "dp__tp_inline_btn_bar dp__tp_btn_in_l" }, null, -1)),
                    V[3] || (V[3] = createBaseVNode("span", { class: "dp__tp_inline_btn_bar dp__tp_btn_in_r" }, null, -1))
                  ], 64))
                ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                  n.$slots["arrow-up"] ? renderSlot(n.$slots, "arrow-up", { key: 0 }) : createCommentVNode("", true),
                  n.$slots["arrow-up"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(ja), { key: 1 }))
                ], 64))
              ], 42, ll),
              createBaseVNode("button", {
                ref_for: true,
                ref: (he) => G(he, ue, 1),
                type: "button",
                "aria-label": `${Ae.value(N.type).text}-${(_b = unref(P)) == null ? void 0 : _b.openTpOverlay(N.type)}`,
                class: normalizeClass({
                  dp__time_display: true,
                  dp__time_display_block: !unref(u).timePickerInline,
                  dp__time_display_inline: unref(u).timePickerInline,
                  "dp--time-invalid": te.value(N.type),
                  "dp--time-overlay-btn": !te.value(N.type),
                  "dp--hidden-el": z.value
                }),
                disabled: unref(W)(X(N.type)),
                tabindex: "0",
                "data-test-id": `${N.type}-toggle-overlay-btn-${o.order}`,
                onKeydown: (he) => unref(T)(he, () => L(N.type), true),
                onClick: (he) => L(N.type)
              }, [
                n.$slots[N.type] ? renderSlot(n.$slots, N.type, {
                  key: 0,
                  text: Ae.value(N.type).text,
                  value: Ae.value(N.type).value
                }) : createCommentVNode("", true),
                n.$slots[N.type] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                  createTextVNode(toDisplayString(Ae.value(N.type).text), 1)
                ], 64))
              ], 42, ol),
              createBaseVNode("button", {
                ref_for: true,
                ref: (he) => G(he, ue, 2),
                type: "button",
                class: normalizeClass({
                  dp__btn: true,
                  dp__inc_dec_button: !unref(u).timePickerInline,
                  dp__inc_dec_button_inline: unref(u).timePickerInline,
                  dp__tp_inline_btn_bottom: unref(u).timePickerInline,
                  dp__inc_dec_button_disabled: E.value(N.type),
                  "dp--hidden-el": z.value
                }),
                "data-test-id": `${N.type}-time-dec-btn-${o.order}`,
                "aria-label": (_c = unref(P)) == null ? void 0 : _c.decrementValue(N.type),
                tabindex: "0",
                onKeydown: (he) => unref(T)(he, () => p(N.type, false, { keyboard: true }), true),
                onClick: (he) => unref(M).timeArrowHoldThreshold ? void 0 : p(N.type, false),
                onMousedown: (he) => unref(M).timeArrowHoldThreshold ? p(N.type, false) : void 0,
                onMouseup: c
              }, [
                unref(u).timePickerInline ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                  n.$slots["tp-inline-arrow-down"] ? renderSlot(n.$slots, "tp-inline-arrow-down", { key: 0 }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                    V[4] || (V[4] = createBaseVNode("span", { class: "dp__tp_inline_btn_bar dp__tp_btn_in_l" }, null, -1)),
                    V[5] || (V[5] = createBaseVNode("span", { class: "dp__tp_inline_btn_bar dp__tp_btn_in_r" }, null, -1))
                  ], 64))
                ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                  n.$slots["arrow-down"] ? renderSlot(n.$slots, "arrow-down", { key: 0 }) : createCommentVNode("", true),
                  n.$slots["arrow-down"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(za), { key: 1 }))
                ], 64))
              ], 42, sl)
            ], 64))
          ], 10, rl);
        }), 128)),
        unref(u).is24 ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", ul, [
          n.$slots["am-pm-button"] ? renderSlot(n.$slots, "am-pm-button", {
            key: 0,
            toggle: g,
            value: y.value
          }) : createCommentVNode("", true),
          n.$slots["am-pm-button"] ? createCommentVNode("", true) : (openBlock(), createElementBlock("button", {
            key: 1,
            ref_key: "amPmButton",
            ref: m,
            type: "button",
            class: "dp__pm_am_button",
            role: "button",
            "aria-label": (_a = unref(P)) == null ? void 0 : _a.amPmButton,
            tabindex: "0",
            "data-compact": ie.value,
            onClick: g,
            onKeydown: V[0] || (V[0] = (N) => unref(T)(N, () => g(), true))
          }, toDisplayString(y.value), 41, il))
        ])),
        (openBlock(true), createElementBlock(Fragment, null, renderList(_e.value, (N, ue) => (openBlock(), createBlock(Transition, {
          key: ue,
          name: unref(F)(I[N.type]),
          css: unref(Q)
        }, {
          default: withCtx(() => {
            var _a2, _b;
            return [
              I[N.type] ? (openBlock(), createBlock(Ut, {
                key: 0,
                items: $(N.type),
                "is-last": unref(x).autoApply && !unref(M).keepActionRow,
                type: N.type,
                "aria-labels": unref(P),
                "overlay-label": (_b = (_a2 = unref(P)).timeOverlay) == null ? void 0 : _b.call(_a2, N.type),
                onSelected: (he) => v(N.type, he),
                onToggle: (he) => L(N.type),
                onResetFlow: V[1] || (V[1] = (he) => n.$emit("reset-flow"))
              }, createSlots({
                "button-icon": withCtx(() => [
                  n.$slots["clock-icon"] ? renderSlot(n.$slots, "clock-icon", { key: 0 }) : createCommentVNode("", true),
                  n.$slots["clock-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(resolveDynamicComponent(unref(u).timePickerInline ? unref(Kt) : unref(Ka)), { key: 1 }))
                ]),
                _: 2
              }, [
                n.$slots[`${N.type}-overlay-value`] ? {
                  name: "item",
                  fn: withCtx(({ item: he }) => [
                    renderSlot(n.$slots, `${N.type}-overlay-value`, {
                      text: he.text,
                      value: he.value
                    })
                  ]),
                  key: "0"
                } : void 0,
                n.$slots[`${N.type}-overlay-header`] ? {
                  name: "header",
                  fn: withCtx(() => [
                    renderSlot(n.$slots, `${N.type}-overlay-header`, {
                      toggle: () => L(N.type)
                    })
                  ]),
                  key: "1"
                } : void 0
              ]), 1032, ["items", "is-last", "type", "aria-labels", "overlay-label", "onSelected", "onToggle"])) : createCommentVNode("", true)
            ];
          }),
          _: 2
        }, 1032, ["name", "css"]))), 128))
      ]));
    };
  }
});
var dl = ["data-dp-mobile"];
var vl = ["aria-label", "tabindex"];
var fl = ["role", "aria-label", "tabindex"];
var ml = ["aria-label"];
var Ga = defineComponent({
  __name: "TimePicker",
  props: {
    hours: {},
    minutes: {},
    seconds: {},
    disabledTimesConfig: { type: [Function, null] },
    noOverlayFocus: { type: Boolean },
    validateTime: { type: Function }
  },
  emits: ["update:hours", "update:minutes", "update:seconds", "mount", "reset-flow"],
  setup(e, { expose: w, emit: h2 }) {
    const r = h2, o = e, {
      rootEmit: s,
      modelValue: a,
      rootProps: l,
      defaults: { ariaLabels: d, textInput: x, config: P, range: O, timeConfig: M }
    } = Se(), { isModelAuto: i } = ze(), { checkKeyDown: _, findFocusableEl: u } = Fe(), { buildMatrix: T, setTimePicker: f } = yt(), { transitionName: W, showTransition: B } = jt(), { hideNavigationButtons: D } = la(), { mapSlots: F } = bt(), { isMobile: Q } = na(), I = useSlots(), y = useTemplateRef("overlay"), m = useTemplateRef("open-tp-btn"), k = useTemplateRef("close-tp-btn"), R = useTemplateRef("tp-input"), z = ref(false);
    onMounted(() => {
      r("mount"), !l.timePicker && l.arrowNavigation ? T([unrefElement(m.value)], "time") : f(true, l.timePicker);
    });
    const Z = computed(() => O.value.enabled && l.modelAuto ? i(a.value) : true), te = ref(false), de = (le) => ({
      hours: Array.isArray(o.hours) ? o.hours[le] : o.hours,
      minutes: Array.isArray(o.minutes) ? o.minutes[le] : o.minutes,
      seconds: Array.isArray(o.seconds) ? o.seconds[le] : o.seconds
    }), ge = computed(() => {
      const le = [];
      if (O.value.enabled)
        for (let me = 0; me < 2; me++)
          le.push(de(me));
      else
        le.push(de(0));
      return le;
    }), H = (le, me = false, $ = "") => {
      me || r("reset-flow"), te.value = le, s("overlay-toggle", { open: le, overlay: Qe.time }), l.arrowNavigation && f(le), nextTick(() => {
        var _a;
        $ !== "" && ((_a = R.value) == null ? void 0 : _a[0]) && R.value[0].openChildCmp($);
      });
    }, se = computed(() => ({
      dp__btn: true,
      dp__button: true,
      dp__button_bottom: l.autoApply && !P.value.keepActionRow
    })), E = F(I, "timePicker"), ae = (le, me, $) => O.value.enabled ? me === 0 ? [le, ge.value[1][$]] : [ge.value[0][$], le] : le, K = (le) => {
      r("update:hours", le);
    }, ne = (le) => {
      r("update:minutes", le);
    }, ie = (le) => {
      r("update:seconds", le);
    }, ye = () => {
      if (y.value && !x.value.enabled && !o.noOverlayFocus) {
        const le = u(y.value);
        le && le.focus({ preventScroll: true });
      }
    }, _e = (le) => {
      z.value = false, s("overlay-toggle", { open: false, overlay: le });
    }, Ae = (le) => {
      z.value = true, s("overlay-toggle", { open: true, overlay: le });
    };
    return w({ toggleTimePicker: H }), (le, me) => {
      var _a;
      return openBlock(), createElementBlock("div", {
        class: "dp--tp-wrap",
        "data-dp-mobile": unref(Q)
      }, [
        !unref(l).timePicker && !unref(M).timePickerInline ? withDirectives((openBlock(), createElementBlock("button", {
          key: 0,
          ref: "open-tp-btn",
          type: "button",
          class: normalizeClass({ ...se.value, "dp--hidden-el": te.value }),
          "aria-label": (_a = unref(d)) == null ? void 0 : _a.openTimePicker,
          tabindex: e.noOverlayFocus ? void 0 : 0,
          "data-test-id": "open-time-picker-btn",
          onKeydown: me[0] || (me[0] = ($) => unref(_)($, () => H(true))),
          onClick: me[1] || (me[1] = ($) => H(true))
        }, [
          le.$slots["clock-icon"] ? renderSlot(le.$slots, "clock-icon", { key: 0 }) : createCommentVNode("", true),
          le.$slots["clock-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Ka), { key: 1 }))
        ], 42, vl)), [
          [vShow, !unref(D)("time")]
        ]) : createCommentVNode("", true),
        createVNode(Transition, {
          name: unref(W)(te.value),
          css: unref(B) && !unref(M).timePickerInline
        }, {
          default: withCtx(() => {
            var _a2, _b;
            return [
              te.value || unref(l).timePicker || unref(M).timePickerInline ? (openBlock(), createElementBlock("div", {
                key: 0,
                ref: "overlay",
                role: unref(M).timePickerInline ? void 0 : "dialog",
                class: normalizeClass({
                  dp__overlay: !unref(M).timePickerInline,
                  "dp--overlay-absolute": !unref(l).timePicker && !unref(M).timePickerInline,
                  "dp--overlay-relative": unref(l).timePicker
                }),
                style: normalizeStyle(unref(l).timePicker ? { height: `${unref(P).modeHeight}px` } : void 0),
                "aria-label": (_a2 = unref(d)) == null ? void 0 : _a2.timePicker,
                tabindex: unref(M).timePickerInline ? void 0 : 0
              }, [
                createBaseVNode("div", {
                  class: normalizeClass(
                    unref(M).timePickerInline ? "dp__time_picker_inline_container" : "dp__overlay_container dp__container_flex dp__time_picker_overlay_container"
                  ),
                  style: { display: "flex" }
                }, [
                  le.$slots["time-picker-overlay"] ? renderSlot(le.$slots, "time-picker-overlay", {
                    key: 0,
                    hours: e.hours,
                    minutes: e.minutes,
                    seconds: e.seconds,
                    setHours: K,
                    setMinutes: ne,
                    setSeconds: ie
                  }) : createCommentVNode("", true),
                  le.$slots["time-picker-overlay"] ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", {
                    key: 1,
                    class: normalizeClass(unref(M).timePickerInline ? "dp__flex" : "dp__overlay_row dp__flex_row")
                  }, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(ge.value, ($, oe) => withDirectives((openBlock(), createBlock(cl, mergeProps({ key: oe }, { ref_for: true }, {
                      order: oe,
                      hours: $.hours,
                      minutes: $.minutes,
                      seconds: $.seconds,
                      closeTimePickerBtn: k.value,
                      disabledTimesConfig: e.disabledTimesConfig,
                      disabled: oe === 0 ? unref(O).fixedStart : unref(O).fixedEnd
                    }, {
                      ref_for: true,
                      ref: "tp-input",
                      "validate-time": (ee, b) => e.validateTime(ee, ae(b, oe, ee)),
                      "onUpdate:hours": (ee) => K(ae(ee, oe, "hours")),
                      "onUpdate:minutes": (ee) => ne(ae(ee, oe, "minutes")),
                      "onUpdate:seconds": (ee) => ie(ae(ee, oe, "seconds")),
                      onMounted: ye,
                      onOverlayClosed: _e,
                      onOverlayOpened: Ae
                    }), createSlots({ _: 2 }, [
                      renderList(unref(E), (ee, b) => ({
                        name: ee,
                        fn: withCtx((X) => [
                          renderSlot(le.$slots, ee, mergeProps({ ref_for: true }, X))
                        ])
                      }))
                    ]), 1040, ["validate-time", "onUpdate:hours", "onUpdate:minutes", "onUpdate:seconds"])), [
                      [vShow, oe === 0 ? true : Z.value]
                    ])), 128))
                  ], 2)),
                  !unref(l).timePicker && !unref(M).timePickerInline ? withDirectives((openBlock(), createElementBlock("button", {
                    key: 2,
                    ref: "close-tp-btn",
                    type: "button",
                    class: normalizeClass({ ...se.value, "dp--hidden-el": z.value }),
                    "aria-label": (_b = unref(d)) == null ? void 0 : _b.closeTimePicker,
                    tabindex: "0",
                    onKeydown: me[2] || (me[2] = ($) => unref(_)($, () => H(false))),
                    onClick: me[3] || (me[3] = ($) => H(false))
                  }, [
                    le.$slots["calendar-icon"] ? renderSlot(le.$slots, "calendar-icon", { key: 0 }) : createCommentVNode("", true),
                    le.$slots["calendar-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Kt), { key: 1 }))
                  ], 42, ml)), [
                    [vShow, !unref(D)("time")]
                  ]) : createCommentVNode("", true)
                ], 2)
              ], 14, fl)) : createCommentVNode("", true)
            ];
          }),
          _: 3
        }, 8, ["name", "css"])
      ], 8, dl);
    };
  }
});
var Ja = (e) => {
  const {
    getDate: w,
    modelValue: h2,
    time: r,
    rootProps: o,
    defaults: { range: s, timeConfig: a }
  } = Se(), { isDateEqual: l, setTime: d } = ze(), x = (I, y) => Array.isArray(r[I]) ? r[I][y] : r[I], P = (I) => a.value.enableSeconds ? Array.isArray(r.seconds) ? r.seconds[I] : r.seconds : 0, O = (I, y) => I ? d(
    y !== void 0 ? { hours: x("hours", y), minutes: x("minutes", y), seconds: P(y) } : { hours: r.hours, minutes: r.minutes, seconds: P() },
    I
  ) : setSeconds(w(), P(y)), M = (I, y) => {
    r[I] = y;
  }, i = computed(() => o.modelAuto && s.value.enabled ? Array.isArray(h2.value) ? h2.value.length > 1 : false : s.value.enabled), _ = (I, y) => {
    const m = Object.fromEntries(
      Object.keys(r).map((k) => k === I ? [k, y] : [k, r[k]].slice())
    );
    if (i.value && !s.value.disableTimeRangeValidation) {
      const k = (z) => h2.value ? d(
        {
          hours: m.hours[z],
          minutes: m.minutes[z],
          seconds: m.seconds[z]
        },
        h2.value[z]
      ) : null, R = (z) => setMilliseconds(h2.value[z], 0);
      return !(l(k(0), k(1)) && (isAfter(k(0), R(1)) || isBefore(k(1), R(0))));
    }
    return true;
  }, u = (I, y) => {
    _(I, y) && (M(I, y), e && e());
  }, T = (I) => {
    u("hours", I);
  }, f = (I) => {
    u("minutes", I);
  }, W = (I) => {
    u("seconds", I);
  }, B = (I, y) => {
    T(I.hours), f(I.minutes), W(I.seconds), h2.value && y(h2.value);
  }, D = (I) => {
    if (I) {
      const y = Array.isArray(I), m = y ? [+I[0].hours, +I[1].hours] : +I.hours, k = y ? [+I[0].minutes, +I[1].minutes] : +I.minutes, R = y ? [+(I[0].seconds ?? 0), +(I[1].seconds ?? 0)] : +(I.seconds ?? 0);
      M("hours", m), M("minutes", k), a.value.enableSeconds && M("seconds", R);
    }
  }, F = (I, y) => {
    const m = {
      hours: Array.isArray(r.hours) ? r.hours[I] : r.hours,
      disabledArr: []
    };
    return (y || y === 0) && (m.hours = y), Array.isArray(o.disabledTimes) && (m.disabledArr = s.value.enabled && Array.isArray(o.disabledTimes[I]) ? o.disabledTimes[I] : o.disabledTimes), m;
  }, Q = computed(() => (I, y) => {
    var _a;
    if (Array.isArray(o.disabledTimes)) {
      const { disabledArr: m, hours: k } = F(I, y), R = m.filter((z) => +z.hours === k);
      return ((_a = R[0]) == null ? void 0 : _a.minutes) === "*" ? { hours: [k], minutes: void 0, seconds: void 0 } : {
        hours: [],
        minutes: (R == null ? void 0 : R.map((z) => +z.minutes)) ?? [],
        seconds: (R == null ? void 0 : R.map((z) => z.seconds ? +z.seconds : void 0)) ?? []
      };
    }
    return { hours: [], minutes: [], seconds: [] };
  });
  return {
    assignTime: M,
    updateHours: T,
    updateMinutes: f,
    updateSeconds: W,
    getSetDateTime: O,
    updateTimeValues: B,
    getSecondsValue: P,
    assignStartTime: D,
    validateTime: _,
    disabledTimesConfig: Q
  };
};
var pl = (e) => {
  const {
    getDate: w,
    time: h2,
    modelValue: r,
    state: o,
    defaults: { startTime: s, range: a, timeConfig: l }
  } = Se(), { getTimeObj: d } = ze();
  zt(() => {
    o.isTextInputDate && F();
  });
  const { updateTimeValues: x, getSetDateTime: P, assignTime: O, assignStartTime: M, disabledTimesConfig: i, validateTime: _ } = Ja(u);
  function u() {
    e("update-flow-step");
  }
  const T = (y) => {
    const { hours: m, minutes: k, seconds: R } = y;
    return { hours: +m, minutes: +k, seconds: R ? +R : 0 };
  }, f = () => {
    if (l.value.startTime) {
      if (Array.isArray(l.value.startTime)) {
        const m = T(l.value.startTime[0]), k = T(l.value.startTime[1]);
        return [set(w(), m), set(w(), k)];
      }
      const y = T(l.value.startTime);
      return set(w(), y);
    }
    return a.value.enabled ? [null, null] : null;
  }, W = () => {
    if (a.value.enabled) {
      const [y, m] = f();
      r.value = [P(y, 0), P(m, 1)];
    } else
      r.value = P(f());
  }, B = (y) => Array.isArray(y) ? [d(w(y[0])), d(w(y[1]))] : [d(y ?? w())], D = (y, m, k) => {
    O("hours", y), O("minutes", m), O("seconds", l.value.enableSeconds ? k : 0);
  }, F = () => {
    const [y, m] = B(r.value);
    return a.value.enabled ? D(
      [y.hours, m.hours],
      [y.minutes, m.minutes],
      [y.seconds, m.seconds]
    ) : D(y.hours, y.minutes, y.seconds);
  };
  onMounted(() => (M(s.value), r.value ? F() : W()));
  const Q = () => {
    Array.isArray(r.value) ? r.value = r.value.map((y, m) => y && P(y, m)) : r.value = P(r.value), e("time-update");
  };
  return {
    modelValue: r,
    time: h2,
    disabledTimesConfig: i,
    validateTime: _,
    updateTime: (y) => {
      x(y, Q);
    }
  };
};
var hl = defineComponent({
  __name: "TimePickerSolo",
  props: {
    flowStep: {},
    collapse: { type: Boolean },
    menuWrapRef: {},
    noOverlayFocus: { type: Boolean }
  },
  emits: ["time-update", "mount", "reset-flow", "update-flow-step"],
  setup(e, { expose: w, emit: h2 }) {
    const r = h2, o = useSlots(), { mapSlots: s } = bt(), a = s(o, "timePicker"), l = useTemplateRef("time-input"), { time: d, modelValue: x, disabledTimesConfig: P, updateTime: O, validateTime: M } = pl(r);
    return onMounted(() => {
      r("mount");
    }), w({ getSidebarProps: () => ({
      modelValue: x,
      time: d,
      updateTime: O
    }), toggleTimePicker: (u, T = false, f = "") => {
      var _a;
      (_a = l.value) == null ? void 0 : _a.toggleTimePicker(u, T, f);
    } }), (u, T) => (openBlock(), createBlock(oa, {
      "multi-calendars": 0,
      stretch: ""
    }, {
      default: withCtx(({ wrapClass: f }) => [
        createBaseVNode("div", {
          class: normalizeClass(f)
        }, [
          createVNode(Ga, mergeProps({ ref: "time-input" }, u.$props, {
            hours: unref(d).hours,
            minutes: unref(d).minutes,
            seconds: unref(d).seconds,
            "disabled-times-config": unref(P),
            "validate-time": unref(M),
            "onUpdate:hours": T[0] || (T[0] = (W) => unref(O)({ hours: W, minutes: unref(d).minutes, seconds: unref(d).seconds })),
            "onUpdate:minutes": T[1] || (T[1] = (W) => unref(O)({ hours: unref(d).hours, minutes: W, seconds: unref(d).seconds })),
            "onUpdate:seconds": T[2] || (T[2] = (W) => unref(O)({ hours: unref(d).hours, minutes: unref(d).minutes, seconds: W })),
            onResetFlow: T[3] || (T[3] = (W) => u.$emit("reset-flow"))
          }), createSlots({ _: 2 }, [
            renderList(unref(a), (W, B) => ({
              name: W,
              fn: withCtx((D) => [
                renderSlot(u.$slots, W, normalizeProps(guardReactiveProps(D)))
              ])
            }))
          ]), 1040, ["hours", "minutes", "seconds", "disabled-times-config", "validate-time"])
        ], 2)
      ]),
      _: 3
    }));
  }
});
var gl = (e, w) => {
  const {
    getDate: h2,
    rootProps: r,
    defaults: { filters: o }
  } = Se(), { validateMonthYearInRange: s, validateMonthYear: a } = nt(), l = (M, i) => {
    let _ = M;
    return o.value.months.includes(getMonth(_)) ? (_ = i ? addMonths(M, 1) : subMonths(M, 1), l(_, i)) : _;
  }, d = (M, i) => {
    let _ = M;
    return o.value.years.includes(getYear(_)) ? (_ = i ? addYears(M, 1) : subYears(M, 1), d(_, i)) : _;
  }, x = (M, i = false) => {
    const _ = set(h2(), { month: e.month, year: e.year });
    let u = M ? addMonths(_, 1) : subMonths(_, 1);
    r.disableYearSelect && (u = setYear(u, e.year));
    let T = getMonth(u), f = getYear(u);
    o.value.months.includes(T) && (u = l(u, M), T = getMonth(u), f = getYear(u)), o.value.years.includes(f) && (u = d(u, M), f = getYear(u)), s(T, f, M, r.preventMinMaxNavigation) && P(T, f, i);
  }, P = (M, i, _) => {
    w("update-month-year", { month: M, year: i, fromNav: _ });
  }, O = computed(() => (M) => a(
    set(h2(), { month: e.month, year: e.year }),
    r.preventMinMaxNavigation,
    M
  ));
  return { handleMonthYearChange: x, isDisabled: O, updateMonthYear: P };
};
var yl = { class: "dp--header-wrap" };
var bl = {
  key: 0,
  class: "dp__month_year_wrap"
};
var kl = { key: 0 };
var wl = { class: "dp__month_year_wrap" };
var Dl = ["data-dp-element", "aria-label", "data-test-id", "onClick", "onKeydown"];
var Ml = defineComponent({
  __name: "DpHeader",
  props: {
    month: {},
    year: {},
    instance: {},
    years: {},
    months: {},
    menuWrapRef: {}
  },
  emits: ["mount", "reset-flow", "update-month-year"],
  setup(e, { expose: w, emit: h2 }) {
    const r = h2, o = e, {
      rootEmit: s,
      rootProps: a,
      modelValue: l,
      defaults: { ariaLabels: d, filters: x, config: P, highlight: O, safeDates: M, ui: i }
    } = Se(), { transitionName: _, showTransition: u } = jt(), { showLeftIcon: T, showRightIcon: f } = la(), { buildMatrix: W } = yt(), { handleMonthYearChange: B, isDisabled: D, updateMonthYear: F } = gl(o, r), { getMaxMonth: Q, getMinMonth: I, getYearFromDate: y, groupListAndMap: m, checkHighlightYear: k, checkHighlightMonth: R } = ze(), { checkKeyDown: z } = Fe(), { formatYear: Z } = kt(), { checkMinMaxValue: te } = nt(), { boolHtmlAttribute: de } = Ot(), ge = ref(false), H = ref(false), se = ref(false), E = ref([null, null, null, null]);
    onMounted(() => {
      r("mount");
    });
    const ae = (L) => ({
      get: () => o[L],
      set: (ve) => {
        const c = L === lt.month ? lt.year : lt.month;
        r("update-month-year", { [L]: ve, [c]: o[c] }), L === lt.month ? me(true) : $(true);
      }
    }), K = computed(ae(lt.month)), ne = computed(ae(lt.year)), ie = computed(() => (L) => ({
      month: o.month,
      year: o.year,
      items: L === lt.month ? o.months : o.years,
      instance: o.instance,
      updateMonthYear: F,
      toggle: L === lt.month ? me : $
    })), ye = computed(() => {
      const L = o.months.find((ve) => ve.value === o.month);
      return L || { text: "", value: 0 };
    }), _e = computed(() => m(o.months, (L) => {
      const ve = o.month === L.value, c = te(
        L.value,
        I(o.year, M.value.minDate),
        Q(o.year, M.value.maxDate)
      ) || x.value.months.includes(L.value), p = R(O.value, L.value, o.year);
      return { active: ve, disabled: c, highlighted: p };
    })), Ae = computed(() => m(o.years, (L) => {
      const ve = o.year === L.value, c = te(
        L.value,
        y(M.value.minDate),
        y(M.value.maxDate)
      ) || x.value.years.includes(L.value), p = k(O.value, L.value);
      return { active: ve, disabled: c, highlighted: p };
    })), le = (L, ve, c) => {
      c === void 0 ? L.value = !L.value : L.value = c, L.value ? (se.value = true, s("overlay-toggle", { open: true, overlay: ve })) : (se.value = false, s("overlay-toggle", { open: false, overlay: ve }));
    }, me = (L = false, ve) => {
      oe(L), le(ge, Qe.month, ve);
    }, $ = (L = false, ve) => {
      oe(L), le(H, Qe.year, ve);
    }, oe = (L) => {
      L || r("reset-flow");
    }, ee = (L, ve) => {
      a.arrowNavigation && (E.value[ve] = unrefElement(L), W(E.value, "monthYear"));
    }, b = computed(() => {
      var _a, _b, _c, _d, _e2, _f;
      return [
        {
          type: lt.month,
          index: 1,
          toggle: me,
          modelValue: K.value,
          updateModelValue: (L) => K.value = L,
          text: ye.value.text,
          showSelectionGrid: ge.value,
          items: _e.value,
          ariaLabel: (_a = d.value) == null ? void 0 : _a.openMonthsOverlay,
          overlayLabel: ((_c = (_b = d.value).monthPicker) == null ? void 0 : _c.call(_b, true)) ?? void 0
        },
        {
          type: lt.year,
          index: 2,
          toggle: $,
          modelValue: ne.value,
          updateModelValue: (L) => ne.value = L,
          text: Z(o.year),
          showSelectionGrid: H.value,
          items: Ae.value,
          ariaLabel: (_d = d.value) == null ? void 0 : _d.openYearsOverlay,
          overlayLabel: ((_f = (_e2 = d.value).yearPicker) == null ? void 0 : _f.call(_e2, true)) ?? void 0
        }
      ];
    }), X = computed(() => a.disableYearSelect ? [b.value[0]] : a.yearFirst ? [...b.value].reverse() : b.value);
    return w({
      toggleMonthPicker: me,
      toggleYearPicker: $,
      handleMonthYearChange: B
    }), (L, ve) => {
      var _a, _b, _c, _d, _e2, _f;
      return openBlock(), createElementBlock("div", yl, [
        L.$slots["month-year"] ? (openBlock(), createElementBlock("div", bl, [
          renderSlot(L.$slots, "month-year", normalizeProps(guardReactiveProps({
            month: e.month,
            year: e.year,
            months: e.months,
            years: e.years,
            updateMonthYear: unref(F),
            handleMonthYearChange: unref(B),
            instance: e.instance,
            isDisabled: unref(D)
          })))
        ])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          L.$slots["top-extra"] ? (openBlock(), createElementBlock("div", kl, [
            renderSlot(L.$slots, "top-extra", { value: unref(l) })
          ])) : createCommentVNode("", true),
          createBaseVNode("div", wl, [
            unref(T)(e.instance) && !unref(a).vertical ? (openBlock(), createBlock(Nt, {
              key: 0,
              "aria-label": (_a = unref(d)) == null ? void 0 : _a.prevMonth,
              disabled: unref(de)(unref(D)(false)),
              class: normalizeClass((_b = unref(i)) == null ? void 0 : _b.navBtnPrev),
              "el-name": "action-prev",
              onActivate: ve[0] || (ve[0] = (c) => unref(B)(false, true)),
              onSetRef: ve[1] || (ve[1] = (c) => ee(c, 0))
            }, {
              default: withCtx(() => [
                L.$slots["arrow-left"] ? renderSlot(L.$slots, "arrow-left", { key: 0 }) : createCommentVNode("", true),
                L.$slots["arrow-left"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(La), { key: 1 }))
              ]),
              _: 3
            }, 8, ["aria-label", "disabled", "class"])) : createCommentVNode("", true),
            createBaseVNode("div", {
              class: normalizeClass(["dp__month_year_wrap", {
                dp__year_disable_select: unref(a).disableYearSelect
              }])
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(X.value, (c, p) => (openBlock(), createElementBlock(Fragment, {
                key: c.type
              }, [
                createBaseVNode("button", {
                  ref_for: true,
                  ref: (S) => ee(S, p + 1),
                  type: "button",
                  "data-dp-element": `overlay-${c.type}`,
                  class: normalizeClass(["dp__btn dp__month_year_select", { "dp--hidden-el": se.value }]),
                  "aria-label": `${c.text}-${c.ariaLabel}`,
                  "data-test-id": `${c.type}-toggle-overlay-${e.instance}`,
                  onClick: (S) => c.toggle(false),
                  onKeydown: (S) => unref(z)(S, () => c.toggle(), true)
                }, [
                  L.$slots[c.type] ? renderSlot(L.$slots, c.type, {
                    key: 0,
                    text: c.text,
                    value: o[c.type]
                  }) : createCommentVNode("", true),
                  L.$slots[c.type] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                    createTextVNode(toDisplayString(c.text), 1)
                  ], 64))
                ], 42, Dl),
                createVNode(Transition, {
                  name: unref(_)(c.showSelectionGrid),
                  css: unref(u)
                }, {
                  default: withCtx(() => [
                    c.showSelectionGrid ? (openBlock(), createBlock(Ut, {
                      key: 0,
                      items: c.items,
                      "is-last": unref(a).autoApply && !unref(P).keepActionRow,
                      "skip-button-ref": false,
                      type: c.type,
                      "header-refs": [],
                      "menu-wrap-ref": e.menuWrapRef,
                      "overlay-label": c.overlayLabel,
                      onSelected: c.updateModelValue,
                      onToggle: c.toggle
                    }, createSlots({
                      "button-icon": withCtx(() => [
                        L.$slots["calendar-icon"] ? renderSlot(L.$slots, "calendar-icon", { key: 0 }) : createCommentVNode("", true),
                        L.$slots["calendar-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Kt), { key: 1 }))
                      ]),
                      _: 2
                    }, [
                      L.$slots[`${c.type}-overlay-value`] ? {
                        name: "item",
                        fn: withCtx(({ item: S }) => [
                          renderSlot(L.$slots, `${c.type}-overlay-value`, {
                            text: S.text,
                            value: S.value
                          })
                        ]),
                        key: "0"
                      } : void 0,
                      L.$slots[`${c.type}-overlay`] ? {
                        name: "overlay",
                        fn: withCtx(() => [
                          renderSlot(L.$slots, `${c.type}-overlay`, mergeProps({ ref_for: true }, ie.value(c.type)))
                        ]),
                        key: "1"
                      } : void 0,
                      L.$slots[`${c.type}-overlay-header`] ? {
                        name: "header",
                        fn: withCtx(() => [
                          renderSlot(L.$slots, `${c.type}-overlay-header`, {
                            toggle: c.toggle
                          })
                        ]),
                        key: "2"
                      } : void 0
                    ]), 1032, ["items", "is-last", "type", "menu-wrap-ref", "overlay-label", "onSelected", "onToggle"])) : createCommentVNode("", true)
                  ]),
                  _: 2
                }, 1032, ["name", "css"])
              ], 64))), 128))
            ], 2),
            unref(T)(e.instance) && unref(a).vertical ? (openBlock(), createBlock(Nt, {
              key: 1,
              "aria-label": (_c = unref(d)) == null ? void 0 : _c.prevMonth,
              "el-name": "action-prev",
              disabled: unref(de)(unref(D)(false)),
              class: normalizeClass((_d = unref(i)) == null ? void 0 : _d.navBtnPrev),
              onActivate: ve[2] || (ve[2] = (c) => unref(B)(false, true))
            }, {
              default: withCtx(() => [
                L.$slots["arrow-up"] ? renderSlot(L.$slots, "arrow-up", { key: 0 }) : createCommentVNode("", true),
                L.$slots["arrow-up"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(ja), { key: 1 }))
              ]),
              _: 3
            }, 8, ["aria-label", "disabled", "class"])) : createCommentVNode("", true),
            unref(f)(e.instance) ? (openBlock(), createBlock(Nt, {
              key: 2,
              ref: "rightIcon",
              "el-name": "action-next",
              disabled: unref(de)(unref(D)(true)),
              "aria-label": (_e2 = unref(d)) == null ? void 0 : _e2.nextMonth,
              class: normalizeClass((_f = unref(i)) == null ? void 0 : _f.navBtnNext),
              onActivate: ve[3] || (ve[3] = (c) => unref(B)(true, true)),
              onSetRef: ve[4] || (ve[4] = (c) => ee(c, unref(a).disableYearSelect ? 2 : 3))
            }, {
              default: withCtx(() => [
                L.$slots[unref(a).vertical ? "arrow-down" : "arrow-right"] ? renderSlot(L.$slots, unref(a).vertical ? "arrow-down" : "arrow-right", { key: 0 }) : createCommentVNode("", true),
                L.$slots[unref(a).vertical ? "arrow-down" : "arrow-right"] ? createCommentVNode("", true) : (openBlock(), createBlock(resolveDynamicComponent(unref(a).vertical ? unref(za) : unref(Ha)), { key: 1 }))
              ]),
              _: 3
            }, 8, ["disabled", "aria-label", "class"])) : createCommentVNode("", true)
          ])
        ], 64))
      ]);
    };
  }
});
var _l = {
  class: "dp__calendar_header",
  role: "row"
};
var Al = {
  key: 0,
  class: "dp__calendar_header_item",
  role: "gridcell"
};
var Pl = ["aria-label"];
var Tl = {
  key: 0,
  class: "dp__calendar_item dp__week_num",
  role: "gridcell"
};
var $l = { class: "dp__cell_inner" };
var Sl = ["id", "aria-selected", "aria-disabled", "aria-label", "tabindex", "data-test-id", "onClick", "onTouchend", "onKeydown", "onMouseenter", "onMouseleave", "onMousedown"];
var Rl = defineComponent({
  __name: "DpCalendar",
  props: {
    instance: {},
    mappedDates: {},
    month: {},
    year: {}
  },
  emits: ["mount", "select-date", "set-hover-date", "handle-scroll", "handle-swipe"],
  setup(e, { expose: w, emit: h2 }) {
    const r = h2, o = e, {
      getDate: s,
      rootEmit: a,
      rootProps: l,
      defaults: { transitions: d, config: x, ariaLabels: P, multiCalendars: O, weekNumbers: M, multiDates: i, ui: _ }
    } = Se(), { buildMultiLevelMatrix: u } = yt(), { isDateAfter: T, isDateEqual: f, resetDateTime: W, getCellId: B } = ze(), { checkKeyDown: D, checkStopPropagation: F, isTouchDevice: Q } = Fe(), { formatWeekDay: I } = kt(), y = useTemplateRef("calendar-wrap"), m = useTemplateRef("active-tooltip"), k = ref([]), R = ref(null), z = ref(true), Z = ref(false), te = ref(""), de = ref({
      bottom: "",
      left: "",
      transform: ""
    }), ge = ref({ left: "50%" });
    useSwipe(y, {
      onSwipeEnd: (g, Y) => {
        x.value.noSwipe || (l.vertical ? (Y === "up" || Y === "down") && r("handle-swipe", Y === "up" ? "left" : "right") : (Y === "left" || Y === "right") && r("handle-swipe", Y === "right" ? "left" : "right"));
      }
    });
    const H = computed(() => l.calendar ? l.calendar(o.mappedDates) : o.mappedDates), se = computed(() => l.dayNames ? Array.isArray(l.dayNames) ? l.dayNames : l.dayNames() : S());
    onMounted(() => {
      r("mount", { cmp: "calendar", dayRefs: k.value }), x.value.monthChangeOnScroll && y.value && y.value.addEventListener("wheel", b, { passive: false });
    }), onUnmounted(() => {
      x.value.monthChangeOnScroll && y.value && y.value.removeEventListener("wheel", b);
    });
    const E = (g) => g ? l.vertical ? "vNext" : "next" : l.vertical ? "vPrevious" : "previous", ae = (g, Y) => {
      if (l.transitions) {
        const G = W(set(s(), { month: o.month, year: o.year }));
        te.value = T(W(set(s(), { month: g, year: Y })), G) ? d.value[E(true)] : d.value[E(false)], z.value = false, nextTick(() => {
          z.value = true;
        });
      }
    }, K = computed(
      () => ({
        ..._.value.calendar
      })
    ), ne = (g) => ({ type: "dot", ...g }), ie = computed(() => (g) => {
      const Y = ne(g);
      return {
        dp__marker_dot: Y.type === "dot",
        dp__marker_line: Y.type === "line"
      };
    }), ye = computed(() => (g) => f(g, R.value)), _e = computed(() => ({
      dp__calendar: true,
      dp__calendar_next: O.value.count > 0 && o.instance !== 0
    })), Ae = computed(() => (g) => l.hideOffsetDates ? g.current : true), le = async (g, Y) => {
      var _a;
      const { width: G, height: v } = g.getBoundingClientRect();
      R.value = Y.value;
      let n = { left: `${G / 2}px` }, V = -50;
      if (await nextTick(), (_a = m.value) == null ? void 0 : _a[0]) {
        const { left: N, width: ue } = m.value[0].getBoundingClientRect();
        N < 0 && (n = { left: "0" }, V = 0, ge.value.left = `${G / 2}px`), globalThis.innerWidth < N + ue && (n = { right: "0" }, V = 0, ge.value.left = `${ue - G / 2}px`);
      }
      de.value = {
        bottom: `${v}px`,
        ...n,
        transform: `translateX(${V}%)`
      };
    }, me = async (g, Y, G) => {
      var _a, _b, _c, _d, _e2;
      const v = unrefElement((_b = (_a = k.value) == null ? void 0 : _a[Y]) == null ? void 0 : _b[G]);
      v && (((_c = g.marker) == null ? void 0 : _c.customPosition) && ((_e2 = (_d = g.marker) == null ? void 0 : _d.tooltip) == null ? void 0 : _e2.length) ? de.value = g.marker.customPosition(v) : await le(v, g), a("tooltip-open", g.marker));
    }, $ = async (g, Y, G) => {
      var _a, _b;
      if (Z.value && i.value.enabled && i.value.dragSelect)
        return r("select-date", g);
      if (r("set-hover-date", g), (_b = (_a = g.marker) == null ? void 0 : _a.tooltip) == null ? void 0 : _b.length) {
        if (l.hideOffsetDates && !g.current) return;
        await me(g, Y, G);
      }
    }, oe = (g) => {
      R.value && (R.value = null, de.value = structuredClone({ bottom: "", left: "", transform: "" }), a("tooltip-close", g.marker));
    }, ee = (g, Y, G) => {
      g && (Array.isArray(k.value[Y]) ? k.value[Y][G] = g : k.value[Y] = [g]), l.arrowNavigation && u(k.value, "calendar");
    }, b = (g) => {
      x.value.monthChangeOnScroll && (g.preventDefault(), r("handle-scroll", g));
    }, X = (g) => M.value ? M.value.type === "local" ? getWeek(g.value, {
      weekStartsOn: +l.weekStart,
      locale: l.locale
    }) : M.value.type === "iso" ? getISOWeek(g.value) : typeof M.value.type == "function" ? M.value.type(g.value) : "" : "", L = (g) => {
      var _a;
      const Y = g[0];
      return ((_a = M.value) == null ? void 0 : _a.hideOnOffsetDates) ? g.some((G) => G.current) ? X(Y) : "" : X(Y);
    }, ve = (g, Y, G = true) => {
      !G && Q() || (!i.value.enabled || x.value.allowPreventDefault) && (F(g, x.value), r("select-date", Y));
    }, c = (g) => {
      F(g, x.value);
    }, p = (g) => {
      i.value.enabled && i.value.dragSelect ? (Z.value = true, r("select-date", g)) : i.value.enabled && r("select-date", g);
    }, S = () => {
      const g = s(), Y = startOfWeek(g, { locale: l.locale, weekStartsOn: +l.weekStart }), G = endOfWeek(g, { locale: l.locale, weekStartsOn: +l.weekStart });
      return eachDayOfInterval({ start: Y, end: G }).map((n) => I(n));
    };
    return w({ triggerTransition: ae }), (g, Y) => (openBlock(), createElementBlock("div", {
      class: normalizeClass(_e.value)
    }, [
      createBaseVNode("div", {
        ref: "calendar-wrap",
        class: normalizeClass(K.value),
        role: "grid"
      }, [
        createBaseVNode("div", _l, [
          unref(M) ? (openBlock(), createElementBlock("div", Al, toDisplayString(unref(M).label), 1)) : createCommentVNode("", true),
          (openBlock(true), createElementBlock(Fragment, null, renderList(se.value, (G, v) => {
            var _a, _b;
            return openBlock(), createElementBlock("div", {
              key: v,
              class: "dp__calendar_header_item",
              role: "gridcell",
              "data-test-id": "calendar-header",
              "aria-label": (_b = (_a = unref(P)) == null ? void 0 : _a.weekDay) == null ? void 0 : _b.call(_a, v)
            }, [
              g.$slots["calendar-header"] ? renderSlot(g.$slots, "calendar-header", {
                key: 0,
                day: G,
                index: v
              }) : createCommentVNode("", true),
              g.$slots["calendar-header"] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createTextVNode(toDisplayString(G), 1)
              ], 64))
            ], 8, Pl);
          }), 128))
        ]),
        Y[2] || (Y[2] = createBaseVNode("div", { class: "dp__calendar_header_separator" }, null, -1)),
        createVNode(Transition, {
          name: te.value,
          css: !!unref(d)
        }, {
          default: withCtx(() => [
            z.value ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: "dp__calendar",
              role: "rowgroup",
              onMouseleave: Y[1] || (Y[1] = (G) => Z.value = false)
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(H.value, (G, v) => (openBlock(), createElementBlock("div", {
                key: v,
                class: "dp__calendar_row",
                role: "row"
              }, [
                unref(M) ? (openBlock(), createElementBlock("div", Tl, [
                  createBaseVNode("div", $l, toDisplayString(L(G.days)), 1)
                ])) : createCommentVNode("", true),
                (openBlock(true), createElementBlock(Fragment, null, renderList(G.days, (n, V) => {
                  var _a, _b, _c;
                  return openBlock(), createElementBlock("div", {
                    id: unref(B)(n.value),
                    ref_for: true,
                    ref: (N) => ee(N, v, V),
                    key: V + v,
                    role: "gridcell",
                    class: "dp__calendar_item",
                    "aria-selected": (n.classData.dp__active_date || n.classData.dp__range_start || n.classData.dp__range_end) ?? void 0,
                    "aria-disabled": n.classData.dp__cell_disabled || void 0,
                    "aria-label": (_b = (_a = unref(P)) == null ? void 0 : _a.day) == null ? void 0 : _b.call(_a, n),
                    tabindex: !n.current && unref(l).hideOffsetDates ? void 0 : 0,
                    "data-test-id": unref(B)(n.value),
                    onClick: withModifiers((N) => ve(N, n), ["prevent"]),
                    onTouchend: (N) => ve(N, n, false),
                    onKeydown: (N) => unref(D)(N, () => g.$emit("select-date", n)),
                    onMouseenter: (N) => $(n, v, V),
                    onMouseleave: (N) => oe(n),
                    onMousedown: (N) => p(n),
                    onMouseup: Y[0] || (Y[0] = (N) => Z.value = false)
                  }, [
                    createBaseVNode("div", {
                      class: normalizeClass(["dp__cell_inner", n.classData])
                    }, [
                      g.$slots.day && Ae.value(n) ? renderSlot(g.$slots, "day", {
                        key: 0,
                        day: +n.text,
                        date: n.value
                      }) : createCommentVNode("", true),
                      g.$slots.day ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                        createTextVNode(toDisplayString(n.text), 1)
                      ], 64)),
                      n.marker && Ae.value(n) ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                        g.$slots.marker ? renderSlot(g.$slots, "marker", {
                          key: 0,
                          marker: n.marker,
                          day: +n.text,
                          date: n.value
                        }) : (openBlock(), createElementBlock("div", {
                          key: 1,
                          class: normalizeClass(ie.value(n.marker)),
                          style: normalizeStyle(n.marker.color ? { backgroundColor: n.marker.color } : {})
                        }, null, 6))
                      ], 64)) : createCommentVNode("", true),
                      ye.value(n.value) ? (openBlock(), createElementBlock("div", {
                        key: 3,
                        ref_for: true,
                        ref: "active-tooltip",
                        class: "dp__marker_tooltip",
                        style: normalizeStyle(de.value)
                      }, [
                        ((_c = n.marker) == null ? void 0 : _c.tooltip) ? (openBlock(), createElementBlock("div", {
                          key: 0,
                          class: "dp__tooltip_content",
                          onClick: c
                        }, [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(n.marker.tooltip, (N, ue) => (openBlock(), createElementBlock("div", {
                            key: ue,
                            class: "dp__tooltip_text"
                          }, [
                            g.$slots["marker-tooltip"] ? renderSlot(g.$slots, "marker-tooltip", {
                              key: 0,
                              tooltip: N,
                              day: n.value
                            }) : createCommentVNode("", true),
                            g.$slots["marker-tooltip"] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                              createBaseVNode("div", {
                                class: "dp__tooltip_mark",
                                style: normalizeStyle(N.color ? { backgroundColor: N.color } : {})
                              }, null, 4),
                              createBaseVNode("div", null, toDisplayString(N.text), 1)
                            ], 64))
                          ]))), 128)),
                          createBaseVNode("div", {
                            class: "dp__arrow_bottom_tp",
                            style: normalizeStyle(ge.value)
                          }, null, 4)
                        ])) : createCommentVNode("", true)
                      ], 4)) : createCommentVNode("", true)
                    ], 2)
                  ], 40, Sl);
                }), 128))
              ]))), 128))
            ], 32)) : createCommentVNode("", true)
          ]),
          _: 3
        }, 8, ["name", "css"])
      ], 2)
    ], 2));
  }
});
var Cl = (e, w, h2, r) => {
  const o = ref([]), s = ref(/* @__PURE__ */ new Date()), a = ref(), {
    getDate: l,
    rootEmit: d,
    calendars: x,
    month: P,
    year: O,
    time: M,
    modelValue: i,
    rootProps: _,
    today: u,
    state: T,
    defaults: { multiCalendars: f, startTime: W, range: B, config: D, safeDates: F, multiDates: Q, timeConfig: I, flow: y }
  } = Se(), { validateMonthYearInRange: m, isDisabled: k, isDateRangeAllowed: R, checkMinMaxRange: z } = nt(), { updateTimeValues: Z, getSetDateTime: te, assignTime: de, assignStartTime: ge, validateTime: H, disabledTimesConfig: se } = Ja(r), { formatDay: E } = kt(), { resetDateTime: ae, setTime: K, isDateBefore: ne, isDateEqual: ie, getDaysInBetween: ye } = ze(), { checkRangeAutoApply: _e, getRangeWithFixedDate: Ae, handleMultiDatesSelect: le, setPresetDate: me } = sa(), { getMapDate: $ } = Fe();
  zt(() => c(T.isTextInputDate));
  const oe = (A) => !D.value.keepViewOnOffsetClick || A ? true : !a.value, ee = (A, J, pe, Me = false) => {
    var _a, _b, _c;
    oe(Me) && ((_a = x.value)[A] ?? (_a[A] = x.value[A] = { month: 0, year: 0 }), x.value[A].month = J ?? ((_b = x.value[A]) == null ? void 0 : _b.month), x.value[A].year = pe ?? ((_c = x.value[A]) == null ? void 0 : _c.year));
  }, b = () => {
    _.autoApply && w("select-date");
  }, X = () => {
    W.value && ge(W.value);
  };
  onMounted(() => {
    i.value || (Ie(), X()), c(true), _.focusStartDate && _.startDate && Ie();
  });
  const L = computed(() => {
    var _a, _b, _c;
    return ((_b = (_a = y.value) == null ? void 0 : _a.steps) == null ? void 0 : _b.length) && !((_c = y.value) == null ? void 0 : _c.partial) ? e.flowStep === y.value.steps.length : true;
  }), ve = () => {
    var _a, _b, _c;
    _.autoApply && L.value && w("auto-apply", ((_a = y.value) == null ? void 0 : _a.partial) ? e.flowStep !== ((_c = (_b = y.value) == null ? void 0 : _b.steps) == null ? void 0 : _c.length) : false);
  }, c = (A = false) => {
    if (i.value)
      return Array.isArray(i.value) ? (o.value = i.value, V(A)) : Y(i.value, A);
    if (f.value.count && A && !_.startDate)
      return g(l(), A);
  }, p = () => Array.isArray(i.value) && B.value.enabled ? getMonth(i.value[0]) === getMonth(i.value[1] ?? i.value[0]) : false, S = (A) => {
    const J = addMonths(A, 1);
    return { month: getMonth(J), year: getYear(J) };
  }, g = (A = l(), J = false) => {
    if ((!f.value.count || !f.value.static || J) && ee(0, getMonth(A), getYear(A)), f.value.count && (!i.value || p() || !f.value.solo) && (!f.value.solo || J))
      for (let pe = 1; pe < f.value.count; pe++) {
        const Me = set(l(), { month: P.value(pe - 1), year: O.value(pe - 1) }), Be = add(Me, { months: 1 });
        x.value[pe] = { month: getMonth(Be), year: getYear(Be) };
      }
  }, Y = (A, J) => {
    g(A), de("hours", getHours(A)), de("minutes", getMinutes(A)), de("seconds", getSeconds(A)), f.value.count && J && he();
  }, G = (A) => {
    if (f.value.count) {
      if (f.value.solo) return 0;
      const J = getMonth(A[0]), pe = getMonth(A[1]);
      return Math.abs(pe - J) < f.value.count ? 0 : 1;
    }
    return 1;
  }, v = (A, J) => {
    A[1] && B.value.showLastInRange ? g(A[G(A)], J) : g(A[0], J);
    const pe = (Me, Be) => [
      Me(A[0]),
      (A == null ? void 0 : A[1]) ? Me(A[1]) : M[Be][1]
    ];
    de("hours", pe(getHours, "hours")), de("minutes", pe(getMinutes, "minutes")), de("seconds", pe(getSeconds, "seconds"));
  }, n = (A, J) => {
    if ((B.value.enabled || _.weekPicker) && !Q.value.enabled)
      return v(A, J);
    if (Q.value.enabled && J) {
      const pe = A[A.length - 1];
      return Y(pe, J);
    }
  }, V = (A) => {
    const J = i.value;
    n(J, A), f.value.count && f.value.solo && he();
  }, N = (A, J) => {
    const pe = set(l(), { month: P.value(J), year: O.value(J) }), Me = A < 0 ? addMonths(pe, 1) : subMonths(pe, 1);
    m(getMonth(Me), getYear(Me), A < 0, _.preventMinMaxNavigation) && (ee(J, getMonth(Me), getYear(Me)), d("update-month-year", { instance: J, month: getMonth(Me), year: getYear(Me) }), f.value.count && !f.value.solo && ue(J), h2());
  }, ue = (A) => {
    for (let J = A - 1; J >= 0; J--) {
      const pe = subMonths(set(l(), { month: P.value(J + 1), year: O.value(J + 1) }), 1);
      ee(J, getMonth(pe), getYear(pe));
    }
    for (let J = A + 1; J <= f.value.count - 1; J++) {
      const pe = addMonths(set(l(), { month: P.value(J - 1), year: O.value(J - 1) }), 1);
      ee(J, getMonth(pe), getYear(pe));
    }
  }, he = () => {
    if (Array.isArray(i.value) && i.value.length === 2) {
      const A = l(l(i.value[1] ?? addMonths(i.value[0], 1))), [J, pe] = [getMonth(i.value[0]), getYear(i.value[0])], [Me, Be] = [getMonth(i.value[1]), getYear(i.value[1])];
      (J !== Me || J === Me && pe !== Be) && f.value.solo && ee(1, getMonth(A), getYear(A));
    } else i.value && !Array.isArray(i.value) && (ee(0, getMonth(i.value), getYear(i.value)), g(l()));
  }, Ie = () => {
    _.startDate && (ee(0, getMonth(l(_.startDate)), getYear(l(_.startDate))), f.value.count && ue(0));
  }, Le = (A, J) => {
    if (D.value.monthChangeOnScroll) {
      const pe = Date.now() - s.value.getTime(), Me = Math.abs(A.deltaY);
      let Be = 500;
      Me > 1 && (Be = 100), Me > 100 && (Be = 0), pe > Be && (s.value = /* @__PURE__ */ new Date(), N(
        D.value.monthChangeOnScroll === "inverse" ? A.deltaY : -A.deltaY,
        J
      ));
    }
  }, wt = (A, J, pe = false) => {
    D.value.monthChangeOnArrows && _.vertical === pe && Pt(A, J);
  }, Pt = (A, J) => {
    N(A === "right" ? -1 : 1, J);
  }, ua = (A) => {
    if (F.value.markers)
      return $(A.value, F.value.markers);
  }, ia = (A, J) => {
    switch (_.sixWeeks === true ? "append" : _.sixWeeks) {
      case "prepend":
        return [true, false];
      case "center":
        return [A == 0, true];
      case "fair":
        return [A == 0 || J > A, true];
      case "append":
        return [false, false];
      default:
        return [false, false];
    }
  }, ca = (A, J, pe, Me) => {
    if (_.sixWeeks && A.length < 6) {
      const Be = 6 - A.length, mt = (J.getDay() + 7 - Me) % 7, Qt = 6 - (pe.getDay() + 7 - Me) % 7, [It, ha] = ia(mt, Qt);
      for (let Dt = 1; Dt <= Be; Dt++)
        if (ha ? !!(Dt % 2) == It : It) {
          const Gt = A[0].days[0], ga = xt(addDays(Gt.value, -7), getMonth(J));
          A.unshift({ days: ga });
        } else {
          const Gt = A[A.length - 1], ga = Gt.days[Gt.days.length - 1], sn = xt(addDays(ga.value, 1), getMonth(J));
          A.push({ days: sn });
        }
    }
    return A;
  }, xt = (A, J) => {
    const pe = l(A), Me = [];
    for (let Be = 0; Be < 7; Be++) {
      const mt = addDays(pe, Be), Bt = getMonth(mt) !== J;
      Me.push({
        text: _.hideOffsetDates && Bt ? "" : E(mt),
        value: mt,
        current: !Bt,
        classData: {}
      });
    }
    return Me;
  }, da = (A, J) => {
    const pe = [], Me = l(new Date(J, A)), Be = l(new Date(J, A + 1, 0)), mt = _.weekStart, Bt = startOfWeek(Me, { weekStartsOn: mt }), Qt = (It) => {
      const ha = xt(It, A);
      if (pe.push({ days: ha }), !pe[pe.length - 1].days.some((Dt) => ie(l(Dt.value), ae(Be)))) {
        const Dt = addDays(It, 7);
        Qt(Dt);
      }
    };
    return Qt(Bt), ca(pe, Me, Be, mt);
  }, va = (A) => {
    const J = K(
      { hours: M.hours, minutes: M.minutes, seconds: Tt() },
      l(A.value)
    );
    d("date-click", J), Q.value.enabled ? le(J, Q.value.limit) : i.value = J, r(), nextTick().then(() => {
      ve();
    });
  }, qt = (A) => B.value.noDisabledRange ? ye(o.value[0], A).some((pe) => k(pe)) : false, fa = () => {
    o.value = i.value ? i.value.slice().filter((A) => !!A) : [], o.value.length === 2 && !(B.value.fixedStart || B.value.fixedEnd) && (o.value = []);
  }, ma = (A, J) => {
    const pe = [l(A.value), addDays(l(A.value), +B.value.autoRange)];
    R(pe) ? (J && fe(A.value), o.value = pe) : d("invalid-date", A.value);
  }, fe = (A) => {
    const J = getMonth(l(A)), pe = getYear(l(A));
    if (ee(0, J, pe), f.value.count > 0)
      for (let Me = 1; Me < f.value.count; Me++) {
        const Be = S(
          set(l(A), { year: O.value(Me - 1), month: P.value(Me - 1) })
        );
        ee(Me, Be.month, Be.year);
      }
  }, Ue = (A) => {
    if (qt(A.value) || !z(A.value, i.value, B.value.fixedStart ? 0 : 1))
      return d("invalid-date", A.value);
    o.value = Ae(l(A.value));
  }, rt = (A, J) => {
    if (fa(), B.value.autoRange) return ma(A, J);
    if (B.value.fixedStart || B.value.fixedEnd) return Ue(A);
    o.value[0] ? z(l(A.value), i.value) && !qt(A.value) ? ne(l(A.value), l(o.value[0])) ? (o.value.unshift(l(A.value)), d("range-end", o.value[0])) : (o.value[1] = l(A.value), d("range-end", o.value[1])) : d("invalid-date", A.value) : (o.value[0] = l(A.value), d("range-start", o.value[0]));
  }, Tt = (A = true) => I.value.enableSeconds ? Array.isArray(M.seconds) ? A ? M.seconds[0] : M.seconds[1] : M.seconds : 0, ct = (A) => {
    o.value[A] = K(
      {
        hours: M.hours[A],
        minutes: M.minutes[A],
        seconds: Tt(A !== 1)
      },
      o.value[A]
    );
  }, pa = () => {
    var _a, _b;
    o.value[0] && o.value[1] && +((_a = o.value) == null ? void 0 : _a[0]) > +((_b = o.value) == null ? void 0 : _b[1]) && (o.value.reverse(), d("range-start", o.value[0]), d("range-end", o.value[1]));
  }, Xa = () => {
    var _a, _b, _c;
    o.value.length && (o.value[0] && !o.value[1] ? ct(0) : (ct(0), ct(1), r()), pa(), i.value = o.value.slice(), _e(
      o.value,
      w,
      o.value.length < 2 || ((_a = y.value) == null ? void 0 : _a.steps.length) ? e.flowStep !== ((_c = (_b = y.value) == null ? void 0 : _b.steps) == null ? void 0 : _c.length) : false
    ));
  }, Za = (A, J = false) => {
    if (k(A.value) || !A.current && _.hideOffsetDates)
      return d("invalid-date", A.value);
    if (a.value = structuredClone(A), !B.value.enabled) return va(A);
    Array.isArray(M.hours) && Array.isArray(M.minutes) && !Q.value.enabled && (rt(A, J), Xa());
  }, en = (A, J) => {
    var _a, _b;
    ee(A, J.month, J.year, true), f.value.count && !f.value.solo && ue(A), d("update-month-year", { instance: A, month: J.month, year: J.year }), h2(f.value.solo ? A : void 0);
    const pe = ((_b = (_a = y.value) == null ? void 0 : _a.steps) == null ? void 0 : _b.length) ? y.value.steps[e.flowStep] : void 0;
    !J.fromNav && (pe === Qe.month || pe === Qe.year) && r();
  }, tn = (A) => {
    me({
      value: A
    }), b(), _.multiCalendars && nextTick().then(() => c(true));
  }, an = () => {
    var _a;
    let A = l();
    return ((_a = _.actionRow) == null ? void 0 : _a.nowBtnRound) && (A = roundToNearestMinutes(A, {
      roundingMethod: _.actionRow.nowBtnRound.rounding ?? "ceil",
      nearestTo: _.actionRow.nowBtnRound.roundTo ?? 15
    })), A;
  }, nn = () => {
    const A = an();
    !B.value.enabled && !Q.value.enabled ? i.value = A : i.value && Array.isArray(i.value) && i.value[0] ? Q.value.enabled ? i.value = [...i.value, A] : i.value = ne(A, i.value[0]) ? [A, i.value[0]] : [i.value[0], A] : i.value = [A], b();
  }, rn = () => {
    if (Array.isArray(i.value))
      if (Q.value.enabled) {
        const A = ln();
        i.value[i.value.length - 1] = te(A);
      } else
        i.value = i.value.map((A, J) => A && te(A, J));
    else
      i.value = te(i.value);
    w("time-update");
  }, ln = () => Array.isArray(i.value) && i.value.length ? i.value[i.value.length - 1] : null, on = (A) => {
    let J = "";
    if (B.value.enabled && Array.isArray(i.value))
      for (const pe of Object.keys(A)) {
        const Me = A[pe];
        Array.isArray(Me) && (M[pe][0] !== Me[0] && (J = "range-start"), M[pe][1] !== Me[1] && (J = "range-start"));
      }
    return J;
  };
  return {
    calendars: x,
    modelValue: i,
    month: P,
    year: O,
    time: M,
    disabledTimesConfig: se,
    today: u,
    validateTime: H,
    getCalendarDays: da,
    getMarker: ua,
    handleScroll: Le,
    handleSwipe: Pt,
    handleArrow: wt,
    selectDate: Za,
    updateMonthYear: en,
    presetDate: tn,
    selectCurrentDate: nn,
    updateTime: (A) => {
      const J = on(A);
      Z(A, rn), J && d(J, i.value[J === "range-start" ? 0 : 1]);
    },
    assignMonthAndYear: g,
    setStartTime: X
  };
};
var Yl = () => {
  const {
    isModelAuto: e,
    matchDate: w,
    isDateAfter: h2,
    isDateBefore: r,
    isDateBetween: o,
    isDateEqual: s,
    getWeekFromDate: a,
    getBeforeAndAfterInRange: l
  } = ze(), {
    getDate: d,
    today: x,
    rootProps: P,
    defaults: { multiCalendars: O, multiDates: M, ui: i, highlight: _, safeDates: u, range: T },
    modelValue: f
  } = Se(), { isDisabled: W } = nt(), B = ref(null), D = (c) => {
    !c.current && P.hideOffsetDates || (B.value = c.value);
  }, F = () => {
    B.value = null;
  }, Q = (c) => Array.isArray(f.value) && T.value.enabled && f.value[0] && B.value ? c ? h2(B.value, f.value[0]) : r(B.value, f.value[0]) : true, I = (c, p) => {
    const S = () => f.value ? p ? f.value[0] || null : f.value[1] : null, g = f.value && Array.isArray(f.value) ? S() : null;
    return s(d(c.value), g);
  }, y = (c) => {
    const p = Array.isArray(f.value) ? f.value[0] : null;
    return c ? !r(B.value, p) : true;
  }, m = (c, p = true) => (T.value.enabled || P.weekPicker) && Array.isArray(f.value) && f.value.length === 2 ? P.hideOffsetDates && !c.current ? false : s(d(c.value), f.value[p ? 0 : 1]) : T.value.enabled ? I(c, p) && y(p) || s(c.value, Array.isArray(f.value) ? f.value[0] : null) && Q(p) : false, k = (c, p) => {
    if (Array.isArray(f.value) && f.value[0] && f.value.length === 1) {
      const S = s(c.value, B.value);
      return p ? h2(f.value[0], c.value) && S : r(f.value[0], c.value) && S;
    }
    return false;
  }, R = (c) => !f.value || P.hideOffsetDates && !c.current ? false : T.value.enabled ? P.modelAuto && Array.isArray(f.value) ? s(c.value, f.value[0] ?? x) : false : M.value.enabled && Array.isArray(f.value) ? f.value.some((p) => s(p, c.value)) : s(c.value, f.value ? f.value : x), z = (c) => {
    if (T.value.autoRange || P.weekPicker) {
      if (B.value) {
        if (P.hideOffsetDates && !c.current) return false;
        const p = addDays(B.value, +T.value.autoRange), S = a(d(B.value), P.weekStart);
        return P.weekPicker ? s(S[1], d(c.value)) : s(p, d(c.value));
      }
      return false;
    }
    return false;
  }, Z = (c) => {
    if (T.value.autoRange || P.weekPicker) {
      if (B.value) {
        const p = addDays(B.value, +T.value.autoRange);
        if (P.hideOffsetDates && !c.current) return false;
        const S = a(d(B.value), P.weekStart);
        return P.weekPicker ? h2(c.value, S[0]) && r(c.value, S[1]) : h2(c.value, B.value) && r(c.value, p);
      }
      return false;
    }
    return false;
  }, te = (c) => {
    if (T.value.autoRange || P.weekPicker) {
      if (B.value) {
        if (P.hideOffsetDates && !c.current) return false;
        const p = a(d(B.value), P.weekStart);
        return P.weekPicker ? s(p[0], c.value) : s(B.value, c.value);
      }
      return false;
    }
    return false;
  }, de = (c) => o(f.value, B.value, c.value), ge = () => P.modelAuto && Array.isArray(f.value) ? !!f.value[0] : false, H = () => P.modelAuto ? e(f.value) : true, se = (c) => {
    if (P.weekPicker) return false;
    const p = T.value.enabled ? !m(c) && !m(c, false) : true;
    return !W(c.value) && !R(c) && !(!c.current && P.hideOffsetDates) && p;
  }, E = (c) => T.value.enabled ? P.modelAuto ? ge() && R(c) : false : R(c), ae = (c) => _.value ? w(c.value, u.value.highlight) : false, K = (c) => {
    const p = W(c.value);
    return p && (typeof _.value == "function" ? !_.value(c.value, p) : !_.value.options.highlightDisabled);
  }, ne = (c) => {
    var _a;
    return typeof _.value == "function" ? _.value(c.value) : (_a = _.value.weekdays) == null ? void 0 : _a.includes(c.value.getDay());
  }, ie = (c) => (T.value.enabled || P.weekPicker) && (!(O.value.count > 0) || c.current) && H() && !(!c.current && P.hideOffsetDates) && !R(c) ? de(c) : false, ye = (c) => {
    if (Array.isArray(f.value) && f.value.length === 1) {
      const { before: p, after: S } = l(+T.value.maxRange, f.value[0]);
      return isBefore(c.value, p) || isAfter(c.value, S);
    }
    return false;
  }, _e = (c) => {
    if (Array.isArray(f.value) && f.value.length === 1) {
      const { before: p, after: S } = l(+T.value.minRange, f.value[0]);
      return o([p, S], f.value[0], c.value);
    }
    return false;
  }, Ae = (c) => T.value.enabled && (T.value.maxRange || T.value.minRange) ? T.value.maxRange && T.value.minRange ? ye(c) || _e(c) : T.value.maxRange ? ye(c) : _e(c) : false, le = (c) => {
    const { isRangeStart: p, isRangeEnd: S } = ee(c), g = T.value.enabled ? p || S : false;
    return {
      dp__cell_offset: !c.current,
      dp__pointer: !P.disabled && !(!c.current && P.hideOffsetDates) && !W(c.value) && !Ae(c),
      dp__cell_disabled: W(c.value) || Ae(c),
      dp__cell_highlight: !K(c) && (ae(c) || ne(c)) && !E(c) && !g && !te(c) && !(ie(c) && P.weekPicker) && !S,
      dp__cell_highlight_active: !K(c) && (ae(c) || ne(c)) && E(c),
      dp__today: !P.noToday && s(c.value, x) && c.current,
      "dp--past": r(c.value, x),
      "dp--future": h2(c.value, x)
    };
  }, me = (c) => ({
    dp__active_date: E(c),
    dp__date_hover: se(c)
  }), $ = (c) => {
    if (f.value && !Array.isArray(f.value)) {
      const p = a(f.value, P.weekStart);
      return {
        ...X(c),
        dp__range_start: s(p[0], c.value),
        dp__range_end: s(p[1], c.value),
        dp__range_between_week: h2(c.value, p[0]) && r(c.value, p[1])
      };
    }
    return {
      ...X(c)
    };
  }, oe = (c) => {
    if (f.value && Array.isArray(f.value)) {
      const p = a(f.value[0], P.weekStart), S = f.value[1] ? a(f.value[1], P.weekStart) : [];
      return {
        ...X(c),
        dp__range_start: s(p[0], c.value) || s(S[0], c.value),
        dp__range_end: s(p[1], c.value) || s(S[1], c.value),
        dp__range_between_week: h2(c.value, p[0]) && r(c.value, p[1]) || h2(c.value, S[0]) && r(c.value, S[1]),
        dp__range_between: h2(c.value, p[1]) && r(c.value, S[0])
      };
    }
    return {
      ...X(c)
    };
  }, ee = (c) => {
    const p = O.value.count > 0 ? c.current && m(c) && H() : m(c) && H(), S = O.value.count > 0 ? c.current && m(c, false) && H() : m(c, false) && H();
    return { isRangeStart: p, isRangeEnd: S };
  }, b = (c) => {
    const { isRangeStart: p, isRangeEnd: S } = ee(c);
    return {
      dp__range_start: p,
      dp__range_end: S,
      dp__range_between: ie(c),
      dp__date_hover: s(c.value, B.value) && !p && !S && !P.weekPicker,
      dp__date_hover_start: k(c, true),
      dp__date_hover_end: k(c, false)
    };
  }, X = (c) => ({
    ...b(c),
    dp__cell_auto_range: Z(c),
    dp__cell_auto_range_start: te(c),
    dp__cell_auto_range_end: z(c)
  }), L = (c) => T.value.enabled ? T.value.autoRange ? X(c) : P.modelAuto ? { ...me(c), ...b(c) } : P.weekPicker ? oe(c) : b(c) : P.weekPicker ? $(c) : me(c);
  return {
    setHoverDate: D,
    clearHoverDate: F,
    getDayClassData: (c) => P.hideOffsetDates && !c.current ? {} : {
      ...le(c),
      ...L(c),
      [i.value.dayClass ? i.value.dayClass(c.value, f.value) : ""]: true,
      ...i.value.calendarCell
    }
  };
};
var Ol = { key: 0 };
var xl = defineComponent({
  __name: "DatePicker",
  props: mergeDefaults({
    flowStep: {},
    collapse: { type: Boolean },
    menuWrapRef: {},
    noOverlayFocus: { type: Boolean }
  }, Cr),
  emits: ["mount", "update-flow-step", "reset-flow", "focus-menu", "select-date", "time-update", "auto-apply"],
  setup(e, { expose: w, emit: h2 }) {
    const r = h2, o = e, {
      month: s,
      year: a,
      modelValue: l,
      time: d,
      disabledTimesConfig: x,
      today: P,
      validateTime: O,
      getCalendarDays: M,
      getMarker: i,
      handleArrow: _,
      handleScroll: u,
      handleSwipe: T,
      selectDate: f,
      updateMonthYear: W,
      presetDate: B,
      selectCurrentDate: D,
      updateTime: F,
      assignMonthAndYear: Q,
      setStartTime: I
    } = Cl(o, r, $, oe), y = useSlots(), { setHoverDate: m, getDayClassData: k, clearHoverDate: R } = Yl(), {
      getDate: z,
      rootEmit: Z,
      rootProps: te,
      defaults: { multiCalendars: de, timeConfig: ge }
    } = Se(), { getYears: H, getMonths: se } = ra(), { getCellId: E } = ze(), { mapSlots: ae } = bt(), K = useTemplateRef("calendar-header"), ne = useTemplateRef("calendar"), ie = useTemplateRef("time-picker"), ye = ae(y, "calendar"), _e = ae(y, "monthYear"), Ae = ae(y, "timePicker"), le = (g) => {
      r("mount", g);
    };
    watch(
      de,
      (g, Y) => {
        g.count - Y.count > 0 && Q();
      },
      { deep: true }
    );
    const me = computed(() => (g) => M(s.value(g), a.value(g)).map((Y) => ({
      ...Y,
      days: Y.days.map((G) => (G.marker = i(G), G.classData = k(G), G))
    })));
    function $(g) {
      var _a, _b, _c;
      g || g === 0 ? (_b = (_a = ne.value) == null ? void 0 : _a[g]) == null ? void 0 : _b.triggerTransition(s.value(g), a.value(g)) : (_c = ne.value) == null ? void 0 : _c.forEach((Y, G) => Y == null ? void 0 : Y.triggerTransition(s.value(G), a.value(G)));
    }
    function oe() {
      r("update-flow-step");
    }
    const ee = (g, Y, G = 0) => {
      var _a, _b;
      (_b = (_a = K.value) == null ? void 0 : _a[G]) == null ? void 0 : _b.toggleMonthPicker(g, Y);
    }, b = (g, Y, G = 0) => {
      var _a, _b;
      (_b = (_a = K.value) == null ? void 0 : _a[G]) == null ? void 0 : _b.toggleYearPicker(g, Y);
    }, X = (g, Y, G) => {
      var _a;
      (_a = ie.value) == null ? void 0 : _a.toggleTimePicker(g, Y, G);
    }, L = (g, Y) => {
      var _a;
      if (!te.range) {
        const G = l.value ? l.value : P, v = Y ? z(Y) : G, n = g ? startOfWeek(v, { weekStartsOn: 1 }) : endOfWeek(v, { weekStartsOn: 1 });
        f({
          value: n,
          current: getMonth(v) === s.value(0),
          text: "",
          classData: {}
        }), (_a = document.getElementById(E(n))) == null ? void 0 : _a.focus();
      }
    }, ve = (g) => {
      var _a, _b;
      (_b = (_a = K.value) == null ? void 0 : _a[0]) == null ? void 0 : _b.handleMonthYearChange(g, true);
    }, c = (g) => {
      W(0, { month: s.value(0), year: a.value(0) + (g ? 1 : -1), fromNav: true });
    }, p = (g) => {
      Z("overlay-toggle", { open: false, overlay: g }), r("focus-menu");
    };
    return w({
      clearHoverDate: R,
      presetDate: B,
      selectCurrentDate: D,
      handleArrow: _,
      updateMonthYear: W,
      setStartTime: I,
      toggleMonthPicker: ee,
      toggleYearPicker: b,
      toggleTimePicker: X,
      getSidebarProps: () => ({
        modelValue: l,
        month: s,
        year: a,
        time: d,
        updateTime: F,
        updateMonthYear: W,
        selectDate: f,
        presetDate: B
      }),
      changeMonth: ve,
      changeYear: c,
      selectWeekDate: L
    }), (g, Y) => (openBlock(), createElementBlock(Fragment, null, [
      createVNode(oa, { collapse: e.collapse }, {
        default: withCtx(({ instances: G, wrapClass: v }) => [
          (openBlock(true), createElementBlock(Fragment, null, renderList(G, (n) => (openBlock(), createElementBlock("div", {
            key: n,
            class: normalizeClass(v)
          }, [
            unref(te).hideMonthYearSelect ? createCommentVNode("", true) : (openBlock(), createBlock(Ml, {
              key: 0,
              ref_for: true,
              ref: "calendar-header",
              months: unref(se)(),
              years: unref(H)(),
              month: unref(s)(n),
              year: unref(a)(n),
              instance: n,
              "menu-wrap-ref": e.menuWrapRef,
              onMount: Y[0] || (Y[0] = (V) => le(unref(_t).header)),
              onResetFlow: Y[1] || (Y[1] = (V) => g.$emit("reset-flow")),
              onUpdateMonthYear: (V) => unref(W)(n, V),
              onOverlayClosed: p
            }, createSlots({ _: 2 }, [
              renderList(unref(_e), (V, N) => ({
                name: V,
                fn: withCtx((ue) => [
                  renderSlot(g.$slots, V, mergeProps({ ref_for: true }, ue))
                ])
              }))
            ]), 1032, ["months", "years", "month", "year", "instance", "menu-wrap-ref", "onUpdateMonthYear"])),
            createVNode(Rl, {
              ref_for: true,
              ref: "calendar",
              "mapped-dates": me.value(n),
              instance: n,
              month: unref(s)(n),
              year: unref(a)(n),
              onSelectDate: (V) => unref(f)(V, n !== 1),
              onSetHoverDate: Y[2] || (Y[2] = (V) => unref(m)(V)),
              onHandleScroll: (V) => unref(u)(V, n),
              onHandleSwipe: (V) => unref(T)(V, n),
              onMount: Y[3] || (Y[3] = (V) => le(unref(_t).calendar))
            }, createSlots({ _: 2 }, [
              renderList(unref(ye), (V, N) => ({
                name: V,
                fn: withCtx((ue) => [
                  renderSlot(g.$slots, V, mergeProps({ ref_for: true }, { ...ue }))
                ])
              }))
            ]), 1032, ["mapped-dates", "instance", "month", "year", "onSelectDate", "onHandleScroll", "onHandleSwipe"])
          ], 2))), 128))
        ]),
        _: 3
      }, 8, ["collapse"]),
      unref(ge).enableTimePicker ? (openBlock(), createElementBlock("div", Ol, [
        g.$slots["time-picker"] ? renderSlot(g.$slots, "time-picker", normalizeProps(mergeProps({ key: 0 }, { time: unref(d), updateTime: unref(F) }))) : (openBlock(), createBlock(Ga, {
          key: 1,
          ref: "time-picker",
          hours: unref(d).hours,
          minutes: unref(d).minutes,
          seconds: unref(d).seconds,
          "disabled-times-config": unref(x),
          "validate-time": unref(O),
          "no-overlay-focus": e.noOverlayFocus,
          onMount: Y[4] || (Y[4] = (G) => le(unref(_t).timePicker)),
          "onUpdate:hours": Y[5] || (Y[5] = (G) => unref(F)({ hours: G, minutes: unref(d).minutes, seconds: unref(d).seconds })),
          "onUpdate:minutes": Y[6] || (Y[6] = (G) => unref(F)({ hours: unref(d).hours, minutes: G, seconds: unref(d).seconds })),
          "onUpdate:seconds": Y[7] || (Y[7] = (G) => unref(F)({ hours: unref(d).hours, minutes: unref(d).minutes, seconds: G })),
          onResetFlow: Y[8] || (Y[8] = (G) => g.$emit("reset-flow"))
        }, createSlots({ _: 2 }, [
          renderList(unref(Ae), (G, v) => ({
            name: G,
            fn: withCtx((n) => [
              renderSlot(g.$slots, G, normalizeProps(guardReactiveProps(n)))
            ])
          }))
        ]), 1032, ["hours", "minutes", "seconds", "disabled-times-config", "validate-time", "no-overlay-focus"]))
      ])) : createCommentVNode("", true)
    ], 64));
  }
});
var Bl = (e, w) => {
  const {
    getDate: h2,
    modelValue: r,
    year: o,
    calendars: s,
    defaults: { highlight: a, range: l, multiDates: d }
  } = Se(), { isDateBetween: x, isDateEqual: P } = ze(), { checkRangeAutoApply: O, handleMultiDatesSelect: M, setMonthOrYearRange: i } = sa();
  zt();
  const { isDisabled: _ } = nt(), { formatQuarterText: u } = kt(), {
    selectYear: T,
    groupedYears: f,
    showYearPicker: W,
    isDisabled: B,
    toggleYearPicker: D,
    handleYearSelect: F,
    handleYear: Q,
    setStartDate: I
  } = Qa(w), y = ref();
  onMounted(() => {
    I();
  });
  const m = computed(() => (E) => r.value ? Array.isArray(r.value) ? r.value.some((ae) => isSameQuarter(E, ae)) : isSameQuarter(r.value, E) : false), k = (E) => {
    if (l.value.enabled) {
      if (Array.isArray(r.value)) {
        const ae = P(E, r.value[0]) || P(E, r.value[1]);
        return x(r.value, y.value, E) && !ae;
      }
      return false;
    }
    return false;
  }, R = (E, ae) => E.quarter === getQuarter(ae) && E.year === getYear(ae), z = (E) => typeof a.value == "function" ? a.value({ quarter: getQuarter(E), year: getYear(E) }) : a.value.quarters.some((ae) => R(ae, E)), Z = computed(() => (E) => {
    const ae = set(h2(), { year: o.value(E) });
    return eachQuarterOfInterval({
      start: startOfYear(ae),
      end: endOfYear(ae)
    }).map((K) => {
      const ne = startOfQuarter(K), ie = endOfQuarter(K), ye = _(K), _e = k(ne), Ae = z(ne);
      return {
        text: u(ne, ie),
        value: ne,
        active: m.value(ne),
        highlighted: Ae,
        disabled: ye,
        isBetween: _e
      };
    });
  }), te = (E) => {
    M(E, d.value.limit), w("auto-apply", true);
  }, de = (E) => {
    r.value = i(E), O(r.value, w, r.value.length < 2);
  }, ge = (E) => {
    r.value = E, w("auto-apply");
  };
  return {
    groupedYears: f,
    year: o,
    isDisabled: B,
    quarters: Z,
    showYearPicker: W,
    modelValue: r,
    selectYear: T,
    toggleYearPicker: D,
    handleYearSelect: F,
    handleYear: Q,
    setHoverDate: (E) => {
      y.value = E;
    },
    selectQuarter: (E, ae, K) => {
      if (!K)
        return s.value[ae].month = getMonth(endOfQuarter(E)), d.value.enabled ? te(E) : l.value.enabled ? de(E) : ge(E);
    }
  };
};
var Il = { class: "dp--quarter-items" };
var Vl = ["data-test-id", "disabled", "onClick", "onMouseover"];
var El = defineComponent({
  __name: "QuarterPicker",
  props: {
    flowStep: {},
    collapse: { type: Boolean },
    menuWrapRef: {},
    noOverlayFocus: { type: Boolean }
  },
  emits: ["reset-flow", "auto-apply"],
  setup(e, { expose: w, emit: h2 }) {
    const r = h2, o = e, {
      defaults: { config: s }
    } = Se(), a = useSlots(), { mapSlots: l } = bt(), { boolHtmlAttribute: d } = Ot(), x = l(a, "yearMode"), {
      groupedYears: P,
      year: O,
      isDisabled: M,
      quarters: i,
      modelValue: _,
      showYearPicker: u,
      setHoverDate: T,
      selectQuarter: f,
      toggleYearPicker: W,
      handleYearSelect: B,
      handleYear: D
    } = Bl(o, r);
    return w({ getSidebarProps: () => ({
      modelValue: _,
      year: O,
      selectQuarter: f,
      handleYearSelect: B,
      handleYear: D
    }) }), (Q, I) => (openBlock(), createBlock(oa, {
      collapse: e.collapse,
      stretch: ""
    }, {
      default: withCtx(({ instances: y, wrapClass: m }) => [
        (openBlock(true), createElementBlock(Fragment, null, renderList(y, (k) => (openBlock(), createElementBlock("div", {
          key: k,
          class: normalizeClass(m)
        }, [
          createBaseVNode("div", {
            class: "dp-quarter-picker-wrap",
            style: normalizeStyle({ minHeight: `${unref(s).modeHeight}px` })
          }, [
            Q.$slots["top-extra"] ? renderSlot(Q.$slots, "top-extra", {
              key: 0,
              value: unref(_)
            }) : createCommentVNode("", true),
            createBaseVNode("div", null, [
              createVNode(qa, {
                items: unref(P)(k),
                instance: k,
                "show-year-picker": unref(u)[k],
                year: unref(O)(k),
                "is-disabled": (R) => unref(M)(k, R),
                onHandleYear: (R) => unref(D)(k, R),
                onYearSelect: (R) => unref(B)(R, k),
                onToggleYearPicker: (R) => unref(W)(k, R == null ? void 0 : R.flow, R == null ? void 0 : R.show)
              }, createSlots({ _: 2 }, [
                renderList(unref(x), (R, z) => ({
                  name: R,
                  fn: withCtx((Z) => [
                    renderSlot(Q.$slots, R, mergeProps({ ref_for: true }, Z))
                  ])
                }))
              ]), 1032, ["items", "instance", "show-year-picker", "year", "is-disabled", "onHandleYear", "onYearSelect", "onToggleYearPicker"])
            ]),
            createBaseVNode("div", Il, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(i)(k), (R, z) => (openBlock(), createElementBlock("div", { key: z }, [
                createBaseVNode("button", {
                  type: "button",
                  class: normalizeClass(["dp--qr-btn", {
                    "dp--qr-btn-active": R.active,
                    "dp--qr-btn-between": R.isBetween,
                    "dp--qr-btn-disabled": R.disabled,
                    "dp--highlighted": R.highlighted
                  }]),
                  "data-test-id": R.value,
                  disabled: unref(d)(R.disabled),
                  onClick: (Z) => unref(f)(R.value, k, R.disabled),
                  onMouseover: (Z) => unref(T)(R.value)
                }, [
                  Q.$slots.quarter ? renderSlot(Q.$slots, "quarter", {
                    key: 0,
                    value: R.value,
                    text: R.text
                  }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                    createTextVNode(toDisplayString(R.text), 1)
                  ], 64))
                ], 42, Vl)
              ]))), 128))
            ])
          ], 4)
        ], 2))), 128))
      ]),
      _: 3
    }, 8, ["collapse"]));
  }
});
var Fl = ["id", "tabindex", "role", "aria-label"];
var Nl = {
  key: 0,
  class: "dp--menu-load-container"
};
var Wl = {
  key: 1,
  class: "dp--menu-header"
};
var Ll = ["data-dp-mobile"];
var Hl = {
  key: 0,
  class: "dp__sidebar_left"
};
var Kl = ["data-dp-mobile"];
var jl = ["data-test-id", "data-dp-mobile", "onClick", "onKeydown"];
var zl = { class: "dp__instance_calendar" };
var Ul = {
  key: 2,
  class: "dp__sidebar_right"
};
var ql = {
  key: 3,
  class: "dp__action_extra"
};
var Ql = defineComponent({
  __name: "DatepickerMenu",
  props: {
    collapse: { type: Boolean },
    noOverlayFocus: { type: Boolean },
    getInputRect: { type: Function }
  },
  emits: ["close-picker", "select-date", "auto-apply", "time-update", "menu-blur"],
  setup(e, { expose: w, emit: h2 }) {
    const r = h2, o = useSlots(), {
      state: s,
      rootProps: a,
      defaults: { textInput: l, inline: d, config: x, ui: P, ariaLabels: O },
      setState: M
    } = Se(), { isMobile: i } = na(), { mapSlots: _ } = bt(), { handleEventPropagation: u, getElWithin: T, checkStopPropagation: f, checkKeyDown: W } = Fe(), { arrowRight: B, arrowLeft: D, arrowDown: F, arrowUp: Q } = yt(), I = useTemplateRef("inner-menu"), y = useTemplateRef("dp-menu"), m = useTemplateRef("dyn-cmp"), k = ref(0), R = ref(false), z = ref(false), { flowStep: Z, updateFlowStep: te, childMount: de, resetFlow: ge, handleFlow: H } = Kn(m), se = (v) => {
      z.value = true, x.value.allowPreventDefault && v.preventDefault(), f(v, x.value, true);
    };
    onMounted(() => {
      R.value = true, E(), globalThis.addEventListener("resize", E);
      const v = unrefElement(y);
      v && !l.value.enabled && !d.value.enabled && (M("menuFocused", true), K()), v && (v.addEventListener("pointerdown", se), v.addEventListener("mousedown", se)), document.addEventListener("mousedown", Y);
    }), onUnmounted(() => {
      globalThis.removeEventListener("resize", E), document.removeEventListener("mousedown", Y);
      const v = unrefElement(y);
      v && (v.removeEventListener("pointerdown", se), v.removeEventListener("mousedown", se));
    });
    const E = () => {
      const v = unrefElement(I);
      v && (k.value = v.getBoundingClientRect().width);
    }, ae = computed(() => a.monthPicker ? el : a.yearPicker ? al : a.timePicker ? hl : a.quarterPicker ? El : xl), K = () => {
      const v = unrefElement(y);
      v && v.focus({ preventScroll: true });
    }, ne = computed(() => {
      var _a;
      return ((_a = m.value) == null ? void 0 : _a.getSidebarProps()) || {};
    }), ie = _(o, "action"), ye = computed(() => a.monthPicker || a.yearPicker ? _(o, "monthYear") : a.timePicker ? _(o, "timePicker") : _(o, "shared")), _e = computed(() => ({
      dp__menu_disabled: a.disabled,
      dp__menu_readonly: a.readonly,
      "dp-menu-loading": a.loading
    })), Ae = computed(
      () => ({
        dp__menu: true,
        dp__menu_index: !d.value.enabled,
        dp__relative: d.value.enabled,
        ...P.value.menu
      })
    ), le = (v) => {
      f(v, x.value, true);
    }, me = (v) => {
      x.value.escClose && (r("close-picker"), u(v, x.value));
    }, $ = (v) => {
      if (a.arrowNavigation) {
        if (v === qe.up) return Q();
        if (v === qe.down) return F();
        if (v === qe.left) return D();
        if (v === qe.right) return B();
      } else v === qe.left || v === qe.up ? X("handleArrow", qe.left, 0, v === qe.up) : X("handleArrow", qe.right, 0, v === qe.down);
    }, oe = (v) => {
      M("shiftKeyInMenu", v.shiftKey), !a.hideMonthYearSelect && v.code === xe.tab && v.target.classList.contains("dp__menu") && s.shiftKeyInMenu && (v.preventDefault(), f(v, x.value, true), r("close-picker"));
    }, ee = (v) => {
      var _a, _b, _c;
      (_a = m.value) == null ? void 0 : _a.toggleTimePicker(false, false), (_b = m.value) == null ? void 0 : _b.toggleMonthPicker(false, false, v), (_c = m.value) == null ? void 0 : _c.toggleYearPicker(false, false, v);
    }, b = (v, n = 0) => {
      var _a, _b, _c;
      return v === "month" ? (_a = m.value) == null ? void 0 : _a.toggleMonthPicker(false, true, n) : v === "year" ? (_b = m.value) == null ? void 0 : _b.toggleYearPicker(false, true, n) : v === "time" ? (_c = m.value) == null ? void 0 : _c.toggleTimePicker(true, false) : ee(n);
    }, X = (v, ...n) => {
      var _a, _b;
      ((_a = m.value) == null ? void 0 : _a[v]) && ((_b = m.value) == null ? void 0 : _b[v](...n));
    }, L = () => {
      X("selectCurrentDate");
    }, ve = (v) => {
      X("presetDate", toValue(v));
    }, c = () => {
      X("clearHoverDate");
    }, p = (v, n) => {
      X("updateMonthYear", v, n);
    }, S = (v, n) => {
      v.preventDefault(), $(n);
    }, g = (v) => {
      var _a, _b, _c;
      if (oe(v), v.key === xe.home || v.key === xe.end)
        return X(
          "selectWeekDate",
          v.key === xe.home,
          v.target.getAttribute("id")
        );
      switch ((v.key === xe.pageUp || v.key === xe.pageDown) && (v.shiftKey ? (X("changeYear", v.key === xe.pageUp), (_a = T(y.value, "overlay-year")) == null ? void 0 : _a.focus()) : (X("changeMonth", v.key === xe.pageUp), (_b = T(y.value, v.key === xe.pageUp ? "action-prev" : "action-next")) == null ? void 0 : _b.focus()), v.target.getAttribute("id") && ((_c = y.value) == null ? void 0 : _c.focus({ preventScroll: true }))), v.key) {
        case xe.esc:
          return me(v);
        case xe.arrowLeft:
          return S(v, qe.left);
        case xe.arrowRight:
          return S(v, qe.right);
        case xe.arrowUp:
          return S(v, qe.up);
        case xe.arrowDown:
          return S(v, qe.down);
        default:
          return;
      }
    }, Y = (v) => {
      var _a;
      d.value.enabled && !d.value.input && !((_a = y.value) == null ? void 0 : _a.contains(v.target)) && z.value && (z.value = false, r("menu-blur"));
    };
    return w({
      updateMonthYear: p,
      switchView: b,
      onValueCleared: () => {
        var _a, _b;
        (_b = (_a = m.value) == null ? void 0 : _a.setStartTime) == null ? void 0 : _b.call(_a);
      },
      handleFlow: H
    }), (v, n) => {
      var _a, _b, _c;
      return openBlock(), createElementBlock("div", {
        id: unref(a).menuId,
        ref: "dp-menu",
        tabindex: unref(d).enabled ? void 0 : "0",
        role: unref(d).enabled ? void 0 : "dialog",
        "aria-label": (_a = unref(O)) == null ? void 0 : _a.menu,
        class: normalizeClass(Ae.value),
        onMouseleave: c,
        onClick: le,
        onKeydown: g
      }, [
        (unref(a).disabled || unref(a).readonly) && unref(d).enabled || unref(a).loading ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(_e.value)
        }, [
          unref(a).loading ? (openBlock(), createElementBlock("div", Nl, [...n[5] || (n[5] = [
            createBaseVNode("span", { class: "dp--menu-loader" }, null, -1)
          ])])) : createCommentVNode("", true)
        ], 2)) : createCommentVNode("", true),
        v.$slots["menu-header"] ? (openBlock(), createElementBlock("div", Wl, [
          renderSlot(v.$slots, "menu-header")
        ])) : createCommentVNode("", true),
        renderSlot(v.$slots, "arrow"),
        createBaseVNode("div", {
          ref: "inner-menu",
          class: normalizeClass({
            dp__menu_content_wrapper: ((_b = unref(a).presetDates) == null ? void 0 : _b.length) || !!v.$slots["left-sidebar"] || !!v.$slots["right-sidebar"],
            "dp--menu-content-wrapper-collapsed": e.collapse && (((_c = unref(a).presetDates) == null ? void 0 : _c.length) || !!v.$slots["left-sidebar"] || !!v.$slots["right-sidebar"])
          }),
          "data-dp-mobile": unref(i),
          style: normalizeStyle({ "--dp-menu-width": `${k.value}px` })
        }, [
          v.$slots["left-sidebar"] ? (openBlock(), createElementBlock("div", Hl, [
            renderSlot(v.$slots, "left-sidebar", normalizeProps(guardReactiveProps(ne.value)))
          ])) : createCommentVNode("", true),
          unref(a).presetDates.length ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: normalizeClass({ "dp--preset-dates-collapsed": e.collapse, "dp--preset-dates": true }),
            "data-dp-mobile": unref(i)
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(unref(a).presetDates, (V, N) => (openBlock(), createElementBlock(Fragment, { key: N }, [
              V.slot ? renderSlot(v.$slots, V.slot, {
                key: 0,
                presetDate: ve,
                label: V.label,
                value: V.value
              }) : (openBlock(), createElementBlock("button", {
                key: 1,
                type: "button",
                style: normalizeStyle(V.style || {}),
                class: normalizeClass(["dp__btn dp--preset-range", { "dp--preset-range-collapsed": e.collapse }]),
                "data-test-id": V.testId ?? void 0,
                "data-dp-mobile": unref(i),
                onClick: withModifiers((ue) => ve(V.value), ["prevent"]),
                onKeydown: (ue) => unref(W)(ue, () => ve(V.value), true)
              }, toDisplayString(V.label), 47, jl))
            ], 64))), 128))
          ], 10, Kl)) : createCommentVNode("", true),
          createBaseVNode("div", zl, [
            (openBlock(), createBlock(resolveDynamicComponent(ae.value), {
              ref: "dyn-cmp",
              "flow-step": unref(Z),
              collapse: e.collapse,
              "no-overlay-focus": e.noOverlayFocus,
              "menu-wrap-ref": y.value,
              onMount: unref(de),
              onUpdateFlowStep: unref(te),
              onResetFlow: unref(ge),
              onFocusMenu: K,
              onSelectDate: n[0] || (n[0] = (V) => v.$emit("select-date")),
              onAutoApply: n[1] || (n[1] = (V) => v.$emit("auto-apply", V)),
              onTimeUpdate: n[2] || (n[2] = (V) => v.$emit("time-update"))
            }, createSlots({ _: 2 }, [
              renderList(ye.value, (V, N) => ({
                name: V,
                fn: withCtx((ue) => [
                  renderSlot(v.$slots, V, normalizeProps(guardReactiveProps({ ...ue })))
                ])
              }))
            ]), 1064, ["flow-step", "collapse", "no-overlay-focus", "menu-wrap-ref", "onMount", "onUpdateFlowStep", "onResetFlow"]))
          ]),
          v.$slots["right-sidebar"] ? (openBlock(), createElementBlock("div", Ul, [
            renderSlot(v.$slots, "right-sidebar", normalizeProps(guardReactiveProps(ne.value)))
          ])) : createCommentVNode("", true),
          v.$slots["action-extra"] ? (openBlock(), createElementBlock("div", ql, [
            v.$slots["action-extra"] ? renderSlot(v.$slots, "action-extra", {
              key: 0,
              selectCurrentDate: L
            }) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ], 14, Ll),
        !unref(a).autoApply || unref(x).keepActionRow ? (openBlock(), createBlock(jr, {
          key: 2,
          "menu-mount": R.value,
          "calendar-width": k.value,
          onClosePicker: n[3] || (n[3] = (V) => v.$emit("close-picker")),
          onSelectDate: n[4] || (n[4] = (V) => v.$emit("select-date")),
          onSelectNow: L
        }, createSlots({ _: 2 }, [
          renderList(unref(ie), (V, N) => ({
            name: V,
            fn: withCtx((ue) => [
              renderSlot(v.$slots, V, normalizeProps(guardReactiveProps({ ...ue })))
            ])
          }))
        ]), 1032, ["menu-mount", "calendar-width"])) : createCommentVNode("", true)
      ], 42, Fl);
    };
  }
});
var Gl = ["data-dp-mobile"];
var Jl = defineComponent({
  __name: "VueDatePicker",
  setup(e, { expose: w }) {
    const {
      rootEmit: h2,
      setState: r,
      inputValue: o,
      modelValue: s,
      rootProps: a,
      defaults: { inline: l, config: d, textInput: x, range: P, multiDates: O, teleport: M, floatingConfig: i }
    } = Se(), { clearArrowNav: _ } = yt(), { validateDate: u, isValidTime: T } = nt(), { menuTransition: f, showTransition: W } = jt(), { isMobile: B } = na(), { mapSlots: D } = bt(), { findNextFocusableElement: F, getNumVal: Q } = Fe(), I = useSlots(), y = ref(false), m = ref(l.value.enabled || a.centered), k = toRef(a, "modelValue"), R = toRef(a, "timezone"), z = useTemplateRef("dp-menu-wrap"), Z = useTemplateRef("dp-menu"), te = useTemplateRef("input-cmp"), de = useTemplateRef("picker-wrapper"), ge = useTemplateRef("menu-arrow"), H = ref(false), se = ref(false), E = ref(false), ae = ref(true), K = (fe) => (i.value.arrow && (i.value.arrow === true ? fe.push(arrow3({ element: ge })) : fe.push(arrow3({ element: i.value.arrow }))), fe), { floatingStyles: ne, middlewareData: ie, placement: ye, y: _e } = useFloating(
      te,
      z,
      {
        strategy: i.value.strategy,
        placement: i.value.placement,
        middleware: K([offset2(i.value.offset), flip2(), shift2()]),
        whileElementsMounted: autoUpdate
      }
    );
    onMounted(() => {
      me(a.modelValue), nextTick().then(() => {
        l.value.enabled || globalThis.addEventListener("resize", p);
      }), l.value.enabled && (y.value = true), globalThis.addEventListener("keyup", S), globalThis.addEventListener("keydown", g);
    }), onUnmounted(() => {
      l.value.enabled || globalThis.removeEventListener("resize", p), globalThis.removeEventListener("keyup", S), globalThis.removeEventListener("keydown", g);
    });
    const Ae = D(I, "all", a.presetDates), le = D(I, "input");
    watch(
      [k, R],
      () => {
        me(k.value);
      },
      { deep: true }
    ), watch([ye, _e], () => {
      !l.value.enabled && !a.centered && ae.value && (m.value = false, nextTick().then(() => {
        ae.value = false, m.value = true;
      }));
    });
    const { parseExternalModelValue: me, emitModelValue: $, formatInputValue: oe, checkBeforeEmit: ee } = Wn(), b = computed(
      () => ({
        dp__main: true,
        dp__theme_dark: a.dark,
        dp__theme_light: !a.dark,
        dp__flex_display: l.value.enabled,
        "dp--flex-display-collapsed": E.value,
        dp__flex_display_with_input: l.value.input
      })
    ), X = computed(() => a.dark ? "dp__theme_dark" : "dp__theme_light"), L = computed(() => l.value.enabled && (a.timePicker || a.monthPicker || a.yearPicker || a.quarterPicker)), ve = () => {
      var _a, _b;
      return ((_b = (_a = te.value) == null ? void 0 : _a.$el) == null ? void 0 : _b.getBoundingClientRect()) ?? { width: 0, left: 0, right: 0 };
    }, c = () => {
      y.value && d.value.closeOnScroll && Ie();
    }, p = () => {
      var _a;
      const fe = ((_a = Z.value) == null ? void 0 : _a.$el.getBoundingClientRect().width) ?? 0;
      E.value = document.body.offsetWidth <= fe;
    }, S = (fe) => {
      fe.key === "Tab" && !l.value.enabled && !a.teleport && d.value.tabOutClosesMenu && (de.value.contains(document.activeElement) || Ie()), se.value = fe.shiftKey;
    }, g = (fe) => {
      se.value = fe.shiftKey;
    }, Y = () => {
      !a.disabled && !a.readonly && (ae.value = true, y.value = true, y.value && h2("open"), y.value || he(), me(a.modelValue));
    }, G = () => {
      var _a, _b;
      o.value = "", he(), (_a = Z.value) == null ? void 0 : _a.onValueCleared(), (_b = te.value) == null ? void 0 : _b.setParsedDate(null), h2("update:model-value", null), h2("cleared"), d.value.closeOnClearValue && Ie();
    }, v = () => {
      const fe = s.value;
      return !fe || !Array.isArray(fe) && u(fe) ? true : Array.isArray(fe) ? O.value.enabled || fe.length === 2 && u(fe[0]) && u(fe[1]) ? true : P.value.partialRange && !a.timePicker ? u(fe[0]) : false : false;
    }, n = () => {
      ee() && v() ? ($(), Ie()) : h2("invalid-select");
    }, V = (fe) => {
      N(), $(), d.value.closeOnAutoApply && !fe && Ie();
    }, N = () => {
      te.value && x.value.enabled && te.value.setParsedDate(s.value);
    }, ue = (fe = false) => {
      a.autoApply && T(s.value) && v() && (P.value.enabled && Array.isArray(s.value) ? (P.value.partialRange || s.value.length === 2) && V(fe) : V(fe));
    }, he = () => {
      x.value.enabled || (s.value = null);
    }, Ie = (fe = false) => {
      ae.value = true, fe && s.value && d.value.setDateOnMenuClose && n(), l.value.enabled || (y.value && (y.value = false, r("menuFocused", false), r("shiftKeyInMenu", false), _(), h2("closed"), o.value && me(k.value)), he(), h2("blur"));
    }, Le = (fe, Ue, rt = false) => {
      if (!fe) {
        s.value = null;
        return;
      }
      const Tt = Array.isArray(fe) ? !fe.some((pa) => !u(pa)) : u(fe), ct = T(fe);
      Tt && ct ? (r("isTextInputDate", true), s.value = fe, Ue ? (H.value = rt, n(), h2("text-submit")) : a.autoApply && ue(true), nextTick().then(() => {
        r("isTextInputDate", false);
      })) : h2("invalid-date", fe);
    }, wt = () => {
      a.autoApply && T(s.value) && $(), N();
    }, Pt = () => y.value ? Ie() : Y(), ua = (fe) => {
      s.value = fe;
    }, ia = () => {
      x.value.enabled && (r("isInputFocused", true), oe()), h2("focus");
    }, ca = () => {
      var _a;
      x.value.enabled && (r("isInputFocused", false), me(a.modelValue), H.value && ((_a = F(de.value, se.value)) == null ? void 0 : _a.focus())), h2("blur");
    }, xt = (fe, Ue) => {
      Z.value && Z.value.updateMonthYear(Ue ?? 0, {
        month: Q(fe.month),
        year: Q(fe.year)
      });
    }, da = (fe) => {
      me(fe ?? a.modelValue);
    }, va = (fe, Ue) => {
      var _a;
      (_a = Z.value) == null ? void 0 : _a.switchView(fe, Ue);
    }, qt = (fe, Ue) => {
      if (y.value)
        return d.value.onClickOutside ? d.value.onClickOutside(fe, Ue) : Ie(true);
    }, fa = (fe = 0) => {
      var _a;
      (_a = Z.value) == null ? void 0 : _a.handleFlow(fe);
    }, ma = () => z;
    return onClickOutside(z, (fe) => qt(v, fe), {
      ignore: [te]
    }), w({
      closeMenu: Ie,
      selectDate: n,
      clearValue: G,
      openMenu: Y,
      onScroll: c,
      formatInputValue: oe,
      // exposed for testing purposes
      updateInternalModelValue: ua,
      // modify internal modelValue
      setMonthYear: xt,
      parseModel: da,
      switchView: va,
      toggleMenu: Pt,
      handleFlow: fa,
      getDpWrapMenuRef: ma
    }), (fe, Ue) => (openBlock(), createElementBlock("div", {
      ref: "picker-wrapper",
      class: normalizeClass(b.value),
      "data-datepicker-instance": "",
      "data-dp-mobile": unref(B)
    }, [
      createVNode(Nr, {
        ref: "input-cmp",
        "is-menu-open": y.value,
        onClear: G,
        onOpen: Y,
        onSetInputDate: Le,
        onSetEmptyDate: unref($),
        onSelectDate: n,
        onToggle: Pt,
        onClose: Ie,
        onFocus: ia,
        onBlur: ca,
        onRealBlur: Ue[0] || (Ue[0] = (rt) => unref(r)("isInputFocused", false))
      }, createSlots({ _: 2 }, [
        renderList(unref(le), (rt, Tt) => ({
          name: rt,
          fn: withCtx((ct) => [
            renderSlot(fe.$slots, rt, normalizeProps(guardReactiveProps(ct)))
          ])
        }))
      ]), 1032, ["is-menu-open", "onSetEmptyDate"]),
      (openBlock(), createBlock(Teleport, {
        to: unref(M),
        disabled: !unref(M)
      }, [
        createBaseVNode("div", {
          ref: "dp-menu-wrap",
          class: normalizeClass({
            "dp--menu-wrapper": !unref(l).enabled,
            dp__outer_menu_wrap: true,
            "dp--centered": unref(a).centered
          }),
          style: normalizeStyle(!unref(l).enabled && !unref(a).centered ? unref(ne) : void 0)
        }, [
          createVNode(Transition, {
            name: unref(f)(unref(ye).startsWith("top")),
            css: unref(W) && !unref(l).enabled && !unref(a).centered && m.value
          }, {
            default: withCtx(() => [
              y.value && m.value ? (openBlock(), createBlock(Ql, {
                key: 0,
                ref: "dp-menu",
                class: normalizeClass({ [X.value]: true }),
                "no-overlay-focus": L.value,
                collapse: E.value,
                "get-input-rect": ve,
                onClosePicker: Ie,
                onSelectDate: n,
                onAutoApply: ue,
                onTimeUpdate: wt,
                onMenuBlur: Ue[1] || (Ue[1] = (rt) => unref(h2)("blur"))
              }, createSlots({ _: 2 }, [
                renderList(unref(Ae), (rt, Tt) => ({
                  name: rt,
                  fn: withCtx((ct) => [
                    renderSlot(fe.$slots, rt, normalizeProps(guardReactiveProps({ ...ct })))
                  ])
                })),
                !unref(l).enabled && !unref(a).centered && unref(i).arrow === true ? {
                  name: "arrow",
                  fn: withCtx(() => {
                    var _a, _b;
                    return [
                      createBaseVNode("div", {
                        ref: "menu-arrow",
                        class: normalizeClass({
                          dp__arrow_top: unref(ye) === "bottom",
                          dp__arrow_bottom: unref(ye) === "top"
                        }),
                        style: normalizeStyle({
                          left: ((_a = unref(ie).arrow) == null ? void 0 : _a.x) != null ? `${unref(ie).arrow.x}px` : "",
                          top: ((_b = unref(ie).arrow) == null ? void 0 : _b.y) != null ? `${unref(ie).arrow.y}px` : ""
                        })
                      }, null, 6)
                    ];
                  }),
                  key: "0"
                } : void 0
              ]), 1032, ["class", "no-overlay-focus", "collapse"])) : createCommentVNode("", true)
            ]),
            _: 3
          }, 8, ["name", "css"])
        ], 6)
      ], 8, ["to", "disabled"]))
    ], 10, Gl));
  }
});
var lo = defineComponent({
  __name: "VueDatePickerRoot",
  props: mergeDefaults({
    multiCalendars: { type: [Boolean, Number, String, Object] },
    modelValue: {},
    modelType: {},
    dark: { type: Boolean },
    transitions: { type: [Boolean, Object] },
    ariaLabels: {},
    hideNavigation: {},
    timezone: {},
    vertical: { type: Boolean },
    hideMonthYearSelect: { type: Boolean },
    disableYearSelect: { type: Boolean },
    yearRange: {},
    autoApply: { type: Boolean },
    disabledDates: { type: [Array, Function] },
    startDate: {},
    hideOffsetDates: { type: Boolean },
    noToday: { type: Boolean },
    allowedDates: {},
    markers: {},
    presetDates: {},
    flow: {},
    preventMinMaxNavigation: { type: Boolean },
    reverseYears: { type: Boolean },
    weekPicker: { type: Boolean },
    filters: {},
    arrowNavigation: { type: Boolean },
    highlight: { type: [Function, Object] },
    teleport: { type: [String, Boolean] },
    centered: { type: Boolean },
    locale: {},
    weekStart: {},
    weekNumbers: { type: [Boolean, Object] },
    dayNames: { type: [Function, Array] },
    monthPicker: { type: Boolean },
    yearPicker: { type: Boolean },
    modelAuto: { type: Boolean },
    formats: {},
    multiDates: { type: [Boolean, Object] },
    minDate: {},
    maxDate: {},
    minTime: {},
    maxTime: {},
    inputAttrs: {},
    timeConfig: {},
    placeholder: {},
    timePicker: { type: Boolean },
    range: { type: [Boolean, Object] },
    menuId: {},
    disabled: { type: Boolean },
    readonly: { type: Boolean },
    inline: { type: [Boolean, Object] },
    textInput: { type: [Boolean, Object] },
    sixWeeks: { type: [Boolean, String] },
    actionRow: {},
    focusStartDate: { type: Boolean },
    disabledTimes: { type: [Function, Array] },
    calendar: { type: Function },
    config: {},
    quarterPicker: { type: Boolean },
    yearFirst: { type: Boolean },
    loading: { type: Boolean },
    ui: {},
    floating: {}
  }, Yr),
  emits: ["update:model-value", "internal-model-change", "text-submit", "text-input", "open", "closed", "focus", "blur", "cleared", "flow-step", "update-month-year", "invalid-select", "invalid-fixed-range", "invalid-date", "tooltip-open", "tooltip-close", "am-pm-change", "range-start", "range-end", "date-click", "overlay-toggle", "invalid"],
  setup(e, { expose: w, emit: h2 }) {
    const r = h2, o = e;
    Hn(o, r);
    const s = useSlots(), { mapSlots: a } = bt(), l = a(s, "root", o.presetDates), d = useTemplateRef("date-picker");
    return w(xr(d)), (x, P) => (openBlock(), createBlock(Jl, { ref: "date-picker" }, createSlots({ _: 2 }, [
      renderList(unref(l), (O, M) => ({
        name: O,
        fn: withCtx((i) => [
          renderSlot(x.$slots, O, normalizeProps(guardReactiveProps(i)))
        ])
      }))
    ]), 1536));
  }
});
export {
  TZDate,
  lo as VueDatePicker
};
//# sourceMappingURL=@vuepic_vue-datepicker.js.map
